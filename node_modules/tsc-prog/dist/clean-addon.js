"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.protectSensitiveFolders = void 0;
const path_1 = require("./utils/path");
const fs_1 = require("./utils/fs");
const path_2 = require("path");
const log_1 = require("./utils/log");
/**
 * Delete files and folders created by a previous build.
 * @internal
 */
function cleanTargets(targets) {
    if (!targets.length)
        return;
    for (const target of targets) {
        console.log('Clean:', (0, path_1.relativeToCWD)(target));
        (0, fs_1.rmrf)(target);
    }
    // Pause on windows to try to work around eventual lingering file handles
    if (process.platform === 'win32') {
        const until = Date.now() + 500;
        while (Date.now() < until) { }
    }
}
exports.default = cleanTargets;
/**
 * @internal
 */
function protectSensitiveFolders(targets, rootDir, basePath) {
    const cwd = process.cwd();
    let protectedDirs = [cwd, ...(0, path_1.parentPaths)(cwd)];
    if (basePath && basePath !== cwd) {
        protectedDirs.push(basePath, ...(0, path_1.parentPaths)(basePath));
    }
    // compilerOptions properties returns unix separators in windows paths so we must normalize
    rootDir = rootDir ? (0, path_2.normalize)(rootDir) : undefined;
    if (rootDir && rootDir !== cwd && rootDir !== basePath) {
        protectedDirs.push(rootDir, ...(0, path_1.parentPaths)(rootDir));
    }
    // Dedupe
    protectedDirs = [...new Set(protectedDirs)];
    for (const target of targets) {
        for (const dir of protectedDirs) {
            if (target === dir) {
                throw log_1.Color.red(`You cannot delete ${target}`);
            }
        }
    }
}
exports.protectSensitiveFolders = protectSensitiveFolders;
