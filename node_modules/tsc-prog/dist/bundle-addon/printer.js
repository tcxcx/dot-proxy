"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.print = void 0;
const ts = require("typescript");
/**
 * @internal
 */
function print({ typeDirectivesCollection, libDirectivesCollection, importsCollection, exportsCollection, globalsCollection, augmentationsCollection, extrasCollection, newLine, }) {
    const stringBuilder = new StringBuilder(newLine);
    extrasCollection = filterExtras(extrasCollection, [
        typeDirectivesCollection,
        libDirectivesCollection,
        importsCollection,
        exportsCollection,
        globalsCollection,
        augmentationsCollection,
    ]);
    for (const directive of typeDirectivesCollection) {
        stringBuilder.addLine(directive);
    }
    if (typeDirectivesCollection.size)
        stringBuilder.addLine();
    for (const directive of libDirectivesCollection) {
        stringBuilder.addLine(directive);
    }
    if (libDirectivesCollection.size)
        stringBuilder.addLine();
    for (const declaration of importsCollection) {
        stringBuilder.addLine(declaration);
    }
    if (importsCollection.size)
        stringBuilder.addLine();
    for (const extra of extrasCollection) {
        if (extra.position === 'after-imports') {
            stringBuilder.addLine(extra.declaration).addLine();
        }
    }
    for (const [declaration, comment] of exportsCollection) {
        if (comment)
            stringBuilder.addLine(comment);
        stringBuilder.addLine(declaration).addLine();
    }
    for (const extra of extrasCollection) {
        if (extra.position === 'after-exports') {
            stringBuilder.addLine(extra.declaration).addLine();
        }
    }
    if (globalsCollection === null || globalsCollection === void 0 ? void 0 : globalsCollection.size) {
        stringBuilder.addLine('declare global {');
        for (const [declaration, comment] of globalsCollection) {
            if (comment)
                stringBuilder.addLine(comment);
            stringBuilder.addLine(declaration);
        }
        stringBuilder.addLine('}').addLine();
    }
    if (augmentationsCollection === null || augmentationsCollection === void 0 ? void 0 : augmentationsCollection.size) {
        for (const declaration of augmentationsCollection) {
            stringBuilder.addLine(declaration).addLine();
        }
    }
    stringBuilder.addLine('export {}');
    return stringBuilder.toString();
}
exports.print = print;
function filterExtras(extras, collections) {
    if (!extras)
        return [];
    const declarationsCollections = collections.map((col) => {
        return col instanceof Set ? Array.from(col) : col instanceof Map ? Array.from(col.values()) : [];
    });
    return extras.filter((extra) => {
        return declarationsCollections.every((declarations) => !declarations.includes(extra.declaration));
    });
}
/**
 * Allows a large text string to be constructed incrementally by appending small chunks.
 * The final string can be obtained by calling StringBuilder.toString().
 *
 * A naive approach might use the `+=` operator to append strings:
 * This would have the downside of copying the entire string each time a chunk is appended.
 *
 * @internal
 */
class StringBuilder {
    constructor(newLineKind) {
        this.chunks = [];
        this.newLine =
            newLineKind === ts.NewLineKind.CarriageReturnLineFeed
                ? '\r\n'
                : newLineKind === ts.NewLineKind.LineFeed
                    ? '\n'
                    : ts.sys.newLine;
    }
    add(text) {
        this.chunks.push(text);
        return this;
    }
    addLine(text = '') {
        if (text.length > 0)
            this.add(text);
        return this.add(this.newLine);
    }
    toString() {
        if (this.chunks.length === 0)
            return '';
        if (this.chunks.length > 1) {
            const joined = this.chunks.join('');
            this.chunks.length = 1;
            this.chunks[0] = joined;
        }
        return this.chunks[0];
    }
}
