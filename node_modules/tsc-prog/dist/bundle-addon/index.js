"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.bundleDts = exports.getDtsInterceptor = void 0;
const ts = require("typescript");
const log_1 = require("../utils/log");
const directive_collector_1 = require("./directive-collector");
const external_augmentation_collector_1 = require("./external-augmentation-collector");
const symbol_collector_1 = require("./symbol-collector");
const declaration_collector_1 = require("./declaration-collector");
const printer_1 = require("./printer");
const path_1 = require("../utils/path");
/**
 * Intercepts the declaration file to a cache instead of writing it.
 * @internal
 */
function getDtsInterceptor(dtsCache) {
    // https://github.com/microsoft/TypeScript/blob/v3.6.4/src/compiler/program.ts#L151-L171
    return (fileName, data, writeByteOrderMark, onError, sourceFiles) => {
        try {
            if (fileName.endsWith(ts.Extension.Dts) || fileName.endsWith('.d.ts.map')) {
                dtsCache.set(fileName, data);
            }
            else {
                ts.sys.writeFile(fileName, data, writeByteOrderMark);
            }
        }
        catch (err) {
            if (onError)
                onError(err.message);
        }
    };
}
exports.getDtsInterceptor = getDtsInterceptor;
/**
 * @internal
 */
function bundleDts(program, dtsCache, { entryPoint, fallbackOnError = true, globals: keepGlobals = true, augmentations: keepAugmentations = true, extras, }) {
    const dtsOutDir = getDtsOutDir(program);
    const dtsProgram = createDtsProgram(program, dtsCache);
    const dtsOptions = dtsProgram.getCompilerOptions();
    let entryPoints = typeof entryPoint === 'string' ? [entryPoint] : entryPoint;
    entryPoints = entryPoints.map((ep) => {
        ep = ep.replace(/(\.js|\.ts|\.d\.ts)$/m, '.d.ts');
        return (0, path_1.ensureAbsolutePath)(ep, dtsOutDir);
    });
    try {
        // Retrieve all bundles before writing them, to fail on error before any IO.
        entryPoints
            .map((path) => {
            const entryFile = dtsProgram.getSourceFile(path);
            if (!entryFile)
                throw Error('Unable to load entry point:' + path);
            const directives = (0, directive_collector_1.collectDirectives)(dtsProgram);
            const augmentationsCollection = keepAugmentations ? (0, external_augmentation_collector_1.collectExternalAugmentations)(dtsProgram) : undefined;
            const symbols = new symbol_collector_1.SymbolCollector(entryFile, dtsProgram);
            const { declarations } = new declaration_collector_1.DeclarationCollector(symbols, entryFile, dtsProgram, keepGlobals, keepAugmentations);
            const globalsCollection = keepGlobals ? declarations.globals : undefined;
            const bundled = (0, printer_1.print)({
                typeDirectivesCollection: directives.typeRef,
                libDirectivesCollection: directives.libRef,
                importsCollection: declarations.imports,
                exportsCollection: declarations.exports,
                globalsCollection,
                augmentationsCollection,
                extrasCollection: extras,
                newLine: dtsOptions.newLine,
            });
            return [path, bundled];
        })
            .forEach(([path, bundled]) => {
            ts.sys.writeFile(path, bundled);
        });
        if (dtsOptions.listEmittedFiles) {
            console.log('Emitted files:\n' + entryPoints.join('\n'));
        }
    }
    catch (error) {
        if (!fallbackOnError)
            throw log_1.Color.red(error);
        console.error(log_1.Color.red(error.stack));
        console.log('Fallback to original declaration files');
        dtsCache.forEach((data, path) => ts.sys.writeFile(path, data));
        if (dtsOptions.listEmittedFiles) {
            console.log('Emitted files:\n' + Array.from(dtsCache.keys()).join('\n'));
        }
    }
}
exports.bundleDts = bundleDts;
/**
 * @internal
 */
function createDtsProgram(program, dtsCache) {
    const options = program.getCompilerOptions();
    // https://stackoverflow.com/a/53764522/4776628
    const host = ts.createCompilerHost(options, true);
    const readFile0 = host.readFile;
    host.readFile = (fileName) => {
        if (dtsCache.has(fileName))
            return dtsCache.get(fileName);
        return readFile0.call(host, fileName);
    };
    const fileExists0 = host.fileExists;
    host.fileExists = (fileName) => {
        if (dtsCache.has(fileName))
            return true;
        return fileExists0.call(host, fileName);
    };
    const getSourceFile0 = host.getSourceFile;
    host.getSourceFile = (fileName, languageVersion, onError, shouldCreate) => {
        if (dtsCache.has(fileName)) {
            return ts.createSourceFile(fileName, dtsCache.get(fileName), options.target || /* default */ ts.ScriptTarget.ES5, true, ts.ScriptKind.TS);
        }
        return getSourceFile0.call(host, fileName, languageVersion, onError, shouldCreate);
    };
    const rootNames = Array.from(dtsCache.keys());
    return ts.createProgram({ rootNames, options, host });
}
/**
 * Declaration output folder is either `declarationDir`, `outDir`, or the original root folder.
 * @internal
 */
function getDtsOutDir(program) {
    const { declarationDir, outDir } = program.getCompilerOptions();
    return declarationDir || outDir || program.getCommonSourceDirectory();
}
