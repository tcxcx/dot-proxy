"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getModuleNameFromSpecifier = exports.getModuleSpecifier = exports.getModuleName = exports.getModifier = exports.getDeclarationName = exports.getDeclarationIdentifier = exports.getNextKeyword = exports.getNextToken = exports.findFirstParent = exports.findFirstChild = exports.lookForProperty = void 0;
const ts = require("typescript");
const syntax_check_1 = require("./syntax-check");
/**
 * From `A` in `type T = A.a`, retrieves the root `A.a` and the property `a`.
 * @returns root/parent reference, and the property found.
 * @internal
 */
function lookForProperty(ref) {
    let refRoot;
    let refProp;
    if (ts.isImportTypeNode(ref)) {
        refRoot = ref;
        if (!ref.qualifier)
            return;
        refProp = ts.isQualifiedName(ref.qualifier)
            ? ref.qualifier.right
            : ts.isIdentifier(ref.qualifier)
                ? ref.qualifier
                : undefined;
        if (!refProp)
            return;
    }
    else {
        refRoot = findFirstParent(ref, ts.isQualifiedName);
        if (!refRoot)
            return;
        refProp = refRoot.right;
    }
    return [refRoot, refProp];
}
exports.lookForProperty = lookForProperty;
/**
 * Does a depth-first search of the children of the specified node.
 * @internal
 */
function findFirstChild(node, predicate, sourceFile = node.getSourceFile()) {
    for (const child of node.getChildren(sourceFile)) {
        if (predicate(child))
            return child;
        const grandChild = findFirstChild(child, predicate, sourceFile);
        if (grandChild)
            return grandChild;
    }
    return undefined;
}
exports.findFirstChild = findFirstChild;
/**
 * @internal
 */
function findFirstParent(node, predicate) {
    let current = node.parent;
    while (current) {
        if (predicate(current))
            return current;
        current = current.parent;
    }
    return undefined;
}
exports.findFirstParent = findFirstParent;
/**
 * @internal
 */
function getNextToken(node, sourceFile = node.getSourceFile()) {
    const children = node.parent.getChildren(sourceFile);
    for (const child of children) {
        if (child.end > node.end && child.kind !== ts.SyntaxKind.JSDocComment) {
            if ((0, syntax_check_1.isTokenNode)(child))
                return child;
            // Next token is nested in another node
            return getNextToken(child, sourceFile);
        }
    }
}
exports.getNextToken = getNextToken;
/**
 * @internal
 */
function getNextKeyword(node, sourceFile = node.getSourceFile()) {
    const children = node.parent.getChildren(sourceFile);
    for (const child of children) {
        if (child.end > node.end) {
            if ((0, syntax_check_1.isKeywordNode)(child))
                return child;
            continue;
        }
    }
}
exports.getNextKeyword = getNextKeyword;
/**
 * @see https://github.com/Microsoft/TypeScript/blob/v3.6.4/src/compiler/utilities.ts#L5216-L5219
 * @internal
 */
function getDeclarationIdentifier(node) {
    const name = ts.getNameOfDeclaration(node);
    return name && ts.isIdentifier(name) ? name : undefined;
}
exports.getDeclarationIdentifier = getDeclarationIdentifier;
/**
 * Try to get A in `export default A`.
 * @internal
 */
function getDeclarationName(node) {
    const name = ts.getNameOfDeclaration(node);
    return name && ts.isIdentifier(name) ? name.escapedText : undefined;
}
exports.getDeclarationName = getDeclarationName;
/**
 * @internal
 */
function getModifier(node, kind) {
    if (!node.modifiers)
        return;
    for (const modifier of node.modifiers) {
        if (modifier.kind === kind)
            return modifier;
    }
}
exports.getModifier = getModifier;
/**
 * Get module name from any import/export declaration part. Could be internal or external.
 * Example: X in `export * from "X"`.
 *
 * @param strict - throw an error if node is not part of an import/export declaration.
 * @internal
 */
function getModuleName(node, strict = false) {
    if (ts.isNamespaceExportDeclaration(node))
        return node.name.text;
    const moduleSpecifier = getModuleSpecifier(node, strict);
    return getModuleNameFromSpecifier(moduleSpecifier);
}
exports.getModuleName = getModuleName;
/**
 * @param strict - throw an error if node is not part of an import/export node.
 * @internal
 */
function getModuleSpecifier(node, strict = false) {
    // https://github.com/Microsoft/TypeScript/blob/v3.6.4/src/compiler/utilities.ts#L2149
    if (ts.isImportDeclaration(node) || ts.isExportDeclaration(node)) {
        return node.moduleSpecifier;
    }
    else if (ts.isImportEqualsDeclaration(node)) {
        return ts.isExternalModuleReference(node.moduleReference) ? node.moduleReference.expression : undefined;
    }
    else if (ts.isImportSpecifier(node)) {
        return node.parent.parent.parent.moduleSpecifier;
    }
    else if (ts.isExportSpecifier(node) || ts.isNamespaceImport(node) || ts.isNamedImports(node)) {
        return node.parent.parent.moduleSpecifier;
    }
    else if (ts.isImportClause(node) || ts.isNamedExports(node)) {
        return node.parent.moduleSpecifier;
    }
    else if (ts.isImportTypeNode(node)) {
        return ts.isLiteralTypeNode(node.argument) ? node.argument.literal : undefined;
    }
    else if (node.parent && ts.isImportTypeNode(node.parent)) {
        if (ts.isLiteralTypeNode(node)) {
            return node.literal;
        }
        else if (ts.isEntityName(node)) {
            const { argument } = node.parent;
            return ts.isLiteralTypeNode(argument) ? argument.literal : undefined;
        }
        else {
            return undefined;
        }
    }
    else {
        if (strict) {
            throw Error(`${node.getText()} (kind: ${node.kind}) is not part of an import or export declaration`);
        }
    }
}
exports.getModuleSpecifier = getModuleSpecifier;
/**
 * @internal
 */
function getModuleNameFromSpecifier(moduleSpecifier) {
    if (moduleSpecifier && ts.isStringLiteralLike(moduleSpecifier)) {
        return ts.getTextOfIdentifierOrLiteral(moduleSpecifier);
    }
}
exports.getModuleNameFromSpecifier = getModuleNameFromSpecifier;
