"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.isKeywordNode = exports.isTokenNode = exports.hasModuleSpecifier = exports.isKeywordTypeNode = exports.isTopLevelNamedDeclaration = exports.isExternalLibraryAugmentation = exports.isTopLevelNonVariableDeclaration = exports.isExported = exports.isTopLevelDeclarationStatement = exports.isTopLevelVariableDeclaration = exports.isExportedTopLevelDeclaration = exports.isTopLevelDeclaration = void 0;
const ts = require("typescript");
/**
 * @see https://github.com/microsoft/TypeScript/blob/v3.5.3/src/services/refactors/moveToNewFile.ts#L644
 * @internal
 */
function isTopLevelDeclaration(node) {
    return ((isTopLevelNonVariableDeclaration(node) && ts.isSourceFile(node.parent)) ||
        (isTopLevelVariableDeclaration(node) && ts.isSourceFile(node.parent.parent.parent)));
}
exports.isTopLevelDeclaration = isTopLevelDeclaration;
/**
 * @internal
 */
function isExportedTopLevelDeclaration(node) {
    return ((isTopLevelNonVariableDeclaration(node) && isExported(node)) ||
        (isTopLevelVariableDeclaration(node) && isExported(node.parent.parent)));
}
exports.isExportedTopLevelDeclaration = isExportedTopLevelDeclaration;
/**
 * @internal
 */
function isTopLevelVariableDeclaration(node) {
    return (ts.isVariableDeclaration(node) &&
        ts.isVariableDeclarationList(node.parent) &&
        ts.isVariableStatement(node.parent.parent));
}
exports.isTopLevelVariableDeclaration = isTopLevelVariableDeclaration;
/**
 * @internal
 */
function isTopLevelDeclarationStatement(node) {
    return isTopLevelNonVariableDeclaration(node) || ts.isVariableStatement(node);
}
exports.isTopLevelDeclarationStatement = isTopLevelDeclarationStatement;
/**
 * @see https://github.com/microsoft/TypeScript/blob/v3.5.3/src/services/refactors/moveToNewFile.ts#L733
 * @internal
 */
function isExported(dec) {
    return ts.hasModifier(dec, ts.ModifierFlags.Export);
}
exports.isExported = isExported;
/**
 * @internal
 */
function isTopLevelNonVariableDeclaration(node) {
    switch (node.kind) {
        case ts.SyntaxKind.FunctionDeclaration:
        case ts.SyntaxKind.ClassDeclaration:
        case ts.SyntaxKind.ModuleDeclaration:
        case ts.SyntaxKind.EnumDeclaration:
        case ts.SyntaxKind.TypeAliasDeclaration:
        case ts.SyntaxKind.InterfaceDeclaration:
        case ts.SyntaxKind.ImportEqualsDeclaration:
            return true;
        default:
            return false;
    }
}
exports.isTopLevelNonVariableDeclaration = isTopLevelNonVariableDeclaration;
/**
 * Accepts ambient declarations like `declare "library"` and not `declare global` or `declare "./relative-module"`.
 * @internal
 */
function isExternalLibraryAugmentation(node) {
    return (ts.isAmbientModule(node) && !ts.isGlobalScopeAugmentation(node) && !ts.isExternalModuleNameRelative(node.name.text));
}
exports.isExternalLibraryAugmentation = isExternalLibraryAugmentation;
function isTopLevelNamedDeclaration(node) {
    switch (node.kind) {
        case ts.SyntaxKind.FunctionDeclaration:
        case ts.SyntaxKind.ClassDeclaration:
        case ts.SyntaxKind.EnumDeclaration:
        case ts.SyntaxKind.TypeAliasDeclaration:
        case ts.SyntaxKind.InterfaceDeclaration:
        case ts.SyntaxKind.ModuleDeclaration:
        case ts.SyntaxKind.VariableDeclaration:
            return true;
        default:
            return false;
    }
}
exports.isTopLevelNamedDeclaration = isTopLevelNamedDeclaration;
/**
 * @internal
 */
function isKeywordTypeNode(node) {
    switch (node.kind) {
        case ts.SyntaxKind.AnyKeyword:
        case ts.SyntaxKind.UnknownKeyword:
        case ts.SyntaxKind.NumberKeyword:
        case ts.SyntaxKind.BigIntKeyword:
        case ts.SyntaxKind.ObjectKeyword:
        case ts.SyntaxKind.BooleanKeyword:
        case ts.SyntaxKind.StringKeyword:
        case ts.SyntaxKind.SymbolKeyword:
        case ts.SyntaxKind.ThisKeyword:
        case ts.SyntaxKind.VoidKeyword:
        case ts.SyntaxKind.UndefinedKeyword:
        case ts.SyntaxKind.NullKeyword:
        case ts.SyntaxKind.NeverKeyword:
            return true;
        default:
            return false;
    }
}
exports.isKeywordTypeNode = isKeywordTypeNode;
/**
 * @internal
 */
function hasModuleSpecifier(node) {
    if (ts.isImportDeclaration(node) || ts.isExportDeclaration(node)) {
        return !!node.moduleSpecifier;
    }
    if (ts.isImportSpecifier(node)) {
        return !!node.parent.parent.parent.moduleSpecifier;
    }
    if (ts.isExportSpecifier(node)) {
        return !!node.parent.parent.moduleSpecifier;
    }
    return false;
}
exports.hasModuleSpecifier = hasModuleSpecifier;
/**
 * Ensures that the node has no children.
 * @see https://github.com/ajafff/tsutils/blob/v3.17.1/util/util.ts#L17-L19
 * @internal
 */
function isTokenNode(node) {
    return node.kind >= ts.SyntaxKind.FirstToken && node.kind <= ts.SyntaxKind.LastToken;
}
exports.isTokenNode = isTokenNode;
/**
 * @internal
 * @see https://github.com/ajafff/tsutils/blob/v3.17.1/util/util.ts#L37-L39
 */
function isKeywordNode(node) {
    return node.kind >= ts.SyntaxKind.FirstKeyword && node.kind <= ts.SyntaxKind.LastKeyword;
}
exports.isKeywordNode = isKeywordNode;
