"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.readdirPaths = exports.rmrf = exports.cp = void 0;
const fs = require("fs");
const path_1 = require("path");
const path_2 = require("./path");
/**
 * Copy file, create parent folders if necessary.
 * @internal
 */
function cp(srcFilePath, destFilePath, overwrite = false) {
    const parentDir = (0, path_1.dirname)(destFilePath);
    fs.mkdirSync(parentDir, { recursive: true }); // no EEXIST error issue with recursive option
    fs.copyFileSync(srcFilePath, destFilePath, overwrite ? 0 : fs.constants.COPYFILE_EXCL);
}
exports.cp = cp;
/**
 * Delete file/folder recursively.
 * @internal
 */
function rmrf(path) {
    // TODO: rely on ENOENT instead
    // https://nodejs.org/dist/latest/docs/api/fs.html#fs_fs_exists_path_callback
    if (!fs.existsSync(path))
        return;
    if (tryIsDirectory(path))
        deleteRecursive(path);
    else
        tryDeleteFile(path);
    function deleteRecursive(dirPath) {
        const paths = readdirPaths(dirPath);
        for (const path_ of paths) {
            if (tryIsDirectory(path_))
                deleteRecursive(path_);
            else
                tryDeleteFile(path_);
        }
        tryDeleteEmptyDir(dirPath);
    }
}
exports.rmrf = rmrf;
/**
 * `readdir` with full paths instead of names.
 * @internal
 */
function readdirPaths(dir) {
    return fs.readdirSync(dir).map((name) => (0, path_1.join)(dir, name));
}
exports.readdirPaths = readdirPaths;
/**
 * @internal
 */
function tryIsDirectory(path) {
    const stats = fsSyncRetry(fs.lstatSync, path, ['EPERM'], 2);
    return stats.isDirectory();
}
/**
 * @internal
 */
function tryDeleteFile(filePath) {
    fsSyncRetry(fs.unlinkSync, filePath, ['EBUSY', 'EPERM']);
}
/**
 * @internal
 */
function tryDeleteEmptyDir(dirPath) {
    fsSyncRetry(fs.rmdirSync, dirPath, ['EBUSY', 'EPERM', 'ENOTEMPTY']);
}
/**
 * Retry fs sync operations on some error codes, to bypass locks (especially on windows).
 * Inspired from https://github.com/isaacs/rimraf
 * @internal
 */
function fsSyncRetry(fsSyncFn, path, errorCodes, tries = 13) {
    let round = 1;
    do {
        if (round > 4) {
            console.log(`Try ${fsSyncFn.name} on ${(0, path_2.relativeToCWD)(path)} for the ${round}th time (out of ${tries})`);
        }
        try {
            return fsSyncFn(path);
        }
        catch (err) {
            if (!errorCodes.includes(err.code) || round > tries)
                throw err;
            fixWindowsEPERM(path);
            pause(round * 100);
            round++;
        }
    } while (true);
    function pause(ms) {
        const until = Date.now() + ms;
        while (Date.now() < until) { }
    }
    function fixWindowsEPERM(path_) {
        if (process.platform === 'win32')
            fs.chmodSync(path_, 0o666);
    }
}
