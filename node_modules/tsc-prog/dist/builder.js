"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.emit = exports.createProgramFromConfig = exports.build = void 0;
const ts = require("typescript");
const path_1 = require("./utils/path");
const log_1 = require("./utils/log");
const clean_addon_1 = require("./clean-addon");
const copy_addon_1 = require("./copy-addon");
const bundle_addon_1 = require("./bundle-addon");
/**
 * Compiles .ts files by creating a compilation object with the compiler API and emitting .js files.
 * @public
 */
function build(options) {
    const program = createProgramFromConfig(options);
    emit(program, options);
}
exports.build = build;
/**
 * Creates a compilation object using the compiler API.
 * @public
 */
function createProgramFromConfig({ basePath, configFilePath, compilerOptions, include, exclude, files, extends: extend, // cuz keyword
references, host, }) {
    let config = {};
    if (configFilePath) {
        configFilePath = (0, path_1.ensureAbsolutePath)(configFilePath, basePath);
        console.log(`Retrieving ${configFilePath}`);
        const readResult = ts.readConfigFile(configFilePath, ts.sys.readFile);
        if (readResult.error) {
            const isTTY = !!ts.sys.writeOutputIsTTY && ts.sys.writeOutputIsTTY();
            (0, log_1.logDiagnostics)([readResult.error], isTTY);
        }
        config = readResult.config;
    }
    config.compilerOptions = Object.assign({}, config.compilerOptions, compilerOptions);
    if (include)
        config.include = include;
    if (exclude)
        config.exclude = exclude;
    if (files)
        config.files = files;
    if (extend)
        config.extends = extend;
    if (references)
        config.references = references;
    const { options, fileNames, projectReferences, errors } = ts.parseJsonConfigFileContent(config, ts.sys, basePath, undefined, configFilePath);
    if (errors && errors.length) {
        const isTTY = !!ts.sys.writeOutputIsTTY && ts.sys.writeOutputIsTTY();
        (0, log_1.logDiagnostics)(errors, isTTY);
    }
    const program = ts.createProgram({
        options,
        rootNames: fileNames,
        projectReferences,
        host,
    });
    program[copy_addon_1.excludeKey] = config.exclude;
    return program;
}
exports.createProgramFromConfig = createProgramFromConfig;
/**
 * Compiles TypeScript files and emits diagnostics if any.
 * @public
 */
function emit(program, { basePath, clean, copyOtherToOutDir, bundleDeclaration } = {}) {
    const options = program.getCompilerOptions();
    if (copyOtherToOutDir && !options.outDir) {
        throw log_1.Color.red('Cannot copy: you must define `outDir` in the compiler options');
    }
    // Write .d.ts files to an in memory Map in case of bundling.
    const dtsCache = new Map();
    let dtsInterceptor;
    if (bundleDeclaration) {
        if (!options.declaration) {
            throw log_1.Color.red('Cannot bundle declarations: you must turn `declaration` on in the compiler options');
        }
        if (options.declarationMap) {
            console.warn(log_1.Color.yellow("`declarationMap` won't work with declaration bundling"));
        }
        dtsInterceptor = (0, bundle_addon_1.getDtsInterceptor)(dtsCache);
    }
    if (clean) {
        let targets = [];
        if (Array.isArray(clean)) {
            targets = clean.map((t) => (0, path_1.ensureAbsolutePath)(t, basePath));
        }
        else {
            if (clean.outDir && options.outDir)
                targets.push(options.outDir);
            if (clean.outFile && options.outFile)
                targets.push(options.outFile);
            if (clean.declarationDir && options.declarationDir)
                targets.push(options.declarationDir);
        }
        (0, clean_addon_1.protectSensitiveFolders)(targets, options.rootDir, basePath);
        (0, clean_addon_1.default)(targets);
    }
    if (options.listFiles) {
        console.log('Files to compile:\n' + program.getRootFileNames().join('\n'));
    }
    console.log('Compilation started');
    // tslint:disable-next-line: prefer-const
    let { diagnostics, emitSkipped, emittedFiles } = program.emit(undefined, dtsInterceptor);
    if (options.listEmittedFiles && emittedFiles) {
        if (bundleDeclaration) {
            emittedFiles = emittedFiles.filter((path) => !dtsCache.has(path));
        }
        console.log('Emitted files:\n' + emittedFiles.join('\n'));
    }
    // https://github.com/dsherret/ts-morph/issues/384
    const allDiagnostics = ts.getPreEmitDiagnostics(program).concat(diagnostics);
    (0, log_1.logDiagnostics)(allDiagnostics, options.pretty);
    if (!options.noEmit && emitSkipped) {
        throw log_1.Color.red('Compilation failed');
    }
    if (copyOtherToOutDir) {
        console.log('Copying other files to `outDir`');
        const copiedFiles = (0, copy_addon_1.default)(program);
        if (options.listEmittedFiles) {
            console.log('Copied files:\n' + copiedFiles.join('\n'));
        }
    }
    if (bundleDeclaration) {
        console.log('Bundling declarations');
        (0, bundle_addon_1.bundleDts)(program, dtsCache, bundleDeclaration);
    }
    if (allDiagnostics.length) {
        console.log(log_1.Color.yellow(`Compilation done with ${allDiagnostics.length} errors`));
    }
    else {
        console.log(log_1.Color.green('Compilation successful'));
    }
}
exports.emit = emit;
