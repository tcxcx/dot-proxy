{
  "version": 3,
  "sources": ["../src/index.ts", "../src/state/stateFactory.ts", "../src/internal/share-latest.ts", "../src/internal/empty-value.ts", "../src/state/stateSingle.ts", "../src/state/index.ts"],
  "sourcesContent": ["export { state } from \"./state\"\n", "import { Observable } from \"rxjs\"\nimport shareLatest from \"@/internal/share-latest\"\nimport { StateObservable } from \"@/StateObservable\"\n\nfunction cloneProps<T>(\n  internal: StateObservable<T>,\n  external: StateObservable<T>,\n) {\n  external.getValue = internal.getValue\n  external.getRefCount = internal.getRefCount\n  external.getComplete$ = internal.getComplete$\n  if ((internal as any).getDefaultValue) {\n    ;(external as any).getDefaultValue = (internal as any).getDefaultValue\n  }\n}\n\n/**\n * Accepts: A factory function that returns an Observable.\n *\n * Returns [1, 2]\n * 1. A React Hook function with the same parameters as the factory function.\n *  This hook will yield the latest update from the observable returned from\n *  the factory function.\n * 2. A `sharedLatest` version of the observable generated by the factory\n *  function that can be used for composing other streams that depend on it.\n *  The shared subscription is closed as soon as there are no subscribers to\n *  that observable.\n *\n * @param getObservable Factory of observables. The arguments of this function\n *  will be the ones used in the hook.\n *\n * @remarks If the Observable doesn't synchronously emit a value upon the first\n * subscription, then the hook will leverage React Suspense while it's waiting\n * for the first value.\n */\nexport default function connectFactoryObservable<A extends [], O>(\n  getObservable: (...args: A) => Observable<O>,\n  defaultValue: O | ((...args: A) => O),\n) {\n  const cache = new NestedMap<A, StateObservable<O>>()\n  const getDefaultValue = (\n    typeof defaultValue === \"function\" ? defaultValue : () => defaultValue\n  ) as (...args: A) => O\n\n  const getSharedObservables$ = (input: A): StateObservable<O> => {\n    for (let i = input.length - 1; input[i] === undefined && i > -1; i--) {\n      input.splice(-1)\n    }\n    const keys = [input.length, ...input] as any as A\n    const cachedVal = cache.get(keys)\n\n    if (cachedVal !== undefined) {\n      return cachedVal\n    }\n\n    const sharedObservable$ = shareLatest(\n      new Observable<O>((observer) =>\n        getObservable(...input).subscribe(observer),\n      ),\n      getDefaultValue(...input),\n      () => {\n        cache.delete(keys)\n      },\n    )\n\n    const publicShared$ = new Observable<O>((subscriber) => {\n      const inCache = cache.get(keys)\n      let source$: StateObservable<O> = sharedObservable$\n\n      if (!inCache) {\n        cache.set(keys, result)\n      } else if (inCache !== publicShared$) {\n        source$ = inCache\n        cloneProps(source$, publicShared$)\n      }\n\n      return source$.subscribe(subscriber)\n    }) as StateObservable<O>\n    cloneProps(sharedObservable$, publicShared$)\n\n    const result: StateObservable<O> = publicShared$\n\n    cache.set(keys, result)\n    return result\n  }\n\n  return (...input: A) => getSharedObservables$(input)\n}\n\nclass NestedMap<K extends [], V extends Object> {\n  private root: Map<K, any>\n  constructor() {\n    this.root = new Map()\n  }\n\n  get(keys: K[]): V | undefined {\n    let current: any = this.root\n    for (let i = 0; i < keys.length; i++) {\n      current = current.get(keys[i])\n      if (!current) return undefined\n    }\n    return current\n  }\n\n  set(keys: K[], value: V): void {\n    let current: Map<K, any> = this.root\n    let i\n    for (i = 0; i < keys.length - 1; i++) {\n      let nextCurrent = current.get(keys[i])\n      if (!nextCurrent) {\n        nextCurrent = new Map<K, any>()\n        current.set(keys[i], nextCurrent)\n      }\n      current = nextCurrent\n    }\n    current.set(keys[i], value)\n  }\n\n  delete(keys: K[]): void {\n    const maps: Map<K, any>[] = [this.root]\n    let current: Map<K, any> = this.root\n\n    for (let i = 0; i < keys.length - 1; i++) {\n      maps.push((current = current.get(keys[i])))\n    }\n\n    let mapIdx = maps.length - 1\n    maps[mapIdx].delete(keys[mapIdx])\n\n    while (--mapIdx > -1 && maps[mapIdx].get(keys[mapIdx]).size === 0) {\n      maps[mapIdx].delete(keys[mapIdx])\n    }\n  }\n}\n", "import { Observable, Subscription, Subject, noop, Subscriber } from \"rxjs\"\nimport { StateObservable } from \"../StateObservable\"\nimport { EMPTY_VALUE } from \"./empty-value\"\n\nconst shareLatest = <T>(\n  source$: Observable<T>,\n  defaultValue: T,\n  teardown = noop,\n) => {\n  let subject: Subject<T> | null\n  let subscription: Subscriber<T> | null\n  let refCount = 0\n  let currentValue: T = EMPTY_VALUE\n  let promise: Promise<T> | null\n\n  const emitIfEmpty =\n    defaultValue === EMPTY_VALUE\n      ? noop\n      : () => {\n          currentValue === EMPTY_VALUE &&\n            subject &&\n            subject!.next((currentValue = defaultValue))\n        }\n\n  const result = new Observable<T>((subscriber) => {\n    subscriber.complete = noop\n\n    refCount++\n    let innerSub: Subscription\n\n    subscriber.add(() => {\n      refCount--\n      innerSub.unsubscribe()\n      if (refCount === 0) {\n        currentValue = EMPTY_VALUE\n        if (subscription) {\n          subscription.unsubscribe()\n        }\n        teardown()\n        subject = null\n        subscription = null\n        promise = null\n      }\n    })\n\n    if (!subject) {\n      subject = new Subject<T>()\n      innerSub = subject.subscribe(subscriber)\n      subscription = null\n      subscription = new Subscriber<T>({\n        next(value: T) {\n          subject!.next((currentValue = value))\n        },\n        error(err: any) {\n          const _subject = subject\n          subscription = null\n          subject = null\n          _subject!.error(err)\n        },\n        complete() {\n          subscription = null\n          emitIfEmpty()\n          subject!.complete()\n        },\n      })\n      source$.subscribe(subscription)\n      emitIfEmpty()\n    } else {\n      innerSub = subject.subscribe(subscriber)\n      if (currentValue !== EMPTY_VALUE) {\n        subscriber.next(currentValue)\n      }\n    }\n  }) as StateObservable<T>\n\n  result.getRefCount = () => refCount\n\n  const noSubscribersErr = new Error(\"No subscribers\")\n  result.getComplete$ = () =>\n    new Observable<boolean>((observer) => {\n      if (refCount === 0) {\n        observer.error(noSubscribersErr)\n        return\n      }\n\n      if (!subscription) {\n        observer.next(true)\n        observer.complete()\n        return\n      }\n\n      observer.next(false)\n      return subject!.subscribe({\n        complete() {\n          observer.next(true)\n          observer.complete()\n        },\n      })\n    })\n\n  result.getValue = () => {\n    if (refCount === 0) {\n      throw noSubscribersErr\n    }\n\n    if (currentValue !== EMPTY_VALUE) return currentValue\n    if (promise) return promise\n\n    return (promise = new Promise<T>((res, rej) => {\n      const error = (e: any) => {\n        rej(e)\n        promise = null\n      }\n      const pSubs = subject!.subscribe({\n        next(v) {\n          pSubs.unsubscribe()\n          res(v)\n          promise = null\n        },\n        error,\n        complete() {\n          error(new Error(\"Empty observable\"))\n        },\n      })\n      subscription!.add(pSubs)\n      subscription!.add(() => {\n        // When the subscription tears down (i.e. refCount = 0) and no value was emitted we must reject the promise.\n        // we can directly emit error without any check, as if it had a value the promise already resolved.\n        error(noSubscribersErr)\n      })\n    }))\n  }\n\n  if (defaultValue !== EMPTY_VALUE) {\n    ;(result as any).getDefaultValue = () => defaultValue\n  }\n\n  return result\n}\nexport default shareLatest\n", "export const EMPTY_VALUE: any = {}\n", "import { Observable } from \"rxjs\"\nimport shareLatest from \"@/internal/share-latest\"\n\nexport default function state<T>(observable: Observable<T>, defaultValue: T) {\n  return shareLatest<T>(observable, defaultValue)\n}\n", "import { Observable } from \"rxjs\"\nimport stateFactory from \"./stateFactory\"\nimport stateSingle from \"./stateSingle\"\nimport { EMPTY_VALUE } from \"../internal/empty-value\"\nimport { DefaultedStateObservable, StateObservable } from \"../StateObservable\"\n\n/**\n * Binds an observable to React\n *\n * @param {Observable<T>} observable - Source observable to be used by the hook.\n * @param {T} [defaultValue] - Default value that will be used if the observable\n * has not emitted any values.\n * @returns [1, 2]\n * 1. A React Hook that yields the latest emitted value of the observable\n * 2. A `sharedLatest` version of the observable. It can be used for composing\n * other streams that depend on it. The shared subscription is closed as soon as\n * there are no subscribers to that observable.\n *\n * @remarks If the Observable doesn't synchronously emit a value upon the first\n * subscription, then the hook will leverage React Suspense while it's waiting\n * for the first value.\n */\nexport function state<T>(observable: Observable<T>): StateObservable<T>\n\nexport function state<T>(\n  observable: Observable<T>,\n  defaultValue: T,\n): DefaultedStateObservable<T>\n\n/**\n * Binds a factory observable to React\n *\n * @param getObservable - Factory of observables. The arguments of this function\n *  will be the ones used in the hook.\n * @param [defaultValue] - Function or value that will be used of the observable\n * has not emitted.\n * @returns [1, 2]\n * 1. A React Hook function with the same parameters as the factory function.\n *  This hook will yield the latest update from the observable returned from\n *  the factory function.\n * 2. A `sharedLatest` version of the observable generated by the factory\n *  function that can be used for composing other streams that depend on it.\n *  The shared subscription is closed as soon as there are no subscribers to\n *  that observable.\n *\n * @remarks If the Observable doesn't synchronously emit a value upon the first\n * subscription, then the hook will leverage React Suspense while it's waiting\n * for the first value.\n */\nexport function state<A extends unknown[], O>(\n  getObservable: (...args: A) => Observable<O>,\n): (...args: A) => StateObservable<O>\n\nexport function state<A extends unknown[], O>(\n  getObservable: (...args: A) => Observable<O>,\n  defaultValue: O | ((...args: A) => O),\n): (...args: A) => DefaultedStateObservable<O>\n\nexport function state(observable: any, defaultValue?: any) {\n  return (\n    typeof observable === \"function\" ? (stateFactory as any) : stateSingle\n  )(observable, arguments.length > 1 ? defaultValue : EMPTY_VALUE)\n}\n"],
  "mappings": "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",
  "names": []
}
