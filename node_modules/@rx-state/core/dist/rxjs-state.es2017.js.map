{
  "version": 3,
  "sources": ["../src/state/stateFactory.ts", "../src/internal/share-latest.ts", "../src/internal/empty-value.ts", "../src/state/stateSingle.ts", "../src/state/index.ts"],
  "sourcesContent": ["import { Observable } from \"rxjs\"\nimport shareLatest from \"@/internal/share-latest\"\nimport { StateObservable } from \"@/StateObservable\"\n\nfunction cloneProps<T>(\n  internal: StateObservable<T>,\n  external: StateObservable<T>,\n) {\n  external.getValue = internal.getValue\n  external.getRefCount = internal.getRefCount\n  external.getComplete$ = internal.getComplete$\n  if ((internal as any).getDefaultValue) {\n    ;(external as any).getDefaultValue = (internal as any).getDefaultValue\n  }\n}\n\n/**\n * Accepts: A factory function that returns an Observable.\n *\n * Returns [1, 2]\n * 1. A React Hook function with the same parameters as the factory function.\n *  This hook will yield the latest update from the observable returned from\n *  the factory function.\n * 2. A `sharedLatest` version of the observable generated by the factory\n *  function that can be used for composing other streams that depend on it.\n *  The shared subscription is closed as soon as there are no subscribers to\n *  that observable.\n *\n * @param getObservable Factory of observables. The arguments of this function\n *  will be the ones used in the hook.\n *\n * @remarks If the Observable doesn't synchronously emit a value upon the first\n * subscription, then the hook will leverage React Suspense while it's waiting\n * for the first value.\n */\nexport default function connectFactoryObservable<A extends [], O>(\n  getObservable: (...args: A) => Observable<O>,\n  defaultValue: O | ((...args: A) => O),\n) {\n  const cache = new NestedMap<A, StateObservable<O>>()\n  const getDefaultValue = (\n    typeof defaultValue === \"function\" ? defaultValue : () => defaultValue\n  ) as (...args: A) => O\n\n  const getSharedObservables$ = (input: A): StateObservable<O> => {\n    for (let i = input.length - 1; input[i] === undefined && i > -1; i--) {\n      input.splice(-1)\n    }\n    const keys = [input.length, ...input] as any as A\n    const cachedVal = cache.get(keys)\n\n    if (cachedVal !== undefined) {\n      return cachedVal\n    }\n\n    const sharedObservable$ = shareLatest(\n      new Observable<O>((observer) =>\n        getObservable(...input).subscribe(observer),\n      ),\n      getDefaultValue(...input),\n      () => {\n        cache.delete(keys)\n      },\n    )\n\n    const publicShared$ = new Observable<O>((subscriber) => {\n      const inCache = cache.get(keys)\n      let source$: StateObservable<O> = sharedObservable$\n\n      if (!inCache) {\n        cache.set(keys, result)\n      } else if (inCache !== publicShared$) {\n        source$ = inCache\n        cloneProps(source$, publicShared$)\n      }\n\n      return source$.subscribe(subscriber)\n    }) as StateObservable<O>\n    cloneProps(sharedObservable$, publicShared$)\n\n    const result: StateObservable<O> = publicShared$\n\n    cache.set(keys, result)\n    return result\n  }\n\n  return (...input: A) => getSharedObservables$(input)\n}\n\nclass NestedMap<K extends [], V extends Object> {\n  private root: Map<K, any>\n  constructor() {\n    this.root = new Map()\n  }\n\n  get(keys: K[]): V | undefined {\n    let current: any = this.root\n    for (let i = 0; i < keys.length; i++) {\n      current = current.get(keys[i])\n      if (!current) return undefined\n    }\n    return current\n  }\n\n  set(keys: K[], value: V): void {\n    let current: Map<K, any> = this.root\n    let i\n    for (i = 0; i < keys.length - 1; i++) {\n      let nextCurrent = current.get(keys[i])\n      if (!nextCurrent) {\n        nextCurrent = new Map<K, any>()\n        current.set(keys[i], nextCurrent)\n      }\n      current = nextCurrent\n    }\n    current.set(keys[i], value)\n  }\n\n  delete(keys: K[]): void {\n    const maps: Map<K, any>[] = [this.root]\n    let current: Map<K, any> = this.root\n\n    for (let i = 0; i < keys.length - 1; i++) {\n      maps.push((current = current.get(keys[i])))\n    }\n\n    let mapIdx = maps.length - 1\n    maps[mapIdx].delete(keys[mapIdx])\n\n    while (--mapIdx > -1 && maps[mapIdx].get(keys[mapIdx]).size === 0) {\n      maps[mapIdx].delete(keys[mapIdx])\n    }\n  }\n}\n", "import { Observable, Subscription, Subject, noop, Subscriber } from \"rxjs\"\nimport { StateObservable } from \"../StateObservable\"\nimport { EMPTY_VALUE } from \"./empty-value\"\n\nconst shareLatest = <T>(\n  source$: Observable<T>,\n  defaultValue: T,\n  teardown = noop,\n) => {\n  let subject: Subject<T> | null\n  let subscription: Subscriber<T> | null\n  let refCount = 0\n  let currentValue: T = EMPTY_VALUE\n  let promise: Promise<T> | null\n\n  const emitIfEmpty =\n    defaultValue === EMPTY_VALUE\n      ? noop\n      : () => {\n          currentValue === EMPTY_VALUE &&\n            subject &&\n            subject!.next((currentValue = defaultValue))\n        }\n\n  const result = new Observable<T>((subscriber) => {\n    subscriber.complete = noop\n\n    refCount++\n    let innerSub: Subscription\n\n    subscriber.add(() => {\n      refCount--\n      innerSub.unsubscribe()\n      if (refCount === 0) {\n        currentValue = EMPTY_VALUE\n        if (subscription) {\n          subscription.unsubscribe()\n        }\n        teardown()\n        subject = null\n        subscription = null\n        promise = null\n      }\n    })\n\n    if (!subject) {\n      subject = new Subject<T>()\n      innerSub = subject.subscribe(subscriber)\n      subscription = null\n      subscription = new Subscriber<T>({\n        next(value: T) {\n          subject!.next((currentValue = value))\n        },\n        error(err: any) {\n          const _subject = subject\n          subscription = null\n          subject = null\n          _subject!.error(err)\n        },\n        complete() {\n          subscription = null\n          emitIfEmpty()\n          subject!.complete()\n        },\n      })\n      source$.subscribe(subscription)\n      emitIfEmpty()\n    } else {\n      innerSub = subject.subscribe(subscriber)\n      if (currentValue !== EMPTY_VALUE) {\n        subscriber.next(currentValue)\n      }\n    }\n  }) as StateObservable<T>\n\n  result.getRefCount = () => refCount\n\n  const noSubscribersErr = new Error(\"No subscribers\")\n  result.getComplete$ = () =>\n    new Observable<boolean>((observer) => {\n      if (refCount === 0) {\n        observer.error(noSubscribersErr)\n        return\n      }\n\n      if (!subscription) {\n        observer.next(true)\n        observer.complete()\n        return\n      }\n\n      observer.next(false)\n      return subject!.subscribe({\n        complete() {\n          observer.next(true)\n          observer.complete()\n        },\n      })\n    })\n\n  result.getValue = () => {\n    if (refCount === 0) {\n      throw noSubscribersErr\n    }\n\n    if (currentValue !== EMPTY_VALUE) return currentValue\n    if (promise) return promise\n\n    return (promise = new Promise<T>((res, rej) => {\n      const error = (e: any) => {\n        rej(e)\n        promise = null\n      }\n      const pSubs = subject!.subscribe({\n        next(v) {\n          pSubs.unsubscribe()\n          res(v)\n          promise = null\n        },\n        error,\n        complete() {\n          error(new Error(\"Empty observable\"))\n        },\n      })\n      subscription!.add(pSubs)\n      subscription!.add(() => {\n        // When the subscription tears down (i.e. refCount = 0) and no value was emitted we must reject the promise.\n        // we can directly emit error without any check, as if it had a value the promise already resolved.\n        error(noSubscribersErr)\n      })\n    }))\n  }\n\n  if (defaultValue !== EMPTY_VALUE) {\n    ;(result as any).getDefaultValue = () => defaultValue\n  }\n\n  return result\n}\nexport default shareLatest\n", "export const EMPTY_VALUE: any = {}\n", "import { Observable } from \"rxjs\"\nimport shareLatest from \"@/internal/share-latest\"\n\nexport default function state<T>(observable: Observable<T>, defaultValue: T) {\n  return shareLatest<T>(observable, defaultValue)\n}\n", "import { Observable } from \"rxjs\"\nimport stateFactory from \"./stateFactory\"\nimport stateSingle from \"./stateSingle\"\nimport { EMPTY_VALUE } from \"../internal/empty-value\"\nimport { DefaultedStateObservable, StateObservable } from \"../StateObservable\"\n\n/**\n * Binds an observable to React\n *\n * @param {Observable<T>} observable - Source observable to be used by the hook.\n * @param {T} [defaultValue] - Default value that will be used if the observable\n * has not emitted any values.\n * @returns [1, 2]\n * 1. A React Hook that yields the latest emitted value of the observable\n * 2. A `sharedLatest` version of the observable. It can be used for composing\n * other streams that depend on it. The shared subscription is closed as soon as\n * there are no subscribers to that observable.\n *\n * @remarks If the Observable doesn't synchronously emit a value upon the first\n * subscription, then the hook will leverage React Suspense while it's waiting\n * for the first value.\n */\nexport function state<T>(observable: Observable<T>): StateObservable<T>\n\nexport function state<T>(\n  observable: Observable<T>,\n  defaultValue: T,\n): DefaultedStateObservable<T>\n\n/**\n * Binds a factory observable to React\n *\n * @param getObservable - Factory of observables. The arguments of this function\n *  will be the ones used in the hook.\n * @param [defaultValue] - Function or value that will be used of the observable\n * has not emitted.\n * @returns [1, 2]\n * 1. A React Hook function with the same parameters as the factory function.\n *  This hook will yield the latest update from the observable returned from\n *  the factory function.\n * 2. A `sharedLatest` version of the observable generated by the factory\n *  function that can be used for composing other streams that depend on it.\n *  The shared subscription is closed as soon as there are no subscribers to\n *  that observable.\n *\n * @remarks If the Observable doesn't synchronously emit a value upon the first\n * subscription, then the hook will leverage React Suspense while it's waiting\n * for the first value.\n */\nexport function state<A extends unknown[], O>(\n  getObservable: (...args: A) => Observable<O>,\n): (...args: A) => StateObservable<O>\n\nexport function state<A extends unknown[], O>(\n  getObservable: (...args: A) => Observable<O>,\n  defaultValue: O | ((...args: A) => O),\n): (...args: A) => DefaultedStateObservable<O>\n\nexport function state(observable: any, defaultValue?: any) {\n  return (\n    typeof observable === \"function\" ? (stateFactory as any) : stateSingle\n  )(observable, arguments.length > 1 ? defaultValue : EMPTY_VALUE)\n}\n"],
  "mappings": "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",
  "names": []
}
