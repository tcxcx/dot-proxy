import { Struct, Option, compact, Bytes, u32, compactBn } from '@polkadot-api/substrate-bindings';
import { toHex } from '@polkadot-api/utils';

const toPjsHex = (value, minByteLen) => {
  let inner = value.toString(16);
  inner = (inner.length % 2 ? "0" : "") + inner;
  const nPaddedBytes = Math.max(0, (minByteLen || 0) - inner.length / 2);
  return "0x" + "00".repeat(nPaddedBytes) + inner;
};
const CheckGenesis = ({
  additionalSigned
}) => ({
  genesisHash: toHex(additionalSigned)
});
const CheckNonce = ({
  value
}) => {
  return { nonce: toPjsHex(compact.dec(value), 4) };
};
const CheckTxVersion = ({
  additionalSigned
}) => {
  return { transactionVersion: toPjsHex(u32.dec(additionalSigned), 4) };
};
const assetTxPaymentDec = Struct({
  tip: compact,
  asset: Option(Bytes(Infinity))
}).dec;
const ChargeAssetTxPayment = ({
  value
}) => {
  const { tip, asset } = assetTxPaymentDec(value);
  return {
    ...asset ? { assetId: toHex(asset) } : {},
    tip: toPjsHex(tip, 16)
  };
};
const ChargeTransactionPayment = ({
  value
}) => ({
  tip: toPjsHex(compactBn.dec(value), 16)
  // u128 => 16 bytes
});
const CheckMortality = ({ value, additionalSigned }, blockNumber) => ({
  era: toHex(value),
  blockHash: toHex(additionalSigned),
  blockNumber: toPjsHex(blockNumber, 4)
});
const CheckSpecVersion = ({
  additionalSigned
}) => ({
  specVersion: toPjsHex(u32.dec(additionalSigned), 4)
});
const CheckMetadataHash = ({
  value,
  additionalSigned
}) => value.length && value[0] ? {
  mode: 1,
  metadataHash: toHex(
    additionalSigned.length ? additionalSigned.slice(1) : additionalSigned
  )
} : {};

export { ChargeAssetTxPayment, ChargeTransactionPayment, CheckGenesis, CheckMetadataHash, CheckMortality, CheckNonce, CheckSpecVersion, CheckTxVersion };
//# sourceMappingURL=pjs-signed-extensions-mappers.mjs.map
