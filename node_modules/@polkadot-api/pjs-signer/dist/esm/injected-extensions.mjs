import { getPolkadotSignerFromPjs } from './from-pjs-account.mjs';

const supportedAccountTypes = /* @__PURE__ */ new Set([
  "ed25519",
  "sr25519",
  "ecdsa",
  "ethereum"
]);
const connectInjectedExtension = async (name, dappName) => {
  let entry = window.injectedWeb3?.[name];
  if (!entry) throw new Error(`Unavailable extension: "${name}"`);
  const enabledExtension = await entry.enable(dappName);
  const signPayload = enabledExtension.signer.signPayload.bind(
    enabledExtension.signer
  );
  const signRaw = enabledExtension.signer.signRaw.bind(enabledExtension.signer);
  const toPolkadotInjected = (accounts) => accounts.filter(({ type }) => supportedAccountTypes.has(type)).map((x) => {
    const polkadotSigner = getPolkadotSignerFromPjs(
      x.address,
      signPayload,
      signRaw
    );
    return {
      ...x,
      polkadotSigner
    };
  });
  let currentAccounts = toPolkadotInjected(
    await enabledExtension.accounts.get()
  );
  const listeners = /* @__PURE__ */ new Set();
  const stop = enabledExtension.accounts.subscribe((x) => {
    currentAccounts = toPolkadotInjected(x);
    listeners.forEach((cb) => {
      cb(currentAccounts);
    });
  });
  return {
    name,
    getAccounts: () => currentAccounts,
    subscribe: (cb) => {
      listeners.add(cb);
      return () => {
        listeners.delete(cb);
      };
    },
    disconnect: () => {
      stop();
    }
  };
};
const getInjectedExtensions = () => {
  const { injectedWeb3 } = window;
  return injectedWeb3 ? Object.keys(injectedWeb3) : [];
};

export { connectInjectedExtension, getInjectedExtensions };
//# sourceMappingURL=injected-extensions.mjs.map
