'use strict';

var substrateClient = require('@polkadot-api/substrate-client');
var rxjs = require('rxjs');
var substrateBindings = require('@polkadot-api/substrate-bindings');
var metadataBuilders = require('@polkadot-api/metadata-builders');
var utils = require('@polkadot-api/utils');

const shareLatest = rxjs.share({
  connector: () => new rxjs.ReplaySubject(1),
  resetOnError: true,
  resetOnComplete: true,
  resetOnRefCountZero: true
});

const concatMapEager = (mapper, concurrent = Infinity) => (source$) => new rxjs.Observable((observer) => {
  let topSubscription;
  const queues = /* @__PURE__ */ new Map();
  const innerSubscriptions = /* @__PURE__ */ new Map();
  const results = /* @__PURE__ */ new Map();
  let mapperIdx = 0;
  let subscriptionIdx = 0;
  let observerIdx = 0;
  const nextSubscription = () => {
    const inner$ = queues.get(subscriptionIdx);
    if (!inner$) {
      if (innerSubscriptions.size === 0 && (typeof topSubscription === "undefined" || topSubscription.closed)) {
        observer.complete();
      }
      return;
    }
    const idx = subscriptionIdx++;
    queues.delete(idx);
    if (observerIdx !== idx) {
      results.set(idx, []);
    }
    let isCompleted = false;
    let subscription = inner$.subscribe({
      next(x) {
        if (observerIdx === idx) {
          observer.next(x);
        } else {
          results.get(idx).push(x);
        }
      },
      complete() {
        isCompleted = true;
        innerSubscriptions.delete(idx);
        if (idx === observerIdx) {
          observerIdx++;
          while (results.has(observerIdx)) {
            results.get(observerIdx).forEach((x) => observer.next(x));
            results.delete(observerIdx);
            if (innerSubscriptions.has(observerIdx)) {
              break;
            }
            observerIdx++;
          }
        }
        nextSubscription();
      },
      error(e) {
        observer.error(e);
      }
    });
    if (!isCompleted) innerSubscriptions.set(idx, subscription);
  };
  topSubscription = source$.subscribe({
    next(outterValue) {
      const idx = mapperIdx++;
      queues.set(
        idx,
        rxjs.defer(() => mapper(outterValue, idx))
      );
      if (innerSubscriptions.size < concurrent) {
        nextSubscription();
      }
    },
    error(e) {
      observer.error(e);
    },
    complete() {
      if (innerSubscriptions.size === 0) {
        observer.complete();
      }
    }
  });
  return () => {
    innerSubscriptions.forEach((subscription) => subscription.unsubscribe());
    topSubscription.unsubscribe();
    queues.clear();
    results.clear();
  };
});

const withDefaultValue = (defaultValue) => (source$) => new rxjs.Observable((observer) => {
  let hasEmited = false;
  const subscription = source$.subscribe({
    next(v) {
      hasEmited = true;
      observer.next(v);
    },
    error(e) {
      observer.error(e);
    },
    complete() {
      observer.complete();
    }
  });
  if (!hasEmited) observer.next(defaultValue);
  return subscription;
});

const delayUnsubscription = (ms) => (source) => new rxjs.Observable((observer) => {
  const subscription = source.subscribe({
    next(v) {
      observer.next(v);
    },
    error(e) {
      observer.error(e);
    },
    complete() {
      observer.complete();
    }
  });
  const unsubscribe = () => subscription.unsubscribe();
  return () => {
    Promise.resolve().then(unsubscribe);
  };
});

var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
class PendingTaskQueue {
  constructor() {
    __publicField(this, "first");
    __publicField(this, "last");
  }
  getRemoveFn(node) {
    return () => {
      if (node.prev) {
        node.prev.next = node.next;
      } else {
        this.first = node.next;
      }
      if (node.next) {
        node.next.prev = node.prev;
      } else {
        this.last = node.prev;
      }
      delete node.prev;
      delete node.next;
    };
  }
  push(value) {
    const newNode = { value };
    if (this.last === void 0) {
      this.last = this.first = newNode;
    } else {
      this.last.next = newNode;
      newNode.prev = this.last;
      this.last = newNode;
    }
    return this.getRemoveFn(newNode);
  }
  unshift(value) {
    this.first = { value, next: this.first };
    this.first.next && (this.first.next.prev = this.first);
    this.last || (this.last = this.first);
    return this.getRemoveFn(this.first);
  }
  pop() {
    const result = this.first?.value;
    if (this.first) {
      this.first = this.first.next;
      if (!this.first) {
        this.last = void 0;
      } else {
        delete this.first.prev?.next;
        delete this.first.prev;
      }
    }
    return result;
  }
  isEmpty() {
    return !this.first;
  }
}
const getWithRecovery = () => {
  const tearDownOperations = /* @__PURE__ */ new Map();
  const setTeardown = (observable, cb) => {
    tearDownOperations.set(observable, () => {
      tearDownOperations.delete(observable);
      cb();
    });
  };
  const teardown = (observable) => {
    tearDownOperations.get(observable)?.();
  };
  const pendingTasks = new PendingTaskQueue();
  const unshift = pendingTasks.unshift.bind(pendingTasks);
  const push = pendingTasks.push.bind(pendingTasks);
  const addTask = (task, topPriority) => {
    const fn = topPriority ? unshift : push;
    setTeardown(task.source$, fn(task));
  };
  const onEmptySlot = () => {
    const data = pendingTasks.pop();
    if (!data) return;
    tearDownOperations.delete(data.source$);
    process(data);
  };
  const process = (data) => {
    const { source$, observer } = data;
    let isOperationLimit = false;
    const subscription = source$.subscribe({
      next(x) {
        observer.next(x);
      },
      error(e) {
        (isOperationLimit = e instanceof substrateClient.OperationLimitError) ? addTask(data, true) : observer.error(e);
      },
      complete() {
        observer.complete();
      }
    });
    if (!subscription.closed) {
      setTeardown(source$, () => {
        subscription.unsubscribe();
        onEmptySlot();
      });
    } else if (!isOperationLimit) onEmptySlot();
  };
  const withRecovery = (topPriority = false) => (source$) => new rxjs.Observable((observer) => {
    const pendingTask = { observer, source$ };
    if (pendingTasks.isEmpty()) {
      process(pendingTask);
    } else {
      addTask(pendingTask, topPriority);
    }
    return () => {
      teardown(source$);
    };
  });
  const withNormalRecovery = withRecovery();
  const withRecoveryFn = (fn) => (...args) => withNormalRecovery(fn(...args));
  return { withRecovery, withRecoveryFn };
};

class BlockNotPinnedError extends Error {
  constructor(hash, label) {
    super(`Block ${hash} is not pinned (${label})`);
    this.name = "BlockNotPinnedError";
  }
}
class BlockPrunedError extends Error {
  constructor() {
    super("Block pruned");
    this.name = "BlockPrunedError";
  }
}
class NotBestBlockError extends Error {
  constructor() {
    super("Block is not best block or finalized");
    this.name = "NotBestBlockError";
  }
}

const dynamicBlocks = /* @__PURE__ */ new Set(["best", "finalized", null]);
const operable = (source$) => {
  const result = source$.pipe(
    rxjs.catchError(
      (e) => e instanceof substrateClient.OperationInaccessibleError ? rxjs.timer(750).pipe(rxjs.concatMap(() => result)) : rxjs.throwError(() => e)
    )
  );
  return result;
};
const getWithOptionalhash$ = (finalized$, best$, usingBlock) => {
  return (fn) => (hash, ...args) => {
    if (!dynamicBlocks.has(hash))
      return operable(fn(hash, ...args)).pipe(
        usingBlock(hash)
      );
    const hash$ = hash === "best" ? best$ : finalized$;
    const result$ = hash$.pipe(
      rxjs.take(1),
      rxjs.mergeMap((h) => fn(h, ...args).pipe(usingBlock(h))),
      rxjs.catchError((e) => {
        return e instanceof BlockNotPinnedError ? result$ : rxjs.throwError(() => e);
      })
    );
    return operable(result$);
  };
};

const fromAbortControllerFn = (fn) => (...args) => new rxjs.Observable((observer) => {
  let aborter = new AbortController();
  fn(...[...args, aborter.signal]).then(
    (value) => {
      observer.next(value);
      observer.complete();
    },
    (error) => {
      observer.error(error);
    }
  );
  return () => {
    observer.unsubscribe();
    aborter.abort();
    aborter = void 0;
  };
});

const withLazyFollower = (getFollower) => (key) => (...args) => getFollower()[key](...args);

const isBestOrFinalizedBlock = (blocks$, blockHash) => blocks$.pipe(
  rxjs.takeWhile((b) => b.blocks.has(blockHash)),
  rxjs.distinctUntilChanged(
    (a, b) => a.finalized === b.finalized && a.best === b.best
  ),
  rxjs.map((pinned) => {
    if (pinned.blocks.get(blockHash).number > pinned.blocks.get(pinned.best).number)
      return null;
    const { number } = pinned.blocks.get(blockHash);
    let current = pinned.blocks.get(pinned.best);
    let isFinalized = pinned.finalized === current.hash;
    while (current.number > number) {
      current = pinned.blocks.get(current.parent);
      isFinalized = isFinalized || pinned.finalized === current.hash;
    }
    if (isFinalized) return "finalized";
    return current.hash === blockHash ? "best" : null;
  }),
  rxjs.distinctUntilChanged(),
  rxjs.takeWhile((x) => x !== "finalized", true)
);

function withEnsureCanonicalChain(blocks$, follow$, fn) {
  return (hash, ensureCanonical, ...args) => {
    const enhancer = ensureCanonical ? rxjs.pipe(
      throwWhenPrune(
        hash,
        follow$.pipe(
          rxjs.filter((evt) => evt.type === "finalized"),
          rxjs.mergeMap((evt) => evt.prunedBlockHashes)
        )
      ),
      onlyIfIsBestOrFinalized(hash, blocks$)
    ) : (x) => x;
    return enhancer(fn(hash, ...args));
  };
}
const onlyIfIsBestOrFinalized = (hash, blocks$) => (source$) => isBestOrFinalizedBlock(blocks$, hash).pipe(
  rxjs.take(1),
  rxjs.switchMap(
    (isBest) => isBest ? source$ : rxjs.throwError(() => new NotBestBlockError())
  )
);
const throwWhenPrune = (hash, pruned$) => (source$) => new rxjs.Observable((subscriber) => {
  const prunedSubscription = pruned$.pipe(rxjs.filter((h) => h === hash)).subscribe(() => {
    subscriber.error(new BlockPrunedError());
  });
  const sourceSubscription = source$.subscribe(subscriber);
  return () => {
    prunedSubscription.unsubscribe();
    sourceSubscription.unsubscribe();
  };
});

function withStopRecovery(blocks$, fn, label) {
  return (hash, ...args) => {
    const source$ = fn(hash, ...args);
    return new rxjs.Observable((observer) => {
      let sourceSub = null;
      let isSubscribed = false;
      const performSourceSub = () => {
        if (isSubscribed) return;
        isSubscribed = true;
        sourceSub = source$.subscribe({
          next: (v) => observer.next(v),
          error: (e) => observer.error(e),
          complete: () => observer.complete()
        });
        sourceSub.add(() => {
          isSubscribed = false;
          sourceSub = null;
        });
      };
      let isRecovering = false;
      const blockSub = blocks$.subscribe({
        next: (v) => {
          const block = v.blocks.get(hash);
          if (!block) {
            if (isRecovering) {
              observer.error(new BlockNotPinnedError(hash, label));
            }
          } else if (block.recovering) {
            sourceSub?.unsubscribe();
          } else {
            performSourceSub();
          }
          isRecovering = v.recovering;
        },
        error: (e) => observer.error(e)
      });
      return () => {
        blockSub.unsubscribe();
        sourceSub?.unsubscribe();
      };
    });
  };
}

const getRecoveralStorage$ = (getFollower, withRecovery) => {
  const recoveralStorage$ = (hash, queries, childTrie, isHighPriority) => new rxjs.Observable(
    (observer) => getFollower().storageSubscription(
      hash,
      queries,
      childTrie ?? null,
      (items) => {
        observer.next(items);
      },
      (error) => {
        observer.error(error);
      },
      () => {
        observer.complete();
      },
      (nDiscarded) => {
        if (nDiscarded > 0)
          observer.next(
            recoveralStorage$(
              hash,
              queries.slice(-nDiscarded),
              childTrie,
              true
            )
          );
      }
    )
  ).pipe(rxjs.mergeAll(), withRecovery(isHighPriority));
  return recoveralStorage$;
};

const withInitializedNumber = (getHeader) => (source$) => source$.pipe(
  rxjs.concatMap((event) => {
    return event.type !== "initialized" ? rxjs.of(event) : getHeader(event.finalizedBlockHashes[0]).then((header) => ({
      ...event,
      number: header.number,
      parentHash: header.parentHash
    }));
  })
);
const getFollow$ = (chainHead) => {
  let follower = null;
  let unfollow = rxjs.noop;
  const getFollower = () => {
    if (!follower) throw new Error("Missing chainHead subscription");
    return follower;
  };
  const getHeader = (hash) => getFollower().header(hash).then(substrateBindings.blockHeader.dec);
  const follow$ = rxjs.connectable(
    new rxjs.Observable((observer) => {
      follower = chainHead(
        true,
        (e) => {
          observer.next(e);
        },
        (e) => {
          follower = null;
          observer.error(e);
        }
      );
      unfollow = () => {
        observer.complete();
        follower?.unfollow();
      };
    }).pipe(withInitializedNumber(getHeader), retryChainHeadError())
  );
  const startFollow = () => {
    follow$.connect();
    return () => {
      unfollow();
    };
  };
  return {
    getHeader,
    getFollower,
    startFollow,
    follow$
  };
};
const retryChainHeadError = () => (source$) => new rxjs.Observable((observer) => {
  const subscription = new rxjs.Subscription();
  const subscribe = () => source$.subscribe({
    next: (v) => observer.next(v),
    error: (e) => {
      if (e instanceof substrateClient.StopError) {
        observer.next({ type: "stop-error" });
      } else {
        console.warn("ChainHead follow request failed, retrying\u2026", e);
      }
      subscription.add(subscribe());
    },
    complete: () => observer.complete()
  });
  subscription.add(subscribe());
  return subscription;
});

const v15Args = utils.toHex(substrateBindings.u32.enc(15));
const opaqueBytes = substrateBindings.Bytes();
const optionalOpaqueBytes = substrateBindings.Option(opaqueBytes);
const u32ListDecoder = substrateBindings.Vector(substrateBindings.u32).dec;
const getRuntimeCreator = (call$) => {
  const getMetadata$ = (getHash) => {
    const recoverCall$ = (method, args) => {
      const hash = getHash();
      return hash ? call$(hash, method, args).pipe(
        rxjs.catchError((e) => {
          if (e instanceof BlockNotPinnedError)
            return recoverCall$(method, args);
          if (e instanceof substrateClient.OperationInaccessibleError)
            return rxjs.timer(750).pipe(
              rxjs.mergeMap(() => recoverCall$(method, args))
            );
          throw e;
        })
      ) : rxjs.EMPTY;
    };
    const versions = recoverCall$("Metadata_metadata_versions", "").pipe(
      rxjs.map(u32ListDecoder)
    );
    const v14 = recoverCall$("Metadata_metadata", "").pipe(
      rxjs.map((x) => {
        const metadataRaw = opaqueBytes.dec(x);
        const metadata = substrateBindings.metadata.dec(metadataRaw);
        return { metadata: metadata.metadata.value, metadataRaw };
      })
    );
    const v15 = recoverCall$("Metadata_metadata_at_version", v15Args).pipe(
      rxjs.map((x) => {
        const metadataRaw = optionalOpaqueBytes.dec(x);
        const metadata = substrateBindings.metadata.dec(metadataRaw);
        return { metadata: metadata.metadata.value, metadataRaw };
      })
    );
    return versions.pipe(
      rxjs.catchError(() => rxjs.of([14])),
      rxjs.mergeMap((v) => v.includes(15) ? v15 : v14)
    );
  };
  return (getHash) => {
    const initialHash = getHash();
    const usages = /* @__PURE__ */ new Set([initialHash]);
    const runtimeContext$ = getMetadata$(
      getHash
    ).pipe(
      rxjs.map(({ metadata, metadataRaw }) => {
        const lookup = metadataBuilders.getLookupFn(metadata);
        const dynamicBuilder = metadataBuilders.getDynamicBuilder(lookup);
        const events = dynamicBuilder.buildStorage("System", "Events");
        const assetPayment = metadata.extrinsic.signedExtensions.find(
          (x) => x.identifier === "ChargeAssetTxPayment"
        );
        let assetId = null;
        if (assetPayment) {
          const assetTxPayment = lookup(assetPayment.type);
          if (assetTxPayment.type === "struct") {
            const optionalAssetId = assetTxPayment.value.asset_id;
            if (optionalAssetId.type === "option")
              assetId = optionalAssetId.value.id;
          }
        }
        return {
          assetId,
          metadataRaw,
          lookup,
          dynamicBuilder,
          events: {
            key: events.keys.enc(),
            dec: events.value.dec
          },
          accountId: substrateBindings.AccountId(dynamicBuilder.ss58Prefix)
        };
      }),
      rxjs.shareReplay(1)
    );
    const result = {
      at: initialHash,
      runtime: runtimeContext$,
      addBlock: (block) => {
        usages.add(block);
        return result;
      },
      deleteBlocks: (blocks) => {
        blocks.forEach((block) => {
          usages.delete(block);
        });
        return usages.size;
      },
      usages
    };
    runtimeContext$.subscribe({
      error() {
      }
    });
    return result;
  };
};

const createRuntimeGetter = (pinned, startAt) => {
  return () => {
    const runtime = pinned.runtimes[startAt];
    if (!runtime) return pinned.blocks.has(startAt) ? startAt : null;
    const winner = [...runtime.usages].reverse().find((x) => !pinned.blocks.get(x).unpinned);
    return winner ?? null;
  };
};
const deleteBlock = (blocks, blockHash) => {
  blocks.get(blocks.get(blockHash).parent)?.children.delete(blockHash);
  blocks.delete(blockHash);
};
const deleteBlocks = (blocks, toDelete) => {
  toDelete.forEach((hash) => {
    deleteBlock(blocks.blocks, hash);
  });
  Object.entries(blocks.runtimes).map(([key, value]) => ({
    key,
    usages: value.deleteBlocks(toDelete)
  })).filter((x) => x.usages === 0).map((x) => x.key).forEach((unusedRuntime) => {
    delete blocks.runtimes[unusedRuntime];
  });
};
const getPinnedBlocks$ = (follow$, call$, blockUsage$, onUnpin, deleteFromCache) => {
  const pinnedBlocks$ = rxjs.merge(
    blockUsage$,
    follow$
  ).pipe(
    rxjs.scan((acc, event) => {
      switch (event.type) {
        case "initialized":
          if (acc.recovering) {
            const isConnected = event.finalizedBlockHashes.some(
              (hash) => acc.blocks.has(hash)
            );
            if (!isConnected) {
              acc = getInitialPinnedBlocks();
            }
          }
          const [finalizedHash] = event.finalizedBlockHashes.slice(-1);
          acc.finalized = acc.best = finalizedHash;
          const lastIdx = event.finalizedBlockHashes.length - 1;
          event.finalizedBlockHashes.forEach((hash, i) => {
            if (acc.blocks.has(hash)) {
              acc.blocks.get(hash).recovering = false;
            } else {
              acc.blocks.set(hash, {
                hash,
                parent: i === 0 ? event.parentHash : event.finalizedBlockHashes[i - 1],
                children: new Set(
                  i === lastIdx ? [] : [event.finalizedBlockHashes[i + 1]]
                ),
                runtime: hash,
                refCount: 0,
                number: event.number + i,
                recovering: false
              });
            }
          });
          const finalizedRuntime = Object.values(acc.runtimes).find(
            (runtime) => runtime.usages.has(finalizedHash)
          );
          acc.finalizedRuntime = finalizedRuntime ?? (acc.runtimes[finalizedHash] = getRuntime(
            createRuntimeGetter(acc, finalizedHash)
          ));
          return acc;
        case "stop-error":
          for (const block of acc.blocks.values()) {
            block.recovering = true;
          }
          acc.recovering = true;
          return acc;
        case "newBlock": {
          const { parentBlockHash: parent, blockHash: hash } = event;
          if (acc.blocks.has(hash)) {
            acc.blocks.get(hash).recovering = false;
          } else {
            const parentNode = acc.blocks.get(parent);
            parentNode.children.add(hash);
            if (event.newRuntime) {
              acc.runtimes[hash] = getRuntime(createRuntimeGetter(acc, hash));
            }
            const block = {
              hash,
              number: parentNode.number + 1,
              parent,
              children: /* @__PURE__ */ new Set(),
              runtime: event.newRuntime ? hash : parentNode.runtime,
              refCount: 0,
              recovering: false
            };
            acc.blocks.set(hash, block);
            acc.runtimes[block.runtime].addBlock(hash);
          }
          return acc;
        }
        case "bestBlockChanged": {
          if (acc.recovering) {
            for (const [hash, block] of acc.blocks) {
              if (block.recovering) {
                deleteBlock(acc.blocks, hash);
                deleteFromCache(hash);
              }
            }
            acc.recovering = false;
          }
          acc.best = event.bestBlockHash;
          return acc;
        }
        case "finalized": {
          acc.finalized = event.finalizedBlockHashes.slice(-1)[0];
          const { blocks } = acc;
          if (blocks.get(acc.best).number < blocks.get(acc.finalized).number)
            acc.best = acc.finalized;
          acc.finalizedRuntime = acc.runtimes[blocks.get(acc.finalized).runtime];
          const { prunedBlockHashes: prunned } = event;
          deleteBlocks(acc, prunned);
          onUnpin(prunned);
          setTimeout(() => {
            const trail = [];
            const toUnpin = [];
            let current = blocks.get(blocks.get(acc.finalized).parent);
            while (current) {
              const { hash } = current;
              trail.push(hash);
              if (current.refCount === 0 && !current.unpinned) {
                current.unpinned = true;
                if (current.recovering) deleteFromCache(hash);
                else toUnpin.push(hash);
              }
              current = blocks.get(current.parent);
            }
            const toDelete = [];
            for (let i = trail.length - 1; i >= 0; i--) {
              current = blocks.get(trail[i]);
              if (!current.unpinned) break;
              toDelete.push(current.hash);
            }
            deleteBlocks(acc, toDelete);
            onUnpin(toUnpin);
          }, 0);
          return acc;
        }
        case "blockUsage": {
          if (!acc.blocks.has(event.value.hash)) return acc;
          const block = acc.blocks.get(event.value.hash);
          block.refCount += event.value.type === "hold" ? 1 : -1;
          if (block.refCount === 0 && block.number < acc.blocks.get(acc.finalized).number && !block.recovering) {
            block.unpinned = true;
            onUnpin([block.hash]);
          }
          return acc;
        }
      }
    }, getInitialPinnedBlocks()),
    rxjs.filter((x) => !!x.finalizedRuntime.runtime),
    rxjs.map((x) => ({ ...x })),
    shareLatest
  );
  const getRuntime = getRuntimeCreator(
    withStopRecovery(pinnedBlocks$, call$, "pinned-blocks")
  );
  return pinnedBlocks$;
};
const getInitialPinnedBlocks = () => ({
  best: "",
  finalized: "",
  runtimes: {},
  blocks: /* @__PURE__ */ new Map(),
  finalizedRuntime: {},
  recovering: false
});

const getTrackTx = (blocks$, getBody, getIsValid, getEvents) => {
  const whileBlockPresent = (hash) => rxjs.takeUntil(blocks$.pipe(rxjs.filter(({ blocks }) => !blocks.has(hash))));
  const analyzeBlock = (hash, tx, alreadyPresent) => {
    if (alreadyPresent)
      return rxjs.of({ hash, found: { type: false, validity: null } });
    const whilePresent = whileBlockPresent(hash);
    return getBody(hash).pipe(
      rxjs.mergeMap((txs) => {
        const index = txs.indexOf(tx);
        return index > -1 ? whilePresent(getEvents(hash)).pipe(
          rxjs.map((events) => ({
            hash,
            found: {
              type: true,
              index,
              events
            }
          }))
        ) : getIsValid(hash, tx).pipe(
          rxjs.map((validity) => ({
            hash,
            found: { type: false, validity }
          }))
        );
      }),
      whilePresent
    );
  };
  const findInBranch = (hash, tx, alreadyPresent) => analyzeBlock(hash, tx, alreadyPresent.has(hash)).pipe(
    rxjs.mergeMap((analyzed) => {
      const { found } = analyzed;
      return found.type || found.validity?.success === false ? rxjs.of(analyzed) : blocks$.pipe(
        whileBlockPresent(hash),
        rxjs.mergeMap((x) => x.blocks.get(hash).children),
        rxjs.distinct(),
        rxjs.mergeMap((hash2) => findInBranch(hash2, tx, alreadyPresent))
      );
    })
  );
  return (tx) => blocks$.pipe(
    rxjs.take(1),
    rxjs.mergeMap((x) => findInBranch(x.finalized, tx, new Set(x.blocks.keys())))
  );
};

const external = new Uint8Array([2]);
const getValidateTxArgs = (tx, hash) => utils.toHex(utils.mergeUint8(external, utils.fromHex(tx), utils.fromHex(hash)));
const TaggedTransactionQueue = "TaggedTransactionQueue";
const validateTransaction = "validate_transaction";
const [, defaultInvalidTxDecoder] = substrateBindings.Variant({
  InvalidTransaction: substrateBindings.Variant({
    Call: substrateBindings._void,
    Payment: substrateBindings._void,
    Future: substrateBindings._void,
    Stale: substrateBindings._void,
    BadProof: substrateBindings._void,
    AncientBirthBlock: substrateBindings._void,
    ExhaustsResources: substrateBindings._void,
    Custom: substrateBindings.u8,
    BadMandatory: substrateBindings._void,
    MandatoryValidation: substrateBindings._void,
    BadSigner: substrateBindings._void
  }),
  UnknownTransaction: substrateBindings.Variant({
    CannotLookup: substrateBindings._void,
    NoUnsignedValidator: substrateBindings._void,
    Custom: substrateBindings.u8
  })
});
const defaultValidateTxDecoder = substrateBindings.createDecoder((input) => {
  const firstByte = substrateBindings.u8.dec(input);
  if (firstByte > 1)
    throw new Error("Unable to decode validateTransaction result");
  if (!firstByte) return { success: true, value: void 0 };
  let value;
  try {
    value = defaultInvalidTxDecoder(input);
  } catch (_) {
    value = {
      type: "UnknownInvalidTx"
    };
  }
  return { success: false, value };
});
const getValidateTx = (call$, getRuntimeContext) => (blockHash, tx) => {
  const decoder$ = getRuntimeContext(blockHash).pipe(
    rxjs.map((ctx) => {
      try {
        return ctx.dynamicBuilder.buildRuntimeCall(
          TaggedTransactionQueue,
          validateTransaction
        ).value[1];
      } catch (_) {
        return defaultValidateTxDecoder;
      }
    })
  );
  return call$(
    blockHash,
    `${TaggedTransactionQueue}_${validateTransaction}`,
    getValidateTxArgs(tx, blockHash)
  ).pipe(
    rxjs.withLatestFrom(decoder$),
    rxjs.map(([result, decoder]) => decoder(result))
  );
};

const toBlockInfo = ({ hash, number, parent }) => ({
  hash,
  number,
  parent
});
const getChainHead$ = (chainHead) => {
  const { getFollower, startFollow, follow$, getHeader } = getFollow$(chainHead);
  const lazyFollower = withLazyFollower(getFollower);
  const { withRecovery, withRecoveryFn } = getWithRecovery();
  const blockUsage$ = new rxjs.Subject();
  const holdBlock = (hash) => {
    blockUsage$.next({ type: "blockUsage", value: { type: "hold", hash } });
    return () => {
      setTimeout(() => {
        blockUsage$.next({
          type: "blockUsage",
          value: { type: "release", hash }
        });
      }, 0);
    };
  };
  const usingBlock = (blockHash) => (base) => new rxjs.Observable((observer) => {
    const release = holdBlock(blockHash);
    const subscription = base.subscribe(observer);
    subscription.add(release);
    return subscription;
  });
  const withRefcount = (fn) => (hash, ...args) => fn(hash, ...args).pipe(usingBlock(hash));
  const withInMemory = (fn, label) => (hash, ...args) => new rxjs.Observable((observer) => {
    let isPresent = false;
    pinnedBlocks$.pipe(rxjs.take(1)).subscribe((blocks) => {
      const block = blocks.blocks.get(hash);
      isPresent = !!block && !block.unpinned;
    });
    return isPresent ? fn(hash, ...args).subscribe(observer) : observer.error(new BlockNotPinnedError(hash, label));
  });
  const unpin = (hashes) => getFollower().unpin(hashes).catch((e) => {
    if (e instanceof substrateClient.DisjointError) return;
    throw e;
  });
  const commonEnhancer = (fn, label) => {
    const canonicalChain = (_fn) => withEnsureCanonicalChain(pinnedBlocks$, follow$, _fn);
    return withInMemory(
      withRefcount(
        canonicalChain(
          withStopRecovery(
            pinnedBlocks$,
            withRecoveryFn(fromAbortControllerFn(fn)),
            `stop-${label}`
          )
        )
      ),
      label
    );
  };
  const withCanonicalChain = (fn, withCanonicalChain2 = true) => (hash, ...args) => fn(hash, withCanonicalChain2, ...args);
  const cache = /* @__PURE__ */ new Map();
  const pinnedBlocks$ = getPinnedBlocks$(
    follow$,
    withRefcount(withRecoveryFn(fromAbortControllerFn(lazyFollower("call")))),
    blockUsage$,
    (blocks) => {
      unpin(blocks);
      blocks.forEach((hash) => {
        cache.delete(hash);
      });
    },
    (block) => {
      cache.delete(block);
    }
  );
  const getRuntimeContext$ = withRefcount(
    (hash) => pinnedBlocks$.pipe(
      rxjs.take(1),
      rxjs.mergeMap(
        (pinned) => pinned.runtimes[pinned.blocks.get(hash).runtime].runtime
      )
    )
  );
  const withRuntime = (mapper) => (source$) => source$.pipe(
    concatMapEager(
      (x) => getRuntimeContext$(mapper(x)).pipe(rxjs.map((runtime) => [x, runtime]))
    )
  );
  const upsertCachedStream = (hash, key, stream) => {
    const hashCache = cache.get(hash) ?? /* @__PURE__ */ new Map();
    const cached = hashCache.get(key);
    if (cached) return cached;
    cache.set(hash, hashCache);
    let connector;
    const result = stream.pipe(
      rxjs.share({
        connector: () => connector = new rxjs.ReplaySubject()
      }),
      rxjs.tap({
        complete() {
          hashCache.set(key, connector);
        }
      }),
      delayUnsubscription()
    );
    hashCache.set(key, result);
    return result;
  };
  const finalized$ = pinnedBlocks$.pipe(
    rxjs.filter((x) => !x.recovering),
    rxjs.distinctUntilChanged((a, b) => a.finalized === b.finalized),
    rxjs.scan((acc, value) => {
      let current = value.blocks.get(value.finalized);
      const result = [current];
      const latest = acc.at(-1);
      if (!latest) return result;
      while (current.number > latest.number + 1) {
        current = value.blocks.get(current.parent);
        if (!current) break;
        result.unshift(current);
      }
      return result;
    }, []),
    rxjs.mergeAll(),
    rxjs.map(toBlockInfo),
    shareLatest
  );
  const best$ = pinnedBlocks$.pipe(
    rxjs.distinctUntilChanged((a, b) => a.best === b.best),
    rxjs.map((pinned) => toBlockInfo(pinned.blocks.get(pinned.best))),
    shareLatest
  );
  const bestBlocks$ = pinnedBlocks$.pipe(
    rxjs.filter((x) => !x.recovering),
    rxjs.distinctUntilChanged(
      (prev, current) => prev.finalized === current.finalized && prev.best === current.best
    ),
    rxjs.scan((acc, pinned) => {
      const getBlockInfo = (hash) => acc.get(hash) || toBlockInfo(pinned.blocks.get(hash));
      const best = getBlockInfo(pinned.best);
      const finalized = getBlockInfo(pinned.finalized);
      const len = best.number - finalized.number + 1;
      const result = new Array(len);
      for (let i = 0, hash = best.hash; i < len; i++) {
        result[i] = getBlockInfo(hash);
        hash = result[i].parent;
      }
      return new Map(result.map((b) => [b.hash, b]));
    }, /* @__PURE__ */ new Map()),
    rxjs.map((x) => [...x.values()]),
    shareLatest
  );
  const runtime$ = pinnedBlocks$.pipe(
    rxjs.distinctUntilChanged((a, b) => a.finalizedRuntime === b.finalizedRuntime),
    rxjs.switchMap(
      ({ finalizedRuntime: { runtime } }) => runtime.pipe(withDefaultValue(null))
    ),
    shareLatest
  );
  const metadata$ = runtime$.pipe(rxjs.map((x) => x?.lookup.metadata ?? null));
  const withOptionalHash$ = getWithOptionalhash$(
    finalized$.pipe(rxjs.map((b) => b.hash)),
    best$.pipe(rxjs.map((b) => b.hash)),
    usingBlock
  );
  const _body$ = withOptionalHash$(commonEnhancer(lazyFollower("body"), "body"));
  const body$ = (hash) => upsertCachedStream(hash, "body", _body$(hash, true));
  const _storage$ = commonEnhancer(lazyFollower("storage"), "storage");
  const storage$ = withOptionalHash$(
    (hash, withCanonicalChain2, type, keyMapper, childTrie = null, mapper) => pinnedBlocks$.pipe(
      rxjs.take(1),
      rxjs.mergeMap(
        (pinned) => pinned.runtimes[pinned.blocks.get(hash).runtime].runtime
      ),
      rxjs.mergeMap((ctx) => {
        const key = keyMapper(ctx);
        const unMapped$ = upsertCachedStream(
          hash,
          `storage-${type}-${key}-${childTrie ?? ""}`,
          _storage$(hash, withCanonicalChain2, type, key, childTrie)
        );
        return mapper ? upsertCachedStream(
          hash,
          `storage-${type}-${key}-${childTrie ?? ""}-dec`,
          unMapped$.pipe(
            rxjs.map((raw) => ({ raw, mapped: mapper(raw, ctx) }))
          )
        ) : unMapped$;
      })
    )
  );
  const recoveralStorage$ = getRecoveralStorage$(getFollower, withRecovery);
  const storageQueries$ = withOptionalHash$(
    withStopRecovery(
      pinnedBlocks$,
      (hash, queries, childTrie) => recoveralStorage$(hash, queries, childTrie ?? null, false),
      `storageQueries`
    )
  );
  const header$ = withOptionalHash$(
    withStopRecovery(
      pinnedBlocks$,
      (hash) => rxjs.defer(() => getHeader(hash)),
      "header"
    )
  );
  const eventsAt$ = (hash, canonical = false) => storage$(
    hash,
    canonical,
    "value",
    (ctx) => ctx.events.key,
    null,
    (x, ctx) => ctx.events.dec(x)
  ).pipe(rxjs.map((x) => x.mapped));
  const __call$ = commonEnhancer(lazyFollower("call"), "call");
  const call$ = withOptionalHash$(
    (hash, canonical, fn, args) => upsertCachedStream(
      hash,
      `call-${fn}-${args}`,
      __call$(hash, canonical, fn, args)
    )
  );
  const validateTx$ = getValidateTx(
    withCanonicalChain(call$, false),
    getRuntimeContext$
  );
  const innerBody$ = (hash) => upsertCachedStream(hash, "body", _body$(hash, false));
  const trackTx$ = getTrackTx(pinnedBlocks$, innerBody$, validateTx$, eventsAt$);
  const trackTxWithoutEvents$ = getTrackTx(
    pinnedBlocks$,
    innerBody$,
    validateTx$,
    () => rxjs.of()
  );
  const genesis$ = runtime$.pipe(
    rxjs.filter(Boolean),
    rxjs.take(1),
    rxjs.mergeMap((runtime) => {
      const { enc } = runtime.dynamicBuilder.buildStorage(
        "System",
        "BlockHash"
      ).keys;
      let key;
      try {
        key = enc(0);
      } catch {
        key = enc(0n);
      }
      return storage$(
        null,
        false,
        "value",
        () => key,
        null
      );
    }),
    rxjs.shareReplay(1)
  );
  rxjs.merge(runtime$, bestBlocks$).subscribe({
    error() {
    }
  });
  let unfollow = rxjs.noop;
  let started = false;
  let nSubscribers = 0;
  const start = (_nSubscribers) => {
    nSubscribers += _nSubscribers;
    started = true;
    unfollow = startFollow();
  };
  return [
    {
      follow$,
      finalized$,
      best$,
      bestBlocks$,
      runtime$,
      metadata$,
      genesis$,
      header$,
      body$,
      call$: withCanonicalChain(call$),
      storage$: withCanonicalChain(storage$),
      storageQueries$,
      eventsAt$: withCanonicalChain(eventsAt$),
      holdBlock,
      trackTx$,
      trackTxWithoutEvents$,
      validateTx$,
      pinnedBlocks$,
      withRuntime,
      getRuntimeContext$: withOptionalHash$(getRuntimeContext$),
      unfollow: () => {
        if (started == null) return;
        nSubscribers--;
        if (started && !nSubscribers) {
          started = null;
          unfollow();
          unfollow = rxjs.noop;
        }
      }
    },
    start
  ];
};

var getBroadcastTx$ = (baseTransaction) => (transaction) => new rxjs.Observable(
  (observer) => baseTransaction(transaction, (e) => {
    observer.error(e);
  })
);

const clientCache = /* @__PURE__ */ new Map();
const getObservableClient = (substrateClient) => {
  const cached = clientCache.get(substrateClient);
  if (cached) {
    cached.refCount++;
    return cached.client;
  }
  const destroy = () => {
    const cached2 = clientCache.get(substrateClient);
    if (!cached2 || cached2.refCount <= 1) {
      clientCache.delete(substrateClient);
      substrateClient.destroy();
    } else {
      cached2.refCount--;
    }
  };
  let cachedChainhead = null;
  let currentSubscribers = 0;
  let expectedSubscribers = null;
  const client = {
    chainHead$: (_expectedSubscribers) => {
      currentSubscribers++;
      expectedSubscribers || (expectedSubscribers = _expectedSubscribers || 1);
      cachedChainhead || (cachedChainhead = getChainHead$(substrateClient.chainHead));
      const [result, start] = cachedChainhead;
      if (expectedSubscribers === currentSubscribers) {
        const copiedCurrentSubscribers = currentSubscribers;
        currentSubscribers = 0;
        expectedSubscribers = null;
        cachedChainhead = null;
        start(copiedCurrentSubscribers);
      }
      return result;
    },
    broadcastTx$: getBroadcastTx$(substrateClient.transaction),
    destroy
  };
  clientCache.set(substrateClient, { client, refCount: 1 });
  return client;
};

exports.BlockNotPinnedError = BlockNotPinnedError;
exports.BlockPrunedError = BlockPrunedError;
exports.NotBestBlockError = NotBestBlockError;
exports.concatMapEager = concatMapEager;
exports.getObservableClient = getObservableClient;
exports.isBestOrFinalizedBlock = isBestOrFinalizedBlock;
//# sourceMappingURL=index.js.map
