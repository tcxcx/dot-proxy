import { pipe, Observable, filter, mergeMap, take, switchMap, throwError } from 'rxjs';
import { BlockPrunedError, NotBestBlockError } from '../errors.mjs';
import { isBestOrFinalizedBlock } from '../streams/block-operations.mjs';

function withEnsureCanonicalChain(blocks$, follow$, fn) {
  return (hash, ensureCanonical, ...args) => {
    const enhancer = ensureCanonical ? pipe(
      throwWhenPrune(
        hash,
        follow$.pipe(
          filter((evt) => evt.type === "finalized"),
          mergeMap((evt) => evt.prunedBlockHashes)
        )
      ),
      onlyIfIsBestOrFinalized(hash, blocks$)
    ) : (x) => x;
    return enhancer(fn(hash, ...args));
  };
}
const onlyIfIsBestOrFinalized = (hash, blocks$) => (source$) => isBestOrFinalizedBlock(blocks$, hash).pipe(
  take(1),
  switchMap(
    (isBest) => isBest ? source$ : throwError(() => new NotBestBlockError())
  )
);
const throwWhenPrune = (hash, pruned$) => (source$) => new Observable((subscriber) => {
  const prunedSubscription = pruned$.pipe(filter((h) => h === hash)).subscribe(() => {
    subscriber.error(new BlockPrunedError());
  });
  const sourceSubscription = source$.subscribe(subscriber);
  return () => {
    prunedSubscription.unsubscribe();
    sourceSubscription.unsubscribe();
  };
});

export { withEnsureCanonicalChain };
//# sourceMappingURL=whileBestBlock.mjs.map
