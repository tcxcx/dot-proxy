import { DisjointError } from '@polkadot-api/substrate-client';
import { Subject, filter, distinctUntilChanged, scan, mergeAll, map, switchMap, take, mergeMap, shareReplay, merge, Observable, share, ReplaySubject, tap, defer, of, noop } from 'rxjs';
import { getWithRecovery } from './enhancers/operationLimitRecovery.mjs';
import { getWithOptionalhash$ } from './enhancers/optionalHash.mjs';
import { fromAbortControllerFn } from './enhancers/fromAbortControllerFn.mjs';
import { withLazyFollower } from './enhancers/lazyFollower.mjs';
import { withEnsureCanonicalChain } from './enhancers/whileBestBlock.mjs';
import { withStopRecovery } from './enhancers/withStopRecovery.mjs';
import { BlockNotPinnedError } from './errors.mjs';
import { getRecoveralStorage$ } from './storage-queries.mjs';
import { getFollow$ } from './streams/follow.mjs';
import './streams/get-runtime-creator.mjs';
import { getPinnedBlocks$ } from './streams/pinned-blocks.mjs';
import { getTrackTx } from './track-tx.mjs';
import { getValidateTx } from './validate-tx.mjs';
import { withDefaultValue } from '../utils/with-default-value.mjs';
import { concatMapEager } from '../utils/concatMapEager.mjs';
import { delayUnsubscription } from '../utils/delay-unsubscription.mjs';
import { shareLatest } from '../utils/shareLatest.mjs';

const toBlockInfo = ({ hash, number, parent }) => ({
  hash,
  number,
  parent
});
const getChainHead$ = (chainHead) => {
  const { getFollower, startFollow, follow$, getHeader } = getFollow$(chainHead);
  const lazyFollower = withLazyFollower(getFollower);
  const { withRecovery, withRecoveryFn } = getWithRecovery();
  const blockUsage$ = new Subject();
  const holdBlock = (hash) => {
    blockUsage$.next({ type: "blockUsage", value: { type: "hold", hash } });
    return () => {
      setTimeout(() => {
        blockUsage$.next({
          type: "blockUsage",
          value: { type: "release", hash }
        });
      }, 0);
    };
  };
  const usingBlock = (blockHash) => (base) => new Observable((observer) => {
    const release = holdBlock(blockHash);
    const subscription = base.subscribe(observer);
    subscription.add(release);
    return subscription;
  });
  const withRefcount = (fn) => (hash, ...args) => fn(hash, ...args).pipe(usingBlock(hash));
  const withInMemory = (fn, label) => (hash, ...args) => new Observable((observer) => {
    let isPresent = false;
    pinnedBlocks$.pipe(take(1)).subscribe((blocks) => {
      const block = blocks.blocks.get(hash);
      isPresent = !!block && !block.unpinned;
    });
    return isPresent ? fn(hash, ...args).subscribe(observer) : observer.error(new BlockNotPinnedError(hash, label));
  });
  const unpin = (hashes) => getFollower().unpin(hashes).catch((e) => {
    if (e instanceof DisjointError) return;
    throw e;
  });
  const commonEnhancer = (fn, label) => {
    const canonicalChain = (_fn) => withEnsureCanonicalChain(pinnedBlocks$, follow$, _fn);
    return withInMemory(
      withRefcount(
        canonicalChain(
          withStopRecovery(
            pinnedBlocks$,
            withRecoveryFn(fromAbortControllerFn(fn)),
            `stop-${label}`
          )
        )
      ),
      label
    );
  };
  const withCanonicalChain = (fn, withCanonicalChain2 = true) => (hash, ...args) => fn(hash, withCanonicalChain2, ...args);
  const cache = /* @__PURE__ */ new Map();
  const pinnedBlocks$ = getPinnedBlocks$(
    follow$,
    withRefcount(withRecoveryFn(fromAbortControllerFn(lazyFollower("call")))),
    blockUsage$,
    (blocks) => {
      unpin(blocks);
      blocks.forEach((hash) => {
        cache.delete(hash);
      });
    },
    (block) => {
      cache.delete(block);
    }
  );
  const getRuntimeContext$ = withRefcount(
    (hash) => pinnedBlocks$.pipe(
      take(1),
      mergeMap(
        (pinned) => pinned.runtimes[pinned.blocks.get(hash).runtime].runtime
      )
    )
  );
  const withRuntime = (mapper) => (source$) => source$.pipe(
    concatMapEager(
      (x) => getRuntimeContext$(mapper(x)).pipe(map((runtime) => [x, runtime]))
    )
  );
  const upsertCachedStream = (hash, key, stream) => {
    const hashCache = cache.get(hash) ?? /* @__PURE__ */ new Map();
    const cached = hashCache.get(key);
    if (cached) return cached;
    cache.set(hash, hashCache);
    let connector;
    const result = stream.pipe(
      share({
        connector: () => connector = new ReplaySubject()
      }),
      tap({
        complete() {
          hashCache.set(key, connector);
        }
      }),
      delayUnsubscription()
    );
    hashCache.set(key, result);
    return result;
  };
  const finalized$ = pinnedBlocks$.pipe(
    filter((x) => !x.recovering),
    distinctUntilChanged((a, b) => a.finalized === b.finalized),
    scan((acc, value) => {
      let current = value.blocks.get(value.finalized);
      const result = [current];
      const latest = acc.at(-1);
      if (!latest) return result;
      while (current.number > latest.number + 1) {
        current = value.blocks.get(current.parent);
        if (!current) break;
        result.unshift(current);
      }
      return result;
    }, []),
    mergeAll(),
    map(toBlockInfo),
    shareLatest
  );
  const best$ = pinnedBlocks$.pipe(
    distinctUntilChanged((a, b) => a.best === b.best),
    map((pinned) => toBlockInfo(pinned.blocks.get(pinned.best))),
    shareLatest
  );
  const bestBlocks$ = pinnedBlocks$.pipe(
    filter((x) => !x.recovering),
    distinctUntilChanged(
      (prev, current) => prev.finalized === current.finalized && prev.best === current.best
    ),
    scan((acc, pinned) => {
      const getBlockInfo = (hash) => acc.get(hash) || toBlockInfo(pinned.blocks.get(hash));
      const best = getBlockInfo(pinned.best);
      const finalized = getBlockInfo(pinned.finalized);
      const len = best.number - finalized.number + 1;
      const result = new Array(len);
      for (let i = 0, hash = best.hash; i < len; i++) {
        result[i] = getBlockInfo(hash);
        hash = result[i].parent;
      }
      return new Map(result.map((b) => [b.hash, b]));
    }, /* @__PURE__ */ new Map()),
    map((x) => [...x.values()]),
    shareLatest
  );
  const runtime$ = pinnedBlocks$.pipe(
    distinctUntilChanged((a, b) => a.finalizedRuntime === b.finalizedRuntime),
    switchMap(
      ({ finalizedRuntime: { runtime } }) => runtime.pipe(withDefaultValue(null))
    ),
    shareLatest
  );
  const metadata$ = runtime$.pipe(map((x) => x?.lookup.metadata ?? null));
  const withOptionalHash$ = getWithOptionalhash$(
    finalized$.pipe(map((b) => b.hash)),
    best$.pipe(map((b) => b.hash)),
    usingBlock
  );
  const _body$ = withOptionalHash$(commonEnhancer(lazyFollower("body"), "body"));
  const body$ = (hash) => upsertCachedStream(hash, "body", _body$(hash, true));
  const _storage$ = commonEnhancer(lazyFollower("storage"), "storage");
  const storage$ = withOptionalHash$(
    (hash, withCanonicalChain2, type, keyMapper, childTrie = null, mapper) => pinnedBlocks$.pipe(
      take(1),
      mergeMap(
        (pinned) => pinned.runtimes[pinned.blocks.get(hash).runtime].runtime
      ),
      mergeMap((ctx) => {
        const key = keyMapper(ctx);
        const unMapped$ = upsertCachedStream(
          hash,
          `storage-${type}-${key}-${childTrie ?? ""}`,
          _storage$(hash, withCanonicalChain2, type, key, childTrie)
        );
        return mapper ? upsertCachedStream(
          hash,
          `storage-${type}-${key}-${childTrie ?? ""}-dec`,
          unMapped$.pipe(
            map((raw) => ({ raw, mapped: mapper(raw, ctx) }))
          )
        ) : unMapped$;
      })
    )
  );
  const recoveralStorage$ = getRecoveralStorage$(getFollower, withRecovery);
  const storageQueries$ = withOptionalHash$(
    withStopRecovery(
      pinnedBlocks$,
      (hash, queries, childTrie) => recoveralStorage$(hash, queries, childTrie ?? null, false),
      `storageQueries`
    )
  );
  const header$ = withOptionalHash$(
    withStopRecovery(
      pinnedBlocks$,
      (hash) => defer(() => getHeader(hash)),
      "header"
    )
  );
  const eventsAt$ = (hash, canonical = false) => storage$(
    hash,
    canonical,
    "value",
    (ctx) => ctx.events.key,
    null,
    (x, ctx) => ctx.events.dec(x)
  ).pipe(map((x) => x.mapped));
  const __call$ = commonEnhancer(lazyFollower("call"), "call");
  const call$ = withOptionalHash$(
    (hash, canonical, fn, args) => upsertCachedStream(
      hash,
      `call-${fn}-${args}`,
      __call$(hash, canonical, fn, args)
    )
  );
  const validateTx$ = getValidateTx(
    withCanonicalChain(call$, false),
    getRuntimeContext$
  );
  const innerBody$ = (hash) => upsertCachedStream(hash, "body", _body$(hash, false));
  const trackTx$ = getTrackTx(pinnedBlocks$, innerBody$, validateTx$, eventsAt$);
  const trackTxWithoutEvents$ = getTrackTx(
    pinnedBlocks$,
    innerBody$,
    validateTx$,
    () => of()
  );
  const genesis$ = runtime$.pipe(
    filter(Boolean),
    take(1),
    mergeMap((runtime) => {
      const { enc } = runtime.dynamicBuilder.buildStorage(
        "System",
        "BlockHash"
      ).keys;
      let key;
      try {
        key = enc(0);
      } catch {
        key = enc(0n);
      }
      return storage$(
        null,
        false,
        "value",
        () => key,
        null
      );
    }),
    shareReplay(1)
  );
  merge(runtime$, bestBlocks$).subscribe({
    error() {
    }
  });
  let unfollow = noop;
  let started = false;
  let nSubscribers = 0;
  const start = (_nSubscribers) => {
    nSubscribers += _nSubscribers;
    started = true;
    unfollow = startFollow();
  };
  return [
    {
      follow$,
      finalized$,
      best$,
      bestBlocks$,
      runtime$,
      metadata$,
      genesis$,
      header$,
      body$,
      call$: withCanonicalChain(call$),
      storage$: withCanonicalChain(storage$),
      storageQueries$,
      eventsAt$: withCanonicalChain(eventsAt$),
      holdBlock,
      trackTx$,
      trackTxWithoutEvents$,
      validateTx$,
      pinnedBlocks$,
      withRuntime,
      getRuntimeContext$: withOptionalHash$(getRuntimeContext$),
      unfollow: () => {
        if (started == null) return;
        nSubscribers--;
        if (started && !nSubscribers) {
          started = null;
          unfollow();
          unfollow = noop;
        }
      }
    },
    start
  ];
};

export { getChainHead$ };
//# sourceMappingURL=chainHead.mjs.map
