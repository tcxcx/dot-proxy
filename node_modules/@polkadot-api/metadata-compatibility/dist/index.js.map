{"version":3,"file":"index.js","sources":["../src/typedef.ts","../src/isCompatible.ts","../src/doubleSet.ts","../src/isStaticCompatible.ts","../src/entryPoint.ts"],"sourcesContent":["import type { MetadataPrimitives, Var } from \"@polkadot-api/metadata-builders\"\nimport {\n  Codec,\n  Option,\n  Self,\n  StringRecord,\n  Struct,\n  Tuple,\n  Variant,\n  Vector,\n  _void,\n  compactNumber,\n  str,\n} from \"@polkadot-api/substrate-bindings\"\n\nconst smallCompact = compactNumber\nexport interface StructNode {\n  type: \"struct\"\n  value: Array<[string, number]>\n}\nconst StructCodec = Vector(Tuple(str, smallCompact))\n\nexport const Primitive = {\n  bool: \"boolean\" as const,\n  str: \"string\" as const,\n  num: \"number\" as const,\n  big: \"bigint\" as const,\n  bits: \"bitseq\" as const,\n  void: \"void\" as const,\n}\nexport type PRIMITIVES = (typeof Primitive)[keyof typeof Primitive]\n\nexport interface TerminalNode {\n  type: \"terminal\"\n  value: {\n    type: PRIMITIVES\n  }\n}\nconst TerminalCodec = Variant(\n  Object.fromEntries(\n    Object.values(Primitive).map((p) => [p, _void]),\n  ) as StringRecord<Codec<undefined>>,\n) as any as Codec<TerminalNode[\"value\"]>\n\nexport interface EnumNode {\n  type: \"enum\"\n  value: Array<[string, TypedefNode | undefined]>\n}\nconst EnumCodec = Vector(Tuple(str, Option(Self(() => TypedefCodec))))\n\nexport interface TupleNode {\n  type: \"tuple\"\n  value: number[]\n}\nconst TupleCodec = Vector(smallCompact)\n\nexport interface ArrayNode {\n  type: \"array\"\n  value: {\n    typeRef: number\n    length?: number\n  }\n}\nconst ArrayCodec = Struct({\n  typeRef: smallCompact,\n  length: Option(smallCompact),\n}) as Codec<ArrayNode[\"value\"]>\n\nexport interface BinaryNode {\n  type: \"binary\"\n  value: number | undefined\n}\nconst BinaryCodec = Option(compactNumber) as Codec<BinaryNode[\"value\"]>\n\nexport interface OptionNode {\n  type: \"option\"\n  value: number\n}\nconst OptionCodec = smallCompact\n\nexport interface ResultNode {\n  type: \"result\"\n  value: {\n    ok: number\n    ko: number\n  }\n}\nconst ResultCodec = Struct({\n  ok: smallCompact,\n  ko: smallCompact,\n})\n\nexport type TypedefNode =\n  | StructNode\n  | TerminalNode\n  | EnumNode\n  | TupleNode\n  | ArrayNode\n  | BinaryNode\n  | OptionNode\n  | ResultNode\nexport const TypedefCodec: Codec<TypedefNode> = Variant({\n  struct: StructCodec,\n  terminal: TerminalCodec,\n  enum: EnumCodec,\n  tuple: TupleCodec,\n  array: ArrayCodec,\n  binary: BinaryCodec,\n  option: OptionCodec,\n  result: ResultCodec,\n})\n\nconst primitiveToTerminal: Record<MetadataPrimitives, PRIMITIVES> = {\n  i256: Primitive.big,\n  i128: Primitive.big,\n  i64: Primitive.big,\n  i32: Primitive.num,\n  i16: Primitive.num,\n  i8: Primitive.num,\n  u256: Primitive.big,\n  u128: Primitive.big,\n  u64: Primitive.big,\n  u32: Primitive.num,\n  u16: Primitive.num,\n  u8: Primitive.num,\n  bool: Primitive.bool,\n  char: Primitive.str,\n  str: Primitive.str,\n}\n\nconst terminal = (type: PRIMITIVES): TerminalNode => ({\n  type: \"terminal\",\n  value: { type },\n})\nexport function mapLookupToTypedef(\n  entry: Var,\n  resolve: (id: number) => void = () => {},\n): TypedefNode {\n  switch (entry.type) {\n    case \"AccountId20\":\n    case \"AccountId32\":\n      return terminal(Primitive.str)\n    case \"array\":\n      if (entry.value.type === \"primitive\" && entry.value.value === \"u8\") {\n        return { type: \"binary\", value: entry.len }\n      }\n      resolve(entry.value.id)\n      return {\n        type: \"array\",\n        value: {\n          typeRef: entry.value.id,\n          length: entry.len,\n        },\n      }\n    case \"bitSequence\":\n      return terminal(Primitive.bits)\n    case \"compact\":\n      return terminal(entry.isBig ? Primitive.big : Primitive.num)\n    case \"enum\":\n      return {\n        type: \"enum\",\n        value: Object.entries(entry.value).map(([key, params]) => {\n          if (params.type === \"lookupEntry\") resolve(params.value.id)\n          return [\n            key,\n            params.type === \"lookupEntry\"\n              ? mapLookupToTypedef(params.value, resolve)\n              : mapLookupToTypedef(params, resolve),\n          ]\n        }),\n      }\n    case \"struct\": {\n      const value = Object.entries(entry.value).map(\n        ([key, prop]) => [key, prop.id] satisfies [string, number],\n      )\n      value.forEach(([, v]) => resolve(v))\n      return {\n        type: \"struct\",\n        value,\n      }\n    }\n    case \"tuple\": {\n      const value = entry.value.map((v) => v.id)\n      value.forEach(resolve)\n      return {\n        type: \"tuple\",\n        value,\n      }\n    }\n    case \"option\":\n      resolve(entry.value.id)\n      return {\n        type: \"option\",\n        value: entry.value.id,\n      }\n    case \"primitive\":\n      return terminal(primitiveToTerminal[entry.value])\n    case \"result\":\n      resolve(entry.value.ok.id)\n      resolve(entry.value.ko.id)\n      return {\n        type: \"result\",\n        value: {\n          ok: entry.value.ok.id,\n          ko: entry.value.ko.id,\n        },\n      }\n    case \"sequence\":\n      if (entry.value.type === \"primitive\" && entry.value.value === \"u8\") {\n        return { type: \"binary\", value: undefined }\n      }\n      resolve(entry.value.id)\n      return {\n        type: \"array\",\n        value: { typeRef: entry.value.id },\n      }\n    case \"void\":\n      return terminal(Primitive.void)\n  }\n}\n\nexport function mapReferences(\n  node: TypedefNode,\n  mapFn: (id: number) => number,\n): TypedefNode {\n  switch (node.type) {\n    case \"array\":\n      return {\n        ...node,\n        value: {\n          ...node.value,\n          typeRef: mapFn(node.value.typeRef),\n        },\n      }\n    case \"option\":\n      return { ...node, value: mapFn(node.value) }\n    case \"result\":\n      return {\n        ...node,\n        value: { ok: mapFn(node.value.ok), ko: mapFn(node.value.ko) },\n      }\n    case \"tuple\":\n      return { ...node, value: node.value.map(mapFn) }\n    case \"struct\":\n      return {\n        ...node,\n        value: node.value.map(([k, v]) => [k, mapFn(v)] as [string, number]),\n      }\n    case \"enum\":\n      return {\n        ...node,\n        value: node.value.map(\n          ([k, v]) =>\n            [k, v == undefined ? undefined : mapReferences(v, mapFn)] as [\n              string,\n              TypedefNode | undefined,\n            ],\n        ),\n      }\n    case \"binary\":\n    case \"terminal\":\n      return node\n  }\n}\n","import { Binary } from \"@polkadot-api/substrate-bindings\"\nimport { Primitive, type TerminalNode, type TypedefNode } from \"./typedef\"\n\n// Descriptors: pallet + name => index (this._descriptors[opType][pallet][name])\n// index will be for both checksums and compatLookup\n\n// Dest type: describes types of the receiving end.\nexport function isCompatible(\n  value: any,\n  destNode: TypedefNode,\n  getNode: (id: number) => TypedefNode,\n): boolean {\n  if (destNode.type === \"option\" && value == null) {\n    return true\n  }\n\n  const nextCall = (value: any, destNode: TypedefNode) =>\n    isCompatible(value, destNode, getNode)\n\n  const checkTerminal = (terminal: TerminalNode) => {\n    switch (terminal.value.type) {\n      case Primitive.str:\n      case Primitive.big:\n      case Primitive.bool:\n      case Primitive.num:\n        return typeof value === terminal.value.type\n      case Primitive.bits:\n        return (\n          typeof value === \"object\" &&\n          value != null &&\n          typeof value.bitsLen === \"number\" &&\n          value.bytes instanceof Uint8Array\n        )\n      case Primitive.void:\n        // A void node is always compatible, since the codec ignores the input.\n        return true\n    }\n  }\n\n  switch (destNode.type) {\n    case \"terminal\":\n      return checkTerminal(destNode)\n    case \"binary\":\n      return (\n        value instanceof Binary &&\n        (destNode.value == null || value.asBytes().length >= destNode.value)\n      )\n    case \"array\":\n      if (!Array.isArray(value)) return false\n      const valueArr = value as Array<any>\n      if (\n        destNode.value.length != null &&\n        valueArr.length < destNode.value.length\n      ) {\n        return false\n      }\n      return valueArr\n        .slice(0, destNode.value.length)\n        .every((value) => nextCall(value, getNode(destNode.value.typeRef)))\n    case \"enum\":\n      if (!value) return false\n      const valueEnum = value as { type: string; value: any }\n      const destVariants = Object.fromEntries(destNode.value)\n      if (!(valueEnum.type in destVariants)) {\n        return false\n      }\n      const variantValue = destVariants[valueEnum.type]\n      if (variantValue == null) {\n        return true\n      }\n      return nextCall(valueEnum.value, variantValue)\n    case \"option\":\n      if (value == null) {\n        return true\n      }\n      return nextCall(value, getNode(destNode.value))\n    case \"struct\":\n      if (!value) return false\n      return destNode.value.every(([key, typeRef]) =>\n        nextCall(value[key], getNode(typeRef)),\n      )\n    case \"tuple\":\n      if (!value) return false\n      // length will be checked indirectly\n      return destNode.value.every((typeRef, idx) =>\n        nextCall(value[idx], getNode(typeRef)),\n      )\n    case \"result\":\n      if (!(\"success\" in value && \"value\" in value)) return false\n      return nextCall(\n        value.value,\n        getNode(value.success ? destNode.value.ok : destNode.value.ko),\n      )\n  }\n}\n","export class DoubleSet<T> {\n  private value: Map<T, Set<T>> = new Map()\n\n  constructor(values: Array<[T, T]> = []) {\n    values.forEach(([a, b]) => this.add(a, b))\n  }\n\n  public has(a: T, b: T) {\n    return this.value.get(a)?.has(b) ?? false\n  }\n  public add(a: T, b: T) {\n    if (!this.value.has(a)) {\n      this.value.set(a, new Set())\n    }\n    this.value.get(a)!.add(b)\n  }\n  public addAll(values: Array<[T, T]>) {\n    values.forEach(([a, b]) => this.add(a, b))\n  }\n  public delete(a: T, b: T) {\n    if (!this.value.has(a)) return\n    const set = this.value.get(a)!\n    set.delete(b)\n    if (!set.size) {\n      this.value.delete(a)\n    }\n  }\n  public isEmpty() {\n    return !this.value.size\n  }\n  public get values() {\n    return Array.from(this.value).flatMap(([a, values]) =>\n      Array.from(values).map((b) => [a, b] as [T, T]),\n    )\n  }\n}\n","import { DoubleSet } from \"./doubleSet\"\nimport type {\n  ArrayNode,\n  BinaryNode,\n  EnumNode,\n  OptionNode,\n  ResultNode,\n  StructNode,\n  TerminalNode,\n  TupleNode,\n  TypedefNode,\n} from \"./typedef\"\n\nexport enum CompatibilityLevel {\n  // No possible value from origin will be compatible with dest\n  Incompatible = 0,\n  // Some values of origin will be compatible with dest\n  Partial,\n  // Every value from origin will be compatible with dest\n  BackwardsCompatible,\n  // Types are identical\n  Identical,\n}\n\n/*\n * We have to be careful with circular references and early returns with the cache.\n *\n * For early returns, the resulting level could be even lower when exploring other branches.\n * This means that we can't store early returns in the cache. For simplicity, the\n * initial implementation will not have early returns.\n * It should be possible to store in the cache what was the CompatibilityLevel that\n * caused the early return, so that if the same call is done with the same CompatibilityLevel\n * we could still leverage the cache.\n *\n * For circular references, the simplest solution is to assume that the circular\n * node is fully-compatible (Identical). But then any node that is reading from it\n * can't be cached because its result will be doing the assumption that the circular\n * node is `Identical`.\n * Only once the whole cycle has completed, then the circular node can actually\n * cache its own result (TODO check this assumption is fine), and then any other\n * node that referenced it can also safely cache.\n * We have to think cases where there could be two cycles:\n *         F ← E\n *         ↓   ↑\n * A → B → C → D\n *     ↑       ↓\n *     I ← H ← G\n *\n * B = 4 => B = 1\n * B = 1 => B = 0\n *\n * As we're going depth-first, when we reach C from F, we will return a \"temporary\"\n * `Identical`. This means that F, E or D can't be cached. But then we continue\n * depth-first into G-H-I-B, then detect the cycle and return a \"temporary\" `Identical`.\n * Then I, H, G and C can't be cached because they actually depend on the temporary result of B.\n * B on the other hand will be able to cache its own result, and so does A.\n *\n * If a new call enters the cycle from D, then the branch G-H-I-B will be cached.\n * But the cycle D-E-F-C will make E-F-C not to cache their result yet.\n *\n *\n * => Maybe instead of having two separate [originNode, destNode] we can first merge\n * both trees into one, and then run the search? This would simplify the double-map/set stuff.\n * Can it be done lazily though? In a way that we don't need to go through the whole tree?\n */\n\nexport type StaticCompatibleResult = {\n  level: CompatibilityLevel\n  assumptions: DoubleSet<TypedefNode>\n}\nexport type CompatibilityCache = Map<\n  TypedefNode,\n  Map<TypedefNode, CompatibilityLevel | null>\n>\nexport function isStaticCompatible(\n  originNode: TypedefNode | undefined,\n  getOriginNode: (id: number) => TypedefNode,\n  destNode: TypedefNode | undefined,\n  getDestNode: (id: number) => TypedefNode,\n  cache: CompatibilityCache,\n): StaticCompatibleResult {\n  if (!destNode && !originNode) {\n    return unconditional(CompatibilityLevel.Identical)\n  }\n  if (!destNode) return unconditional(CompatibilityLevel.BackwardsCompatible)\n  if (!originNode)\n    return unconditional(\n      destNode.type === \"option\"\n        ? CompatibilityLevel.BackwardsCompatible\n        : CompatibilityLevel.Incompatible,\n    )\n\n  if (!cache.has(destNode)) {\n    cache.set(destNode, new Map())\n  }\n  const destNodeCache = cache.get(destNode)!\n  if (destNodeCache.has(originNode)) {\n    const result = destNodeCache.get(originNode)\n    if (result === null) {\n      // Circular reference hit, return Identical with assumption\n      return {\n        level: CompatibilityLevel.Identical,\n        assumptions: new DoubleSet([[originNode, destNode]]),\n      }\n    }\n    return unconditional(result!)\n  }\n\n  // Initialize to null for detecting circular references\n  destNodeCache.set(originNode, null)\n\n  const result = getIsStaticCompatible(\n    originNode,\n    destNode,\n    (originNode, destNode) =>\n      isStaticCompatible(\n        typeof originNode === \"number\" ? getOriginNode(originNode) : originNode,\n        getOriginNode,\n        typeof destNode === \"number\" ? getDestNode(destNode) : destNode,\n        getDestNode,\n        cache,\n      ),\n  )\n\n  result.assumptions.delete(originNode, destNode)\n  if (\n    result.assumptions.isEmpty() ||\n    result.level === CompatibilityLevel.Incompatible\n  ) {\n    destNodeCache.set(originNode, result.level)\n  } else {\n    // Remove the temporary `null` value from the cache\n    destNodeCache.delete(originNode)\n  }\n  return result\n}\n\nfunction getIsStaticCompatible(\n  originNode: TypedefNode,\n  destNode: TypedefNode,\n  nextCall: (\n    originNode: TypedefNode | number | undefined,\n    destNode: TypedefNode | number | undefined,\n  ) => StaticCompatibleResult,\n): StaticCompatibleResult {\n  if (originNode.type !== destNode.type) {\n    if (destNode.type === \"option\") {\n      return withMaxLevel(\n        nextCall(originNode, destNode.value),\n        CompatibilityLevel.BackwardsCompatible,\n      )\n    }\n    if (originNode.type === \"option\") {\n      return withMaxLevel(\n        nextCall(originNode.value, destNode),\n        CompatibilityLevel.Partial,\n      )\n    }\n    return unconditional(CompatibilityLevel.Incompatible)\n  }\n\n  switch (destNode.type) {\n    case \"terminal\":\n      return unconditional(\n        destNode.value.type === (originNode as TerminalNode).value.type\n          ? CompatibilityLevel.Identical\n          : CompatibilityLevel.Incompatible,\n      )\n    case \"binary\":\n      const binaryOrigin = originNode as BinaryNode\n      return unconditional(\n        compareOptionalLengths(binaryOrigin.value, destNode.value),\n      )\n    case \"array\":\n      const arrayOrigin = originNode as ArrayNode\n      const lengthCheck = unconditional(\n        compareOptionalLengths(arrayOrigin.value.length, destNode.value.length),\n      )\n      return strictMerge([\n        lengthCheck,\n        () => nextCall(arrayOrigin.value.typeRef, destNode.value.typeRef),\n      ])\n    case \"enum\": {\n      const enumOrigin = originNode as EnumNode\n      const destVariants = Object.fromEntries(destNode.value)\n      const maxLevel =\n        enumOrigin.value.length === destNode.value.length\n          ? CompatibilityLevel.Identical\n          : CompatibilityLevel.BackwardsCompatible\n\n      // check whether every possible `origin` value is compatible with dest\n      return withMaxLevel(\n        mergeResults(\n          enumOrigin.value.map(\n            ([type, value]) =>\n              () =>\n                type in destVariants\n                  ? nextCall(value, destVariants[type])\n                  : unconditional(CompatibilityLevel.Incompatible),\n          ),\n        ),\n        maxLevel,\n      )\n    }\n    case \"option\":\n      return nextCall((originNode as OptionNode).value, destNode.value)\n    case \"struct\":\n      const structOrigin = originNode as StructNode\n      const originProperties = Object.fromEntries(structOrigin.value)\n      const maxLevel =\n        structOrigin.value.length === destNode.value.length\n          ? CompatibilityLevel.Identical\n          : CompatibilityLevel.BackwardsCompatible\n\n      return withMaxLevel(\n        strictMerge(\n          destNode.value.map(\n            ([key, value]) =>\n              () =>\n                nextCall(originProperties[key], value),\n          ),\n        ),\n        maxLevel,\n      )\n    case \"tuple\": {\n      const tupleOrigin = originNode as TupleNode\n      const lengthCheck = unconditional(\n        compareArrayLengths(tupleOrigin.value, destNode.value),\n      )\n      return strictMerge([\n        lengthCheck,\n        ...destNode.value.map(\n          (value, idx) => () => nextCall(tupleOrigin.value[idx], value),\n        ),\n      ])\n    }\n    case \"result\":\n      const resultOrigin = originNode as ResultNode\n      return mergeResults([\n        nextCall(resultOrigin.value.ok, destNode.value.ok),\n        nextCall(resultOrigin.value.ko, destNode.value.ko),\n      ])\n  }\n}\n\nconst withMaxLevel = (\n  result: StaticCompatibleResult,\n  level: CompatibilityLevel,\n): StaticCompatibleResult => ({\n  ...result,\n  // Confusing yes, but it's Math.min. If we do withMaxLevel(result, 1), we expect to get at most [1] as a result\n  level: Math.min(result.level, level),\n})\nconst noAssumptions = new DoubleSet<TypedefNode>()\nexport const unconditional = (\n  level: CompatibilityLevel,\n): StaticCompatibleResult => ({\n  level,\n  assumptions: noAssumptions,\n})\n\n/**\n * Merges multiple results, following the most \"strict\" one, (semantically an\n * AND)\n */\nexport const strictMerge = (\n  results: Array<StaticCompatibleResult | (() => StaticCompatibleResult)>,\n): StaticCompatibleResult => {\n  let merged = unconditional(CompatibilityLevel.Identical)\n\n  for (const resultFn of results) {\n    const result = typeof resultFn === \"function\" ? resultFn() : resultFn\n    // On early return we don't need to keep the other assumptions\n    if (result.level === CompatibilityLevel.Incompatible) return result\n\n    merged.assumptions.addAll(result.assumptions.values)\n    merged.level = Math.min(merged.level, result.level)\n  }\n\n  return merged\n}\n\n/**\n * Merges multiple results, going to `partially` (semantically an OR)\n */\nconst mergeResults = (\n  results: Array<StaticCompatibleResult | (() => StaticCompatibleResult)>,\n): StaticCompatibleResult => {\n  if (!results.length) return unconditional(CompatibilityLevel.Identical)\n\n  let hasCompatibles = false\n\n  let merged = unconditional(CompatibilityLevel.Identical)\n  for (const resultFn of results) {\n    const result = typeof resultFn === \"function\" ? resultFn() : resultFn\n    if (result.level === CompatibilityLevel.Incompatible) {\n      merged.level = Math.min(merged.level, CompatibilityLevel.Partial)\n      continue\n    }\n    hasCompatibles = true\n\n    merged.assumptions.addAll(result.assumptions.values)\n    merged.level = Math.min(merged.level, result.level)\n  }\n\n  return hasCompatibles\n    ? merged\n    : unconditional(CompatibilityLevel.Incompatible)\n}\n\nexport const compareArrayLengths = (\n  origin: unknown[],\n  dest: unknown[],\n): CompatibilityLevel =>\n  dest.length === origin.length\n    ? CompatibilityLevel.Identical\n    : origin.length >= dest.length\n      ? CompatibilityLevel.BackwardsCompatible\n      : CompatibilityLevel.Incompatible\n\nexport const compareOptionalLengths = (\n  origin: number | undefined,\n  dest: number | undefined,\n): CompatibilityLevel =>\n  dest === origin\n    ? CompatibilityLevel.Identical\n    : dest == null || origin! >= dest\n      ? CompatibilityLevel.BackwardsCompatible\n      : origin == null\n        ? CompatibilityLevel.Partial\n        : CompatibilityLevel.Incompatible\n","import type { EnumVar } from \"@polkadot-api/metadata-builders\"\nimport {\n  compactNumber,\n  Struct,\n  Variant,\n  type V14,\n  type V15,\n} from \"@polkadot-api/substrate-bindings\"\nimport { isCompatible } from \"./isCompatible\"\nimport { CompatibilityCache, isStaticCompatible } from \"./isStaticCompatible\"\nimport {\n  mapLookupToTypedef,\n  mapReferences,\n  Primitive,\n  TypedefCodec,\n  type TypedefNode,\n} from \"./typedef\"\n\nexport type EntryPointNode =\n  | {\n      type: \"lookup\"\n      value: number\n    }\n  | {\n      type: \"typedef\"\n      value: TypedefNode\n    }\nconst EntryPointNodeCodec = Variant({\n  lookup: compactNumber,\n  typedef: TypedefCodec,\n})\n\nconst lookupNode = (value: number): EntryPointNode => ({\n  type: \"lookup\",\n  value,\n})\nconst typedefNode = (value: TypedefNode): EntryPointNode => ({\n  type: \"typedef\",\n  value,\n})\nexport const voidEntryPointNode = typedefNode({\n  type: \"terminal\",\n  value: { type: Primitive.void },\n})\n\nexport interface EntryPoint {\n  args: EntryPointNode\n  values: EntryPointNode\n}\nexport const EntryPointCodec = Struct({\n  args: EntryPointNodeCodec,\n  values: EntryPointNodeCodec,\n})\n\nexport function storageEntryPoint(\n  storageEntry: Exclude<\n    (V15 | V14)[\"pallets\"][number][\"storage\"],\n    undefined\n  >[\"items\"][number],\n): EntryPoint {\n  if (storageEntry.type.tag === \"plain\")\n    return {\n      args: voidEntryPointNode,\n      values: lookupNode(storageEntry.type.value),\n    }\n\n  const { key, value } = storageEntry.type.value\n  return {\n    args: lookupNode(key),\n    values: lookupNode(value),\n  }\n}\n\nexport function runtimeCallEntryPoint(\n  entry: (V15 | V14)[\"apis\"][number][\"methods\"][number],\n): EntryPoint {\n  return {\n    args: typedefNode({\n      type: \"tuple\",\n      value: entry.inputs.map((v) => v.type),\n    }),\n    values: lookupNode(entry.output),\n  }\n}\n\nexport function enumValueEntryPointNode(\n  entry: EnumVar[\"value\"][keyof EnumVar[\"value\"]],\n): EntryPointNode {\n  return entry.type === \"lookupEntry\"\n    ? lookupNode(entry.value.id)\n    : typedefNode(mapLookupToTypedef(entry))\n}\n\nexport function singleValueEntryPoint(value: number): EntryPoint {\n  return {\n    args: voidEntryPointNode,\n    values: lookupNode(value),\n  }\n}\n\nexport function entryPointsAreCompatible(\n  descriptorEntry: EntryPoint,\n  getDescriptorNode: (id: number) => TypedefNode,\n  runtimeEntry: EntryPoint,\n  getRuntimeNode: (id: number) => TypedefNode,\n  cache: CompatibilityCache,\n) {\n  const resolveNode = (\n    node: EntryPointNode,\n    getTypedef: (id: number) => TypedefNode,\n  ): TypedefNode =>\n    node.type === \"lookup\" ? getTypedef(node.value) : node.value\n\n  // EntryPoint interaction \"origin -> dest\" is descriptor -> runtime for args, and runtime -> descriptor for values.\n  return {\n    args: isStaticCompatible(\n      resolveNode(descriptorEntry.args, getDescriptorNode),\n      getDescriptorNode,\n      resolveNode(runtimeEntry.args, getRuntimeNode),\n      getRuntimeNode,\n      cache,\n    ).level,\n    values: isStaticCompatible(\n      resolveNode(runtimeEntry.values, getRuntimeNode),\n      getRuntimeNode,\n      resolveNode(descriptorEntry.values, getDescriptorNode),\n      getDescriptorNode,\n      cache,\n    ).level,\n  }\n}\n\nexport function valueIsCompatibleWithDest(\n  dest: EntryPointNode,\n  getDestNode: (id: number) => TypedefNode,\n  value: unknown,\n) {\n  const node = dest.type === \"lookup\" ? getDestNode(dest.value) : dest.value\n  return isCompatible(value, node, getDestNode)\n}\n\nexport function mapEntryPointReferences(\n  entryPoint: EntryPoint,\n  mapFn: (id: number) => number,\n): EntryPoint {\n  const mapNode = (node: EntryPointNode) =>\n    node.type === \"lookup\"\n      ? lookupNode(mapFn(node.value))\n      : typedefNode(mapReferences(node.value, mapFn))\n\n  return {\n    args: mapNode(entryPoint.args),\n    values: mapNode(entryPoint.values),\n  }\n}\n"],"names":["compactNumber","Vector","Tuple","str","Variant","_void","Option","Self","Struct","value","destNode","Binary","CompatibilityLevel","result","originNode","maxLevel","lengthCheck"],"mappings":"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"}