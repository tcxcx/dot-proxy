import { Var, EnumVar } from '@polkadot-api/metadata-builders';
import * as _polkadot_api_substrate_bindings from '@polkadot-api/substrate-bindings';
import { Codec, V15, V14 } from '@polkadot-api/substrate-bindings';

interface StructNode {
    type: "struct";
    value: Array<[string, number]>;
}
declare const Primitive: {
    bool: "boolean";
    str: "string";
    num: "number";
    big: "bigint";
    bits: "bitseq";
    void: "void";
};
type PRIMITIVES = (typeof Primitive)[keyof typeof Primitive];
interface TerminalNode {
    type: "terminal";
    value: {
        type: PRIMITIVES;
    };
}
interface EnumNode {
    type: "enum";
    value: Array<[string, TypedefNode | undefined]>;
}
interface TupleNode {
    type: "tuple";
    value: number[];
}
interface ArrayNode {
    type: "array";
    value: {
        typeRef: number;
        length?: number;
    };
}
interface BinaryNode {
    type: "binary";
    value: number | undefined;
}
interface OptionNode {
    type: "option";
    value: number;
}
interface ResultNode {
    type: "result";
    value: {
        ok: number;
        ko: number;
    };
}
type TypedefNode = StructNode | TerminalNode | EnumNode | TupleNode | ArrayNode | BinaryNode | OptionNode | ResultNode;
declare const TypedefCodec: Codec<TypedefNode>;
declare function mapLookupToTypedef(entry: Var, resolve?: (id: number) => void): TypedefNode;
declare function mapReferences(node: TypedefNode, mapFn: (id: number) => number): TypedefNode;

declare function isCompatible(value: any, destNode: TypedefNode, getNode: (id: number) => TypedefNode): boolean;

declare class DoubleSet<T> {
    private value;
    constructor(values?: Array<[T, T]>);
    has(a: T, b: T): boolean;
    add(a: T, b: T): void;
    addAll(values: Array<[T, T]>): void;
    delete(a: T, b: T): void;
    isEmpty(): boolean;
    get values(): [T, T][];
}

declare enum CompatibilityLevel {
    Incompatible = 0,
    Partial = 1,
    BackwardsCompatible = 2,
    Identical = 3
}
type StaticCompatibleResult = {
    level: CompatibilityLevel;
    assumptions: DoubleSet<TypedefNode>;
};
type CompatibilityCache = Map<TypedefNode, Map<TypedefNode, CompatibilityLevel | null>>;
declare function isStaticCompatible(originNode: TypedefNode | undefined, getOriginNode: (id: number) => TypedefNode, destNode: TypedefNode | undefined, getDestNode: (id: number) => TypedefNode, cache: CompatibilityCache): StaticCompatibleResult;

type EntryPointNode = {
    type: "lookup";
    value: number;
} | {
    type: "typedef";
    value: TypedefNode;
};
declare const voidEntryPointNode: EntryPointNode;
interface EntryPoint {
    args: EntryPointNode;
    values: EntryPointNode;
}
declare const EntryPointCodec: _polkadot_api_substrate_bindings.Codec<{
    args: _polkadot_api_substrate_bindings.Enum<{
        lookup: number;
        typedef: TypedefNode;
    }>;
    values: _polkadot_api_substrate_bindings.Enum<{
        lookup: number;
        typedef: TypedefNode;
    }>;
}>;
declare function storageEntryPoint(storageEntry: Exclude<(V15 | V14)["pallets"][number]["storage"], undefined>["items"][number]): EntryPoint;
declare function runtimeCallEntryPoint(entry: (V15 | V14)["apis"][number]["methods"][number]): EntryPoint;
declare function enumValueEntryPointNode(entry: EnumVar["value"][keyof EnumVar["value"]]): EntryPointNode;
declare function singleValueEntryPoint(value: number): EntryPoint;
declare function entryPointsAreCompatible(descriptorEntry: EntryPoint, getDescriptorNode: (id: number) => TypedefNode, runtimeEntry: EntryPoint, getRuntimeNode: (id: number) => TypedefNode, cache: CompatibilityCache): {
    args: CompatibilityLevel;
    values: CompatibilityLevel;
};
declare function valueIsCompatibleWithDest(dest: EntryPointNode, getDestNode: (id: number) => TypedefNode, value: unknown): boolean;
declare function mapEntryPointReferences(entryPoint: EntryPoint, mapFn: (id: number) => number): EntryPoint;

export { type CompatibilityCache, CompatibilityLevel, type EntryPoint, EntryPointCodec, type EntryPointNode, type StaticCompatibleResult, TypedefCodec, type TypedefNode, entryPointsAreCompatible, enumValueEntryPointNode, isCompatible, isStaticCompatible, mapEntryPointReferences, mapLookupToTypedef, mapReferences, runtimeCallEntryPoint, singleValueEntryPoint, storageEntryPoint, valueIsCompatibleWithDest, voidEntryPointNode };
