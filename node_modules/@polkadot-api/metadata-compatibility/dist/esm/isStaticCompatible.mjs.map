{"version":3,"file":"isStaticCompatible.mjs","sources":["../../src/isStaticCompatible.ts"],"sourcesContent":["import { DoubleSet } from \"./doubleSet\"\nimport type {\n  ArrayNode,\n  BinaryNode,\n  EnumNode,\n  OptionNode,\n  ResultNode,\n  StructNode,\n  TerminalNode,\n  TupleNode,\n  TypedefNode,\n} from \"./typedef\"\n\nexport enum CompatibilityLevel {\n  // No possible value from origin will be compatible with dest\n  Incompatible = 0,\n  // Some values of origin will be compatible with dest\n  Partial,\n  // Every value from origin will be compatible with dest\n  BackwardsCompatible,\n  // Types are identical\n  Identical,\n}\n\n/*\n * We have to be careful with circular references and early returns with the cache.\n *\n * For early returns, the resulting level could be even lower when exploring other branches.\n * This means that we can't store early returns in the cache. For simplicity, the\n * initial implementation will not have early returns.\n * It should be possible to store in the cache what was the CompatibilityLevel that\n * caused the early return, so that if the same call is done with the same CompatibilityLevel\n * we could still leverage the cache.\n *\n * For circular references, the simplest solution is to assume that the circular\n * node is fully-compatible (Identical). But then any node that is reading from it\n * can't be cached because its result will be doing the assumption that the circular\n * node is `Identical`.\n * Only once the whole cycle has completed, then the circular node can actually\n * cache its own result (TODO check this assumption is fine), and then any other\n * node that referenced it can also safely cache.\n * We have to think cases where there could be two cycles:\n *         F ← E\n *         ↓   ↑\n * A → B → C → D\n *     ↑       ↓\n *     I ← H ← G\n *\n * B = 4 => B = 1\n * B = 1 => B = 0\n *\n * As we're going depth-first, when we reach C from F, we will return a \"temporary\"\n * `Identical`. This means that F, E or D can't be cached. But then we continue\n * depth-first into G-H-I-B, then detect the cycle and return a \"temporary\" `Identical`.\n * Then I, H, G and C can't be cached because they actually depend on the temporary result of B.\n * B on the other hand will be able to cache its own result, and so does A.\n *\n * If a new call enters the cycle from D, then the branch G-H-I-B will be cached.\n * But the cycle D-E-F-C will make E-F-C not to cache their result yet.\n *\n *\n * => Maybe instead of having two separate [originNode, destNode] we can first merge\n * both trees into one, and then run the search? This would simplify the double-map/set stuff.\n * Can it be done lazily though? In a way that we don't need to go through the whole tree?\n */\n\nexport type StaticCompatibleResult = {\n  level: CompatibilityLevel\n  assumptions: DoubleSet<TypedefNode>\n}\nexport type CompatibilityCache = Map<\n  TypedefNode,\n  Map<TypedefNode, CompatibilityLevel | null>\n>\nexport function isStaticCompatible(\n  originNode: TypedefNode | undefined,\n  getOriginNode: (id: number) => TypedefNode,\n  destNode: TypedefNode | undefined,\n  getDestNode: (id: number) => TypedefNode,\n  cache: CompatibilityCache,\n): StaticCompatibleResult {\n  if (!destNode && !originNode) {\n    return unconditional(CompatibilityLevel.Identical)\n  }\n  if (!destNode) return unconditional(CompatibilityLevel.BackwardsCompatible)\n  if (!originNode)\n    return unconditional(\n      destNode.type === \"option\"\n        ? CompatibilityLevel.BackwardsCompatible\n        : CompatibilityLevel.Incompatible,\n    )\n\n  if (!cache.has(destNode)) {\n    cache.set(destNode, new Map())\n  }\n  const destNodeCache = cache.get(destNode)!\n  if (destNodeCache.has(originNode)) {\n    const result = destNodeCache.get(originNode)\n    if (result === null) {\n      // Circular reference hit, return Identical with assumption\n      return {\n        level: CompatibilityLevel.Identical,\n        assumptions: new DoubleSet([[originNode, destNode]]),\n      }\n    }\n    return unconditional(result!)\n  }\n\n  // Initialize to null for detecting circular references\n  destNodeCache.set(originNode, null)\n\n  const result = getIsStaticCompatible(\n    originNode,\n    destNode,\n    (originNode, destNode) =>\n      isStaticCompatible(\n        typeof originNode === \"number\" ? getOriginNode(originNode) : originNode,\n        getOriginNode,\n        typeof destNode === \"number\" ? getDestNode(destNode) : destNode,\n        getDestNode,\n        cache,\n      ),\n  )\n\n  result.assumptions.delete(originNode, destNode)\n  if (\n    result.assumptions.isEmpty() ||\n    result.level === CompatibilityLevel.Incompatible\n  ) {\n    destNodeCache.set(originNode, result.level)\n  } else {\n    // Remove the temporary `null` value from the cache\n    destNodeCache.delete(originNode)\n  }\n  return result\n}\n\nfunction getIsStaticCompatible(\n  originNode: TypedefNode,\n  destNode: TypedefNode,\n  nextCall: (\n    originNode: TypedefNode | number | undefined,\n    destNode: TypedefNode | number | undefined,\n  ) => StaticCompatibleResult,\n): StaticCompatibleResult {\n  if (originNode.type !== destNode.type) {\n    if (destNode.type === \"option\") {\n      return withMaxLevel(\n        nextCall(originNode, destNode.value),\n        CompatibilityLevel.BackwardsCompatible,\n      )\n    }\n    if (originNode.type === \"option\") {\n      return withMaxLevel(\n        nextCall(originNode.value, destNode),\n        CompatibilityLevel.Partial,\n      )\n    }\n    return unconditional(CompatibilityLevel.Incompatible)\n  }\n\n  switch (destNode.type) {\n    case \"terminal\":\n      return unconditional(\n        destNode.value.type === (originNode as TerminalNode).value.type\n          ? CompatibilityLevel.Identical\n          : CompatibilityLevel.Incompatible,\n      )\n    case \"binary\":\n      const binaryOrigin = originNode as BinaryNode\n      return unconditional(\n        compareOptionalLengths(binaryOrigin.value, destNode.value),\n      )\n    case \"array\":\n      const arrayOrigin = originNode as ArrayNode\n      const lengthCheck = unconditional(\n        compareOptionalLengths(arrayOrigin.value.length, destNode.value.length),\n      )\n      return strictMerge([\n        lengthCheck,\n        () => nextCall(arrayOrigin.value.typeRef, destNode.value.typeRef),\n      ])\n    case \"enum\": {\n      const enumOrigin = originNode as EnumNode\n      const destVariants = Object.fromEntries(destNode.value)\n      const maxLevel =\n        enumOrigin.value.length === destNode.value.length\n          ? CompatibilityLevel.Identical\n          : CompatibilityLevel.BackwardsCompatible\n\n      // check whether every possible `origin` value is compatible with dest\n      return withMaxLevel(\n        mergeResults(\n          enumOrigin.value.map(\n            ([type, value]) =>\n              () =>\n                type in destVariants\n                  ? nextCall(value, destVariants[type])\n                  : unconditional(CompatibilityLevel.Incompatible),\n          ),\n        ),\n        maxLevel,\n      )\n    }\n    case \"option\":\n      return nextCall((originNode as OptionNode).value, destNode.value)\n    case \"struct\":\n      const structOrigin = originNode as StructNode\n      const originProperties = Object.fromEntries(structOrigin.value)\n      const maxLevel =\n        structOrigin.value.length === destNode.value.length\n          ? CompatibilityLevel.Identical\n          : CompatibilityLevel.BackwardsCompatible\n\n      return withMaxLevel(\n        strictMerge(\n          destNode.value.map(\n            ([key, value]) =>\n              () =>\n                nextCall(originProperties[key], value),\n          ),\n        ),\n        maxLevel,\n      )\n    case \"tuple\": {\n      const tupleOrigin = originNode as TupleNode\n      const lengthCheck = unconditional(\n        compareArrayLengths(tupleOrigin.value, destNode.value),\n      )\n      return strictMerge([\n        lengthCheck,\n        ...destNode.value.map(\n          (value, idx) => () => nextCall(tupleOrigin.value[idx], value),\n        ),\n      ])\n    }\n    case \"result\":\n      const resultOrigin = originNode as ResultNode\n      return mergeResults([\n        nextCall(resultOrigin.value.ok, destNode.value.ok),\n        nextCall(resultOrigin.value.ko, destNode.value.ko),\n      ])\n  }\n}\n\nconst withMaxLevel = (\n  result: StaticCompatibleResult,\n  level: CompatibilityLevel,\n): StaticCompatibleResult => ({\n  ...result,\n  // Confusing yes, but it's Math.min. If we do withMaxLevel(result, 1), we expect to get at most [1] as a result\n  level: Math.min(result.level, level),\n})\nconst noAssumptions = new DoubleSet<TypedefNode>()\nexport const unconditional = (\n  level: CompatibilityLevel,\n): StaticCompatibleResult => ({\n  level,\n  assumptions: noAssumptions,\n})\n\n/**\n * Merges multiple results, following the most \"strict\" one, (semantically an\n * AND)\n */\nexport const strictMerge = (\n  results: Array<StaticCompatibleResult | (() => StaticCompatibleResult)>,\n): StaticCompatibleResult => {\n  let merged = unconditional(CompatibilityLevel.Identical)\n\n  for (const resultFn of results) {\n    const result = typeof resultFn === \"function\" ? resultFn() : resultFn\n    // On early return we don't need to keep the other assumptions\n    if (result.level === CompatibilityLevel.Incompatible) return result\n\n    merged.assumptions.addAll(result.assumptions.values)\n    merged.level = Math.min(merged.level, result.level)\n  }\n\n  return merged\n}\n\n/**\n * Merges multiple results, going to `partially` (semantically an OR)\n */\nconst mergeResults = (\n  results: Array<StaticCompatibleResult | (() => StaticCompatibleResult)>,\n): StaticCompatibleResult => {\n  if (!results.length) return unconditional(CompatibilityLevel.Identical)\n\n  let hasCompatibles = false\n\n  let merged = unconditional(CompatibilityLevel.Identical)\n  for (const resultFn of results) {\n    const result = typeof resultFn === \"function\" ? resultFn() : resultFn\n    if (result.level === CompatibilityLevel.Incompatible) {\n      merged.level = Math.min(merged.level, CompatibilityLevel.Partial)\n      continue\n    }\n    hasCompatibles = true\n\n    merged.assumptions.addAll(result.assumptions.values)\n    merged.level = Math.min(merged.level, result.level)\n  }\n\n  return hasCompatibles\n    ? merged\n    : unconditional(CompatibilityLevel.Incompatible)\n}\n\nexport const compareArrayLengths = (\n  origin: unknown[],\n  dest: unknown[],\n): CompatibilityLevel =>\n  dest.length === origin.length\n    ? CompatibilityLevel.Identical\n    : origin.length >= dest.length\n      ? CompatibilityLevel.BackwardsCompatible\n      : CompatibilityLevel.Incompatible\n\nexport const compareOptionalLengths = (\n  origin: number | undefined,\n  dest: number | undefined,\n): CompatibilityLevel =>\n  dest === origin\n    ? CompatibilityLevel.Identical\n    : dest == null || origin! >= dest\n      ? CompatibilityLevel.BackwardsCompatible\n      : origin == null\n        ? CompatibilityLevel.Partial\n        : CompatibilityLevel.Incompatible\n"],"names":["CompatibilityLevel","result","originNode","destNode","maxLevel","lengthCheck"],"mappings":"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"}