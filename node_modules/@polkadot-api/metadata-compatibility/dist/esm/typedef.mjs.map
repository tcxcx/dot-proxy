{"version":3,"file":"typedef.mjs","sources":["../../src/typedef.ts"],"sourcesContent":["import type { MetadataPrimitives, Var } from \"@polkadot-api/metadata-builders\"\nimport {\n  Codec,\n  Option,\n  Self,\n  StringRecord,\n  Struct,\n  Tuple,\n  Variant,\n  Vector,\n  _void,\n  compactNumber,\n  str,\n} from \"@polkadot-api/substrate-bindings\"\n\nconst smallCompact = compactNumber\nexport interface StructNode {\n  type: \"struct\"\n  value: Array<[string, number]>\n}\nconst StructCodec = Vector(Tuple(str, smallCompact))\n\nexport const Primitive = {\n  bool: \"boolean\" as const,\n  str: \"string\" as const,\n  num: \"number\" as const,\n  big: \"bigint\" as const,\n  bits: \"bitseq\" as const,\n  void: \"void\" as const,\n}\nexport type PRIMITIVES = (typeof Primitive)[keyof typeof Primitive]\n\nexport interface TerminalNode {\n  type: \"terminal\"\n  value: {\n    type: PRIMITIVES\n  }\n}\nconst TerminalCodec = Variant(\n  Object.fromEntries(\n    Object.values(Primitive).map((p) => [p, _void]),\n  ) as StringRecord<Codec<undefined>>,\n) as any as Codec<TerminalNode[\"value\"]>\n\nexport interface EnumNode {\n  type: \"enum\"\n  value: Array<[string, TypedefNode | undefined]>\n}\nconst EnumCodec = Vector(Tuple(str, Option(Self(() => TypedefCodec))))\n\nexport interface TupleNode {\n  type: \"tuple\"\n  value: number[]\n}\nconst TupleCodec = Vector(smallCompact)\n\nexport interface ArrayNode {\n  type: \"array\"\n  value: {\n    typeRef: number\n    length?: number\n  }\n}\nconst ArrayCodec = Struct({\n  typeRef: smallCompact,\n  length: Option(smallCompact),\n}) as Codec<ArrayNode[\"value\"]>\n\nexport interface BinaryNode {\n  type: \"binary\"\n  value: number | undefined\n}\nconst BinaryCodec = Option(compactNumber) as Codec<BinaryNode[\"value\"]>\n\nexport interface OptionNode {\n  type: \"option\"\n  value: number\n}\nconst OptionCodec = smallCompact\n\nexport interface ResultNode {\n  type: \"result\"\n  value: {\n    ok: number\n    ko: number\n  }\n}\nconst ResultCodec = Struct({\n  ok: smallCompact,\n  ko: smallCompact,\n})\n\nexport type TypedefNode =\n  | StructNode\n  | TerminalNode\n  | EnumNode\n  | TupleNode\n  | ArrayNode\n  | BinaryNode\n  | OptionNode\n  | ResultNode\nexport const TypedefCodec: Codec<TypedefNode> = Variant({\n  struct: StructCodec,\n  terminal: TerminalCodec,\n  enum: EnumCodec,\n  tuple: TupleCodec,\n  array: ArrayCodec,\n  binary: BinaryCodec,\n  option: OptionCodec,\n  result: ResultCodec,\n})\n\nconst primitiveToTerminal: Record<MetadataPrimitives, PRIMITIVES> = {\n  i256: Primitive.big,\n  i128: Primitive.big,\n  i64: Primitive.big,\n  i32: Primitive.num,\n  i16: Primitive.num,\n  i8: Primitive.num,\n  u256: Primitive.big,\n  u128: Primitive.big,\n  u64: Primitive.big,\n  u32: Primitive.num,\n  u16: Primitive.num,\n  u8: Primitive.num,\n  bool: Primitive.bool,\n  char: Primitive.str,\n  str: Primitive.str,\n}\n\nconst terminal = (type: PRIMITIVES): TerminalNode => ({\n  type: \"terminal\",\n  value: { type },\n})\nexport function mapLookupToTypedef(\n  entry: Var,\n  resolve: (id: number) => void = () => {},\n): TypedefNode {\n  switch (entry.type) {\n    case \"AccountId20\":\n    case \"AccountId32\":\n      return terminal(Primitive.str)\n    case \"array\":\n      if (entry.value.type === \"primitive\" && entry.value.value === \"u8\") {\n        return { type: \"binary\", value: entry.len }\n      }\n      resolve(entry.value.id)\n      return {\n        type: \"array\",\n        value: {\n          typeRef: entry.value.id,\n          length: entry.len,\n        },\n      }\n    case \"bitSequence\":\n      return terminal(Primitive.bits)\n    case \"compact\":\n      return terminal(entry.isBig ? Primitive.big : Primitive.num)\n    case \"enum\":\n      return {\n        type: \"enum\",\n        value: Object.entries(entry.value).map(([key, params]) => {\n          if (params.type === \"lookupEntry\") resolve(params.value.id)\n          return [\n            key,\n            params.type === \"lookupEntry\"\n              ? mapLookupToTypedef(params.value, resolve)\n              : mapLookupToTypedef(params, resolve),\n          ]\n        }),\n      }\n    case \"struct\": {\n      const value = Object.entries(entry.value).map(\n        ([key, prop]) => [key, prop.id] satisfies [string, number],\n      )\n      value.forEach(([, v]) => resolve(v))\n      return {\n        type: \"struct\",\n        value,\n      }\n    }\n    case \"tuple\": {\n      const value = entry.value.map((v) => v.id)\n      value.forEach(resolve)\n      return {\n        type: \"tuple\",\n        value,\n      }\n    }\n    case \"option\":\n      resolve(entry.value.id)\n      return {\n        type: \"option\",\n        value: entry.value.id,\n      }\n    case \"primitive\":\n      return terminal(primitiveToTerminal[entry.value])\n    case \"result\":\n      resolve(entry.value.ok.id)\n      resolve(entry.value.ko.id)\n      return {\n        type: \"result\",\n        value: {\n          ok: entry.value.ok.id,\n          ko: entry.value.ko.id,\n        },\n      }\n    case \"sequence\":\n      if (entry.value.type === \"primitive\" && entry.value.value === \"u8\") {\n        return { type: \"binary\", value: undefined }\n      }\n      resolve(entry.value.id)\n      return {\n        type: \"array\",\n        value: { typeRef: entry.value.id },\n      }\n    case \"void\":\n      return terminal(Primitive.void)\n  }\n}\n\nexport function mapReferences(\n  node: TypedefNode,\n  mapFn: (id: number) => number,\n): TypedefNode {\n  switch (node.type) {\n    case \"array\":\n      return {\n        ...node,\n        value: {\n          ...node.value,\n          typeRef: mapFn(node.value.typeRef),\n        },\n      }\n    case \"option\":\n      return { ...node, value: mapFn(node.value) }\n    case \"result\":\n      return {\n        ...node,\n        value: { ok: mapFn(node.value.ok), ko: mapFn(node.value.ko) },\n      }\n    case \"tuple\":\n      return { ...node, value: node.value.map(mapFn) }\n    case \"struct\":\n      return {\n        ...node,\n        value: node.value.map(([k, v]) => [k, mapFn(v)] as [string, number]),\n      }\n    case \"enum\":\n      return {\n        ...node,\n        value: node.value.map(\n          ([k, v]) =>\n            [k, v == undefined ? undefined : mapReferences(v, mapFn)] as [\n              string,\n              TypedefNode | undefined,\n            ],\n        ),\n      }\n    case \"binary\":\n    case \"terminal\":\n      return node\n  }\n}\n"],"names":[],"mappings":"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"}