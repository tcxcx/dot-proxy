{"version":3,"file":"isCompatible.mjs","sources":["../../src/isCompatible.ts"],"sourcesContent":["import { Binary } from \"@polkadot-api/substrate-bindings\"\nimport { Primitive, type TerminalNode, type TypedefNode } from \"./typedef\"\n\n// Descriptors: pallet + name => index (this._descriptors[opType][pallet][name])\n// index will be for both checksums and compatLookup\n\n// Dest type: describes types of the receiving end.\nexport function isCompatible(\n  value: any,\n  destNode: TypedefNode,\n  getNode: (id: number) => TypedefNode,\n): boolean {\n  if (destNode.type === \"option\" && value == null) {\n    return true\n  }\n\n  const nextCall = (value: any, destNode: TypedefNode) =>\n    isCompatible(value, destNode, getNode)\n\n  const checkTerminal = (terminal: TerminalNode) => {\n    switch (terminal.value.type) {\n      case Primitive.str:\n      case Primitive.big:\n      case Primitive.bool:\n      case Primitive.num:\n        return typeof value === terminal.value.type\n      case Primitive.bits:\n        return (\n          typeof value === \"object\" &&\n          value != null &&\n          typeof value.bitsLen === \"number\" &&\n          value.bytes instanceof Uint8Array\n        )\n      case Primitive.void:\n        // A void node is always compatible, since the codec ignores the input.\n        return true\n    }\n  }\n\n  switch (destNode.type) {\n    case \"terminal\":\n      return checkTerminal(destNode)\n    case \"binary\":\n      return (\n        value instanceof Binary &&\n        (destNode.value == null || value.asBytes().length >= destNode.value)\n      )\n    case \"array\":\n      if (!Array.isArray(value)) return false\n      const valueArr = value as Array<any>\n      if (\n        destNode.value.length != null &&\n        valueArr.length < destNode.value.length\n      ) {\n        return false\n      }\n      return valueArr\n        .slice(0, destNode.value.length)\n        .every((value) => nextCall(value, getNode(destNode.value.typeRef)))\n    case \"enum\":\n      if (!value) return false\n      const valueEnum = value as { type: string; value: any }\n      const destVariants = Object.fromEntries(destNode.value)\n      if (!(valueEnum.type in destVariants)) {\n        return false\n      }\n      const variantValue = destVariants[valueEnum.type]\n      if (variantValue == null) {\n        return true\n      }\n      return nextCall(valueEnum.value, variantValue)\n    case \"option\":\n      if (value == null) {\n        return true\n      }\n      return nextCall(value, getNode(destNode.value))\n    case \"struct\":\n      if (!value) return false\n      return destNode.value.every(([key, typeRef]) =>\n        nextCall(value[key], getNode(typeRef)),\n      )\n    case \"tuple\":\n      if (!value) return false\n      // length will be checked indirectly\n      return destNode.value.every((typeRef, idx) =>\n        nextCall(value[idx], getNode(typeRef)),\n      )\n    case \"result\":\n      if (!(\"success\" in value && \"value\" in value)) return false\n      return nextCall(\n        value.value,\n        getNode(value.success ? destNode.value.ok : destNode.value.ko),\n      )\n  }\n}\n"],"names":["value","destNode"],"mappings":"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"}