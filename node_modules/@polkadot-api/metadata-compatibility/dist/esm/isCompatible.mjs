import { Binary } from '@polkadot-api/substrate-bindings';
import { Primitive } from './typedef.mjs';

function isCompatible(value, destNode, getNode) {
  if (destNode.type === "option" && value == null) {
    return true;
  }
  const nextCall = (value2, destNode2) => isCompatible(value2, destNode2, getNode);
  const checkTerminal = (terminal) => {
    switch (terminal.value.type) {
      case Primitive.str:
      case Primitive.big:
      case Primitive.bool:
      case Primitive.num:
        return typeof value === terminal.value.type;
      case Primitive.bits:
        return typeof value === "object" && value != null && typeof value.bitsLen === "number" && value.bytes instanceof Uint8Array;
      case Primitive.void:
        return true;
    }
  };
  switch (destNode.type) {
    case "terminal":
      return checkTerminal(destNode);
    case "binary":
      return value instanceof Binary && (destNode.value == null || value.asBytes().length >= destNode.value);
    case "array":
      if (!Array.isArray(value)) return false;
      const valueArr = value;
      if (destNode.value.length != null && valueArr.length < destNode.value.length) {
        return false;
      }
      return valueArr.slice(0, destNode.value.length).every((value2) => nextCall(value2, getNode(destNode.value.typeRef)));
    case "enum":
      if (!value) return false;
      const valueEnum = value;
      const destVariants = Object.fromEntries(destNode.value);
      if (!(valueEnum.type in destVariants)) {
        return false;
      }
      const variantValue = destVariants[valueEnum.type];
      if (variantValue == null) {
        return true;
      }
      return nextCall(valueEnum.value, variantValue);
    case "option":
      if (value == null) {
        return true;
      }
      return nextCall(value, getNode(destNode.value));
    case "struct":
      if (!value) return false;
      return destNode.value.every(
        ([key, typeRef]) => nextCall(value[key], getNode(typeRef))
      );
    case "tuple":
      if (!value) return false;
      return destNode.value.every(
        (typeRef, idx) => nextCall(value[idx], getNode(typeRef))
      );
    case "result":
      if (!("success" in value && "value" in value)) return false;
      return nextCall(
        value.value,
        getNode(value.success ? destNode.value.ok : destNode.value.ko)
      );
  }
}

export { isCompatible };
//# sourceMappingURL=isCompatible.mjs.map
