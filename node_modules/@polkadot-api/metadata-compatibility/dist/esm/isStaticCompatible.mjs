import { DoubleSet } from './doubleSet.mjs';

var CompatibilityLevel = /* @__PURE__ */ ((CompatibilityLevel2) => {
  CompatibilityLevel2[CompatibilityLevel2["Incompatible"] = 0] = "Incompatible";
  CompatibilityLevel2[CompatibilityLevel2["Partial"] = 1] = "Partial";
  CompatibilityLevel2[CompatibilityLevel2["BackwardsCompatible"] = 2] = "BackwardsCompatible";
  CompatibilityLevel2[CompatibilityLevel2["Identical"] = 3] = "Identical";
  return CompatibilityLevel2;
})(CompatibilityLevel || {});
function isStaticCompatible(originNode, getOriginNode, destNode, getDestNode, cache) {
  if (!destNode && !originNode) {
    return unconditional(3 /* Identical */);
  }
  if (!destNode) return unconditional(2 /* BackwardsCompatible */);
  if (!originNode)
    return unconditional(
      destNode.type === "option" ? 2 /* BackwardsCompatible */ : 0 /* Incompatible */
    );
  if (!cache.has(destNode)) {
    cache.set(destNode, /* @__PURE__ */ new Map());
  }
  const destNodeCache = cache.get(destNode);
  if (destNodeCache.has(originNode)) {
    const result2 = destNodeCache.get(originNode);
    if (result2 === null) {
      return {
        level: 3 /* Identical */,
        assumptions: new DoubleSet([[originNode, destNode]])
      };
    }
    return unconditional(result2);
  }
  destNodeCache.set(originNode, null);
  const result = getIsStaticCompatible(
    originNode,
    destNode,
    (originNode2, destNode2) => isStaticCompatible(
      typeof originNode2 === "number" ? getOriginNode(originNode2) : originNode2,
      getOriginNode,
      typeof destNode2 === "number" ? getDestNode(destNode2) : destNode2,
      getDestNode,
      cache
    )
  );
  result.assumptions.delete(originNode, destNode);
  if (result.assumptions.isEmpty() || result.level === 0 /* Incompatible */) {
    destNodeCache.set(originNode, result.level);
  } else {
    destNodeCache.delete(originNode);
  }
  return result;
}
function getIsStaticCompatible(originNode, destNode, nextCall) {
  if (originNode.type !== destNode.type) {
    if (destNode.type === "option") {
      return withMaxLevel(
        nextCall(originNode, destNode.value),
        2 /* BackwardsCompatible */
      );
    }
    if (originNode.type === "option") {
      return withMaxLevel(
        nextCall(originNode.value, destNode),
        1 /* Partial */
      );
    }
    return unconditional(0 /* Incompatible */);
  }
  switch (destNode.type) {
    case "terminal":
      return unconditional(
        destNode.value.type === originNode.value.type ? 3 /* Identical */ : 0 /* Incompatible */
      );
    case "binary":
      const binaryOrigin = originNode;
      return unconditional(
        compareOptionalLengths(binaryOrigin.value, destNode.value)
      );
    case "array":
      const arrayOrigin = originNode;
      const lengthCheck = unconditional(
        compareOptionalLengths(arrayOrigin.value.length, destNode.value.length)
      );
      return strictMerge([
        lengthCheck,
        () => nextCall(arrayOrigin.value.typeRef, destNode.value.typeRef)
      ]);
    case "enum": {
      const enumOrigin = originNode;
      const destVariants = Object.fromEntries(destNode.value);
      const maxLevel2 = enumOrigin.value.length === destNode.value.length ? 3 /* Identical */ : 2 /* BackwardsCompatible */;
      return withMaxLevel(
        mergeResults(
          enumOrigin.value.map(
            ([type, value]) => () => type in destVariants ? nextCall(value, destVariants[type]) : unconditional(0 /* Incompatible */)
          )
        ),
        maxLevel2
      );
    }
    case "option":
      return nextCall(originNode.value, destNode.value);
    case "struct":
      const structOrigin = originNode;
      const originProperties = Object.fromEntries(structOrigin.value);
      const maxLevel = structOrigin.value.length === destNode.value.length ? 3 /* Identical */ : 2 /* BackwardsCompatible */;
      return withMaxLevel(
        strictMerge(
          destNode.value.map(
            ([key, value]) => () => nextCall(originProperties[key], value)
          )
        ),
        maxLevel
      );
    case "tuple": {
      const tupleOrigin = originNode;
      const lengthCheck2 = unconditional(
        compareArrayLengths(tupleOrigin.value, destNode.value)
      );
      return strictMerge([
        lengthCheck2,
        ...destNode.value.map(
          (value, idx) => () => nextCall(tupleOrigin.value[idx], value)
        )
      ]);
    }
    case "result":
      const resultOrigin = originNode;
      return mergeResults([
        nextCall(resultOrigin.value.ok, destNode.value.ok),
        nextCall(resultOrigin.value.ko, destNode.value.ko)
      ]);
  }
}
const withMaxLevel = (result, level) => ({
  ...result,
  // Confusing yes, but it's Math.min. If we do withMaxLevel(result, 1), we expect to get at most [1] as a result
  level: Math.min(result.level, level)
});
const noAssumptions = new DoubleSet();
const unconditional = (level) => ({
  level,
  assumptions: noAssumptions
});
const strictMerge = (results) => {
  let merged = unconditional(3 /* Identical */);
  for (const resultFn of results) {
    const result = typeof resultFn === "function" ? resultFn() : resultFn;
    if (result.level === 0 /* Incompatible */) return result;
    merged.assumptions.addAll(result.assumptions.values);
    merged.level = Math.min(merged.level, result.level);
  }
  return merged;
};
const mergeResults = (results) => {
  if (!results.length) return unconditional(3 /* Identical */);
  let hasCompatibles = false;
  let merged = unconditional(3 /* Identical */);
  for (const resultFn of results) {
    const result = typeof resultFn === "function" ? resultFn() : resultFn;
    if (result.level === 0 /* Incompatible */) {
      merged.level = Math.min(merged.level, 1 /* Partial */);
      continue;
    }
    hasCompatibles = true;
    merged.assumptions.addAll(result.assumptions.values);
    merged.level = Math.min(merged.level, result.level);
  }
  return hasCompatibles ? merged : unconditional(0 /* Incompatible */);
};
const compareArrayLengths = (origin, dest) => dest.length === origin.length ? 3 /* Identical */ : origin.length >= dest.length ? 2 /* BackwardsCompatible */ : 0 /* Incompatible */;
const compareOptionalLengths = (origin, dest) => dest === origin ? 3 /* Identical */ : dest == null || origin >= dest ? 2 /* BackwardsCompatible */ : origin == null ? 1 /* Partial */ : 0 /* Incompatible */;

export { CompatibilityLevel, compareArrayLengths, compareOptionalLengths, isStaticCompatible, strictMerge, unconditional };
//# sourceMappingURL=isStaticCompatible.mjs.map
