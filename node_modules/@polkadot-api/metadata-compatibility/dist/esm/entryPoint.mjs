import { Variant, compactNumber, Struct } from '@polkadot-api/substrate-bindings';
import { isCompatible } from './isCompatible.mjs';
import { isStaticCompatible } from './isStaticCompatible.mjs';
import { TypedefCodec, Primitive, mapLookupToTypedef, mapReferences } from './typedef.mjs';

const EntryPointNodeCodec = Variant({
  lookup: compactNumber,
  typedef: TypedefCodec
});
const lookupNode = (value) => ({
  type: "lookup",
  value
});
const typedefNode = (value) => ({
  type: "typedef",
  value
});
const voidEntryPointNode = typedefNode({
  type: "terminal",
  value: { type: Primitive.void }
});
const EntryPointCodec = Struct({
  args: EntryPointNodeCodec,
  values: EntryPointNodeCodec
});
function storageEntryPoint(storageEntry) {
  if (storageEntry.type.tag === "plain")
    return {
      args: voidEntryPointNode,
      values: lookupNode(storageEntry.type.value)
    };
  const { key, value } = storageEntry.type.value;
  return {
    args: lookupNode(key),
    values: lookupNode(value)
  };
}
function runtimeCallEntryPoint(entry) {
  return {
    args: typedefNode({
      type: "tuple",
      value: entry.inputs.map((v) => v.type)
    }),
    values: lookupNode(entry.output)
  };
}
function enumValueEntryPointNode(entry) {
  return entry.type === "lookupEntry" ? lookupNode(entry.value.id) : typedefNode(mapLookupToTypedef(entry));
}
function singleValueEntryPoint(value) {
  return {
    args: voidEntryPointNode,
    values: lookupNode(value)
  };
}
function entryPointsAreCompatible(descriptorEntry, getDescriptorNode, runtimeEntry, getRuntimeNode, cache) {
  const resolveNode = (node, getTypedef) => node.type === "lookup" ? getTypedef(node.value) : node.value;
  return {
    args: isStaticCompatible(
      resolveNode(descriptorEntry.args, getDescriptorNode),
      getDescriptorNode,
      resolveNode(runtimeEntry.args, getRuntimeNode),
      getRuntimeNode,
      cache
    ).level,
    values: isStaticCompatible(
      resolveNode(runtimeEntry.values, getRuntimeNode),
      getRuntimeNode,
      resolveNode(descriptorEntry.values, getDescriptorNode),
      getDescriptorNode,
      cache
    ).level
  };
}
function valueIsCompatibleWithDest(dest, getDestNode, value) {
  const node = dest.type === "lookup" ? getDestNode(dest.value) : dest.value;
  return isCompatible(value, node, getDestNode);
}
function mapEntryPointReferences(entryPoint, mapFn) {
  const mapNode = (node) => node.type === "lookup" ? lookupNode(mapFn(node.value)) : typedefNode(mapReferences(node.value, mapFn));
  return {
    args: mapNode(entryPoint.args),
    values: mapNode(entryPoint.values)
  };
}

export { EntryPointCodec, entryPointsAreCompatible, enumValueEntryPointNode, mapEntryPointReferences, runtimeCallEntryPoint, singleValueEntryPoint, storageEntryPoint, valueIsCompatibleWithDest, voidEntryPointNode };
//# sourceMappingURL=entryPoint.mjs.map
