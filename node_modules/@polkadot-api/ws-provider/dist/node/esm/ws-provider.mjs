import { getSyncProvider } from '@polkadot-api/json-rpc-provider-proxy';
import { WsEvent } from './types.mjs';
import { followEnhancer } from './follow-enhancer.mjs';

const timeoutError = {
  type: WsEvent.ERROR,
  event: { type: "timeout" }
};
const noop = () => {
};
const mapEndpoints = (endpoints) => endpoints.map((x) => typeof x === "string" ? [x] : [x.uri, x.protocol]);
const getInternalWsProvider = (WebsocketClass) => {
  return (...args) => {
    let endpoints = [];
    let onStatusChanged = noop;
    let timeout = 3500;
    const [firstArg] = args;
    if (args.length === 1 && typeof firstArg === "object" && !Array.isArray(firstArg)) {
      endpoints = mapEndpoints(firstArg.endpoints);
      onStatusChanged = firstArg.onStatusChanged ?? noop;
      timeout = firstArg.timeout ?? timeout;
    } else {
      if (typeof args[1] === "function")
        onStatusChanged = args[1];
      if (Array.isArray(firstArg)) endpoints = mapEndpoints(firstArg);
      else {
        endpoints = [[firstArg]];
        if (args[1] && args[1] !== onStatusChanged)
          endpoints[0][1] = args[1];
        if (args[2]) onStatusChanged = args[2];
      }
    }
    let idx = 0;
    let status;
    let switchTo = null;
    let disconnect = noop;
    let outerCleanup = noop;
    const result = followEnhancer(
      getSyncProvider(async () => {
        const [uri, protocols] = switchTo || endpoints[idx++ % endpoints.length];
        switchTo = null;
        const socket = new WebsocketClass(uri, protocols);
        const forceSocketClose = () => {
          try {
            socket.addEventListener("error", noop, { once: true });
            socket.close();
          } catch {
          }
        };
        onStatusChanged(
          status = {
            type: WsEvent.CONNECTING,
            uri,
            protocols
          }
        );
        await new Promise((resolve, reject) => {
          const onOpen = () => {
            initialCleanup();
            resolve();
          };
          const onError = (e) => {
            initialCleanup();
            if (e == null) forceSocketClose();
            console.error(
              `Unable to connect to ${uri}${protocols ? ", protocols: " + protocols : ""}`
            );
            onStatusChanged(
              status = {
                type: e ? WsEvent.ERROR : WsEvent.CLOSE,
                event: e
              }
            );
            setTimeout(reject, e ? 300 : 0, e);
          };
          const timeoutToken = timeout !== Infinity ? setTimeout(() => {
            initialCleanup();
            forceSocketClose();
            onStatusChanged(status = timeoutError);
            reject(timeoutError.event);
          }, timeout) : void 0;
          const initialCleanup = () => {
            clearTimeout(timeoutToken);
            socket.removeEventListener("error", onError);
            socket.removeEventListener("open", onOpen);
          };
          socket.addEventListener("open", onOpen);
          socket.addEventListener("error", onError);
          disconnect = () => {
            onError(null);
          };
        });
        onStatusChanged(
          status = {
            type: WsEvent.CONNECTED,
            uri,
            protocols
          }
        );
        return (onMessage, onHalt) => {
          const _onMessage = (e) => {
            if (typeof e.data === "string") onMessage(e.data);
          };
          const innerHalt = (reason) => (e) => {
            console.warn(`WS halt (${reason})`);
            onStatusChanged(
              status = {
                type: reason,
                event: e
              }
            );
            onHalt();
          };
          const onError = innerHalt(WsEvent.ERROR);
          const onClose = innerHalt(WsEvent.CLOSE);
          socket.addEventListener("message", _onMessage);
          socket.addEventListener("error", onError);
          socket.addEventListener("close", onClose);
          disconnect = (withHalt) => {
            outerCleanup();
            disconnect = noop;
            socket.removeEventListener("message", _onMessage);
            socket.removeEventListener("error", onError);
            socket.removeEventListener("close", onClose);
            forceSocketClose();
            if (withHalt) onClose({});
          };
          return {
            send: (msg) => {
              socket.send(msg);
            },
            disconnect
          };
        };
      }),
      () => {
        switchFn();
      }
    );
    outerCleanup = result.cleanup;
    delete result.cleanup;
    const switchFn = (...args2) => {
      if (status.type === WsEvent.CLOSE) return;
      if (args2.length) switchTo = args2;
      if (status.type !== WsEvent.ERROR) disconnect(true);
    };
    return Object.assign(result, { switch: switchFn, getStatus: () => status });
  };
};

export { getInternalWsProvider };
//# sourceMappingURL=ws-provider.mjs.map
