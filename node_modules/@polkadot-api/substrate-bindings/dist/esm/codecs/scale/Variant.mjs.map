{"version":3,"file":"Variant.mjs","sources":["../../../../src/codecs/scale/Variant.ts"],"sourcesContent":["import {\n  Codec,\n  CodecType,\n  Decoder,\n  DecoderType,\n  Encoder,\n  EncoderType,\n  Enum as ScaleEnum,\n  StringRecord,\n  createCodec,\n} from \"scale-ts\"\nimport { mapObject } from \"@polkadot-api/utils\"\nimport { Enum } from \"@/types/enum\"\n\ntype Tuple<T, N extends number> = readonly [T, ...T[]] & { length: N }\n\ntype Push<T extends any[], V> = [...T, V]\n\ntype UnionToIntersection<U> = (U extends any ? (k: U) => void : never) extends (\n  k: infer I,\n) => void\n  ? I\n  : never\n\ntype LastOf<T> =\n  UnionToIntersection<T extends any ? () => T : never> extends () => infer R\n    ? R\n    : never\n\ntype TuplifyUnion<\n  T,\n  L = LastOf<T>,\n  N = [T] extends [never] ? true : false,\n> = true extends N ? [] : Push<TuplifyUnion<Exclude<T, L>>, L>\n\ntype RestrictedLenTuple<T, O extends StringRecord<any>> = Tuple<\n  T,\n  TuplifyUnion<keyof O> extends Tuple<any, infer V> ? V : 0\n>\n\nconst VariantEnc = <O extends StringRecord<Encoder<any>>>(\n  ...args: [inner: O, x?: RestrictedLenTuple<number, O>]\n): Encoder<\n  Enum<{\n    [K in keyof O]: EncoderType<O[K]>\n  }>\n> => {\n  const enc = ScaleEnum.enc<O>(...(args as [any, any]))\n  return (v) => enc({ tag: v.type, value: v.value })\n}\n\nconst VariantDec = <O extends StringRecord<Decoder<any>>>(\n  ...args: [inner: O, x?: RestrictedLenTuple<number, O>]\n): Decoder<\n  Enum<{\n    [K in keyof O]: DecoderType<O[K]>\n  }>\n> => {\n  const dec = ScaleEnum.dec<O>(...(args as [any, any]))\n  return (v) => {\n    const { tag, value } = dec(v)\n    return Enum(tag as any, value as any) as any\n  }\n}\n\nexport const Variant = <O extends StringRecord<Codec<any>>>(\n  inner: O,\n  ...args: [indexes?: RestrictedLenTuple<number, O>]\n): Codec<\n  Enum<{\n    [K in keyof O]: CodecType<O[K]>\n  }>\n> =>\n  createCodec(\n    VariantEnc(\n      mapObject(inner, ([encoder]) => encoder) as StringRecord<\n        O[keyof O][\"enc\"]\n      >,\n      ...(args as any[]),\n    ) as Encoder<\n      Enum<{\n        [K in keyof O]: CodecType<O[K]>\n      }>\n    >,\n    VariantDec(\n      mapObject(inner, ([, decoder]) => decoder) as StringRecord<\n        O[keyof O][\"dec\"]\n      >,\n      ...(args as any[]),\n    ) as Decoder<\n      Enum<{\n        [K in keyof O]: CodecType<O[K]>\n      }>\n    >,\n  )\n\nVariant.enc = VariantEnc\nVariant.dec = VariantDec\n"],"names":["ScaleEnum","Enum"],"mappings":";;;;AAwCA,MAAM,UAAA,GAAa,IACd,IAKA,KAAA;AACH,EAAA,MAAM,GAAM,GAAAA,IAAA,CAAU,GAAO,CAAA,GAAI,IAAmB,CAAA;AACpD,EAAO,OAAA,CAAC,CAAM,KAAA,GAAA,CAAI,EAAE,GAAA,EAAK,EAAE,IAAM,EAAA,KAAA,EAAO,CAAE,CAAA,KAAA,EAAO,CAAA;AACnD,CAAA;AAEA,MAAM,UAAA,GAAa,IACd,IAKA,KAAA;AACH,EAAA,MAAM,GAAM,GAAAA,IAAA,CAAU,GAAO,CAAA,GAAI,IAAmB,CAAA;AACpD,EAAA,OAAO,CAAC,CAAM,KAAA;AACZ,IAAA,MAAM,EAAE,GAAA,EAAK,KAAM,EAAA,GAAI,IAAI,CAAC,CAAA;AAC5B,IAAO,OAAAC,MAAA,CAAK,KAAY,KAAY,CAAA;AAAA,GACtC;AACF,CAAA;AAEa,MAAA,OAAA,GAAU,CACrB,KAAA,EAAA,GACG,IAMH,KAAA,WAAA;AAAA,EACE,UAAA;AAAA,IACE,UAAU,KAAO,EAAA,CAAC,CAAC,OAAO,MAAM,OAAO,CAAA;AAAA,IAGvC,GAAI;AAAA,GACN;AAAA,EAKA,UAAA;AAAA,IACE,UAAU,KAAO,EAAA,CAAC,GAAG,OAAO,MAAM,OAAO,CAAA;AAAA,IAGzC,GAAI;AAAA;AAMR;AAEF,OAAA,CAAQ,GAAM,GAAA,UAAA;AACd,OAAA,CAAQ,GAAM,GAAA,UAAA;;;;"}