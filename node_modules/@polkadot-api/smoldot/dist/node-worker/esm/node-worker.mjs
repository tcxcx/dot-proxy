import { parentPort } from 'node:worker_threads';
import { start } from 'smoldot';

let smoldot = null;
let chainId = 0;
const chains = /* @__PURE__ */ new Map();
parentPort.on("message", async (msg) => {
  if (msg.type === "start") {
    if (smoldot !== null) {
      throw new Error("Can't call start on a client already started");
    }
    smoldot = start(msg.value);
    return parentPort?.postMessage({
      id: msg.id
    });
  }
  if (smoldot === null) {
    throw new Error("Smoldot not started");
  }
  switch (msg.type) {
    case "add-chain": {
      const potentialRelayChains = msg.value.potentialRelayChainIds?.map(
        (id2) => {
          const chain2 = chains.get(id2);
          if (!chain2) throw new Error("Can't reference removed chain");
          return chain2;
        }
      );
      const chain = await smoldot.addChain({
        ...msg.value,
        potentialRelayChains
      });
      const id = chainId++;
      chains.set(id, chain);
      parentPort?.postMessage({
        id: msg.id,
        value: id
      });
      break;
    }
    case "terminate":
      await smoldot.terminate();
      parentPort?.postMessage({
        id: msg.id
      });
      smoldot = null;
      chains.clear();
      break;
    case "chain":
      handleChainMessage(msg, msg.id);
      break;
  }
});
async function handleChainMessage(msg, id) {
  const chain = chains.get(msg.value.id);
  if (!chain) throw new Error("Can't reference removed chain");
  switch (msg.value.type) {
    case "receive":
      parentPort?.postMessage({
        id,
        value: await chain.nextJsonRpcResponse()
      });
      break;
    case "receiveIterable":
      parentPort?.postMessage({
        id,
        value: await chain.jsonRpcResponses.next()
      });
      break;
    case "send":
      chain.sendJsonRpc(msg.value.value);
      break;
    case "remove":
      chain.remove();
      chains.delete(msg.value.id);
      break;
  }
}
//# sourceMappingURL=node-worker.mjs.map
