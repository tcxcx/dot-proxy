import Queue from './queue.mjs';
import { OUT } from './types.mjs';

const rawLogsToLogs = (rawLogs) => {
  const result = /* @__PURE__ */ new Map();
  let tick = -1;
  for (let i = 0; i < rawLogs.length; i++) {
    const [, clientIdRaw, dateRaw, type, msg] = rawLogs[i].match(
      /^(\d*)-(.{24})-(.{2})-(.*)$/
    );
    const clientId = Number(clientIdRaw);
    tick = new Date(dateRaw).getTime();
    const logs = result.get(clientId) ?? [];
    result.set(clientId, logs);
    logs.push({
      clientId,
      tick,
      type,
      msg
    });
  }
  return result;
};
const extractTx = (msg) => {
  const startTxt = 'TaggedTransactionQueue_validate_transaction","';
  const start = msg.lastIndexOf(startTxt) + startTxt.length + 4;
  const end = msg.indexOf(`"`, start + 1);
  return msg.substring(start, end - 64);
};
const defaultOptions = { speed: 1 };
const logsProvider = (rawLogs, options = {}) => {
  const { speed } = { ...defaultOptions, ...options };
  let nextClientId = 1;
  const allLogs = rawLogsToLogs(
    rawLogs[rawLogs.length - 1] ? rawLogs : rawLogs.slice(0, -1)
  );
  return (onMsg) => {
    const clientId = nextClientId++;
    const logs = allLogs.get(clientId);
    const pending = new Queue();
    let idx = 0;
    let transactions = /* @__PURE__ */ new Map();
    const checkForIncommingMessages = async () => {
      if (!pending.peek()) return;
      while (idx < logs.length && token !== void 0) {
        const expected = logs[idx];
        transactions.forEach((value, key) => {
          expected.msg = expected.msg.replace(key, value);
        });
        if (expected.type === OUT) {
          if (!pending.peek()) {
            token = setTimeout(checkForIncommingMessages, 100);
            break;
          }
          const received = pending.pop();
          if (expected.msg.includes(
            "TaggedTransactionQueue_validate_transaction"
          ) && received?.includes("TaggedTransactionQueue_validate_transaction")) {
            transactions.set(extractTx(expected.msg), extractTx(received));
            transactions.forEach((value, key) => {
              expected.msg = expected.msg.replace(key, value);
            });
          }
          if (received !== expected.msg) {
            console.log(`recieved: "${received}"`);
            console.log(`expected: "${expected.msg}"`);
            throw new Error("unexpected messaged was received");
          }
        } else {
          onMsg(expected.msg);
          const nextOne = logs[idx + 1];
          if (nextOne)
            await new Promise(
              (res) => setTimeout(res, (nextOne.tick - expected.tick) / speed)
            );
        }
        idx++;
      }
    };
    let token = setTimeout(checkForIncommingMessages, 200);
    return {
      send: (msg) => {
        pending.push(msg);
      },
      disconnect: () => {
        clearTimeout(token);
        token = void 0;
      }
    };
  };
};

export { logsProvider };
//# sourceMappingURL=logs-provider.mjs.map
