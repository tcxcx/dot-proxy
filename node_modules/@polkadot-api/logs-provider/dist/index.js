'use strict';

var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
class Queue {
  constructor(...vals) {
    __publicField(this, "first");
    __publicField(this, "last");
    if (vals.length === 0) return;
    vals.forEach((val) => this.push(val));
  }
  push(value) {
    const nextLast = { value };
    if (this.last === void 0) {
      this.last = nextLast;
      this.first = this.last;
    } else {
      this.last.next = nextLast;
      this.last = nextLast;
    }
  }
  pop() {
    const result = this.first?.value;
    if (this.first) {
      this.first = this.first.next;
      if (!this.first) {
        this.last = void 0;
      }
    }
    return result;
  }
  peek() {
    return this.first?.value;
  }
}

const OUT = ">>";
const IN = "<<";

const rawLogsToLogs = (rawLogs) => {
  const result = /* @__PURE__ */ new Map();
  let tick = -1;
  for (let i = 0; i < rawLogs.length; i++) {
    const [, clientIdRaw, dateRaw, type, msg] = rawLogs[i].match(
      /^(\d*)-(.{24})-(.{2})-(.*)$/
    );
    const clientId = Number(clientIdRaw);
    tick = new Date(dateRaw).getTime();
    const logs = result.get(clientId) ?? [];
    result.set(clientId, logs);
    logs.push({
      clientId,
      tick,
      type,
      msg
    });
  }
  return result;
};
const extractTx = (msg) => {
  const startTxt = 'TaggedTransactionQueue_validate_transaction","';
  const start = msg.lastIndexOf(startTxt) + startTxt.length + 4;
  const end = msg.indexOf(`"`, start + 1);
  return msg.substring(start, end - 64);
};
const defaultOptions = { speed: 1 };
const logsProvider = (rawLogs, options = {}) => {
  const { speed } = { ...defaultOptions, ...options };
  let nextClientId = 1;
  const allLogs = rawLogsToLogs(
    rawLogs[rawLogs.length - 1] ? rawLogs : rawLogs.slice(0, -1)
  );
  return (onMsg) => {
    const clientId = nextClientId++;
    const logs = allLogs.get(clientId);
    const pending = new Queue();
    let idx = 0;
    let transactions = /* @__PURE__ */ new Map();
    const checkForIncommingMessages = async () => {
      if (!pending.peek()) return;
      while (idx < logs.length && token !== void 0) {
        const expected = logs[idx];
        transactions.forEach((value, key) => {
          expected.msg = expected.msg.replace(key, value);
        });
        if (expected.type === OUT) {
          if (!pending.peek()) {
            token = setTimeout(checkForIncommingMessages, 100);
            break;
          }
          const received = pending.pop();
          if (expected.msg.includes(
            "TaggedTransactionQueue_validate_transaction"
          ) && received?.includes("TaggedTransactionQueue_validate_transaction")) {
            transactions.set(extractTx(expected.msg), extractTx(received));
            transactions.forEach((value, key) => {
              expected.msg = expected.msg.replace(key, value);
            });
          }
          if (received !== expected.msg) {
            console.log(`recieved: "${received}"`);
            console.log(`expected: "${expected.msg}"`);
            throw new Error("unexpected messaged was received");
          }
        } else {
          onMsg(expected.msg);
          const nextOne = logs[idx + 1];
          if (nextOne)
            await new Promise(
              (res) => setTimeout(res, (nextOne.tick - expected.tick) / speed)
            );
        }
        idx++;
      }
    };
    let token = setTimeout(checkForIncommingMessages, 200);
    return {
      send: (msg) => {
        pending.push(msg);
      },
      disconnect: () => {
        clearTimeout(token);
        token = void 0;
      }
    };
  };
};

const withLogsRecorder = (persistLog, input) => {
  let nextId = 1;
  let token;
  let tickDate = "";
  const setTickDate = () => {
    tickDate = (/* @__PURE__ */ new Date()).toISOString();
    token = setTimeout(setTickDate, 0);
  };
  return (onMsg) => {
    const clientId = nextId++;
    setTickDate();
    const result = input((msg) => {
      persistLog(`${clientId}-${tickDate}-${IN}-${msg}`);
      onMsg(msg);
    });
    return {
      ...result,
      send: (msg) => {
        persistLog(`${clientId}-${tickDate}-${OUT}-${msg}`);
        result.send(msg);
      },
      disconnect() {
        clearTimeout(token);
        result.disconnect();
      }
    };
  };
};

exports.logsProvider = logsProvider;
exports.withLogsRecorder = withLogsRecorder;
//# sourceMappingURL=index.js.map
