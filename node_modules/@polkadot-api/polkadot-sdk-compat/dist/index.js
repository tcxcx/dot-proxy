'use strict';

const toParsed = (base) => {
  let _onMsg = null;
  const { send, disconnect } = base((msg) => {
    _onMsg?.(JSON.parse(msg));
  });
  return (onMsg) => {
    _onMsg = onMsg;
    return {
      send(msg) {
        send(JSON.stringify(msg));
      },
      disconnect() {
        _onMsg = null;
        disconnect();
      }
    };
  };
};
const fromParsed = (base) => {
  let _onMsg = null;
  const { send, disconnect } = base((msg) => {
    _onMsg?.(JSON.stringify(msg));
  });
  return (onMsg) => {
    _onMsg = onMsg;
    return {
      send(msg) {
        send(JSON.parse(msg));
      },
      disconnect() {
        _onMsg = null;
        disconnect();
      }
    };
  };
};
const parsed = (...enhancers) => (base) => fromParsed(enhancers.reduce((a, b) => b(a), toParsed(base)));

const chainHead = {
  body: "",
  call: "",
  continue: "",
  follow: "",
  header: "",
  stopOperation: "",
  storage: "",
  unfollow: "",
  unpin: ""
};
const transaction = {
  broadcast: "",
  stop: ""
};
const chainSpec = {
  chainName: "",
  genesisHash: "",
  properties: ""
};
Object.entries({ chainHead, chainSpec, transaction }).forEach(
  ([fnGroupName, methods]) => {
    Object.keys(methods).forEach((methodName) => {
      methods[methodName] = `${fnGroupName}_v1_${methodName}`;
    });
  }
);

var methods = /*#__PURE__*/Object.freeze({
  __proto__: null,
  chainHead: chainHead,
  chainSpec: chainSpec,
  transaction: transaction
});

const fixChainSpec = (base) => (onMsg) => {
  const { send: originalSend, disconnect } = base(onMsg);
  const send = (msg) => {
    switch (msg.method) {
      case chainSpec.chainName:
        return originalSend({ ...msg, method: "system_chain" });
      case chainSpec.genesisHash:
        return originalSend({
          ...msg,
          method: "chain_getBlockHash",
          params: [0]
        });
      case chainSpec.properties:
        return originalSend({ ...msg, method: "system_properties" });
    }
    originalSend(msg);
  };
  return {
    send,
    disconnect
  };
};

const fixPrematureBlocks = (base) => (onMsg) => {
  const pendingChainHeadSubs = /* @__PURE__ */ new Set();
  const pinnedBlocksInSub = /* @__PURE__ */ new Map();
  const prematureBlocks = /* @__PURE__ */ new Map();
  const { send: originalSend, disconnect } = base((message) => {
    if ("id" in message) {
      onMsg(message);
      const { id, result } = message;
      if (pendingChainHeadSubs.has(id)) {
        pendingChainHeadSubs.delete(id);
        pinnedBlocksInSub.set(result, /* @__PURE__ */ new Set());
        prematureBlocks.set(result, /* @__PURE__ */ new Map());
        return;
      }
    } else {
      const { subscription } = message.params;
      const pinnedBlocks = pinnedBlocksInSub.get(subscription);
      const prematureSub = prematureBlocks.get(subscription);
      if (pinnedBlocks) {
        const result = message.params.result;
        const { event } = result;
        if (event === "initialized") {
          result.finalizedBlockHashes.forEach((hash) => {
            pinnedBlocks.add(hash);
          });
        }
        if (event === "newBlock") {
          const { parentBlockHash } = result;
          if (!pinnedBlocks.has(parentBlockHash)) {
            const list = prematureSub.get(parentBlockHash) ?? [];
            list.push(message);
            prematureSub.set(parentBlockHash, list);
            return;
          }
          const hash = result.blockHash;
          pinnedBlocks.add(result.blockHash);
          onMsg(message);
          const prematureMessages = prematureSub.get(hash);
          if (prematureMessages) {
            prematureSub.delete(hash);
            prematureMessages.forEach((msg) => {
              pinnedBlocks.add(msg.params.result.blockHash);
              onMsg(msg);
            });
          }
          return;
        }
        if (event === "stop") {
          pinnedBlocks.delete(subscription);
          prematureBlocks.delete(subscription);
        }
      }
      onMsg(message);
    }
  });
  const send = (msg) => {
    const subId = msg.params[0];
    switch (msg.method) {
      case chainHead.follow:
        pendingChainHeadSubs.add(msg.id);
        break;
      case chainHead.unpin:
        const [subscription, blocks] = msg.params;
        blocks.forEach((block) => {
          pinnedBlocksInSub.get(subscription)?.delete(block);
          prematureBlocks.get(subscription)?.delete(block);
        });
        break;
      case chainHead.unfollow:
        pinnedBlocksInSub.delete(subId);
        prematureBlocks.delete(subId);
        break;
    }
    originalSend(msg);
  };
  return {
    send,
    disconnect
  };
};

const jsonObj = (input) => ({
  jsonrpc: "2.0",
  ...input
});
const operationNotification = (subscription, event, operationId, innerResult = {}) => jsonObj({
  method: "chainHead_v1_followEvent",
  params: {
    subscription,
    result: {
      event,
      operationId,
      ...innerResult
    }
  }
});
const requestPrefix = "__INNER_RQ_DesV";
const getRequest = (base) => {
  let nextId = 0;
  const onGoingRequests = /* @__PURE__ */ new Map();
  const listener = ({ id, error, result }) => {
    const callback = onGoingRequests.get(id);
    if (callback) {
      onGoingRequests.delete(id);
      if (error) callback(false, error);
      else callback(true, result);
    }
    return !callback;
  };
  let send = () => {
  };
  const provider = (onMsg) => {
    const { send: _send, disconnect } = base((msg) => {
      if (listener(msg)) onMsg(msg);
    });
    send = _send;
    return {
      send,
      disconnect: () => {
        onGoingRequests.clear();
        disconnect();
      }
    };
  };
  const request = (method, params, onSuccess, onError) => {
    const id = requestPrefix + nextId++;
    onGoingRequests.set(id, (isOk, value) => {
      (isOk ? onSuccess : onError)(value);
    });
    send(jsonObj({ id, method, params }));
  };
  return [provider, request];
};

const operationPrefix = "__INNER_OP_DesV";
let nextOperationId = 0;
const fixDescendantValues = (base) => (onMsg) => {
  const [provider, request] = getRequest(base);
  const getDescendantValues = getDescendantValuesFromOldRpc(request);
  const preOpId = /* @__PURE__ */ new Map();
  const onGoing = /* @__PURE__ */ new Map();
  const { send: originalSend, disconnect } = provider((msg) => {
    if ("id" in msg) {
      const opIdCb = preOpId.get(msg.id);
      if (opIdCb) {
        preOpId.delete(msg.id);
        if (msg.result.result === "started") opIdCb(msg.result.operationId);
      }
    } else if (msg.params) {
      const { subscription, result } = msg.params;
      const { operationId } = result || {};
      const operations = onGoing.get(subscription);
      if (operations && result.event === "stop") {
        operations.forEach((x) => {
          x.cancel();
        });
        onGoing.delete(subscription);
      }
      const operation = operations?.get(operationId);
      if (operation) {
        switch (result.event) {
          case "operationInaccessible":
          case "operationError":
            operation.cancel();
            break;
          case "operationStorageDone": {
            if (operation.isInnerDone) {
              operations.delete(operationId);
            } else {
              operation.isOutterDone = true;
              return;
            }
          }
        }
      }
    }
    onMsg(msg);
  });
  const getStartDescendantValues = (subscription, blockHash, keys) => (operationId) => {
    let _cancel = () => {
    };
    if (!onGoing.has(subscription)) {
      onGoing.set(subscription, /* @__PURE__ */ new Map());
    }
    const operationsMap = onGoing.get(subscription);
    const state = {
      isOutterDone: false,
      isInnerDone: false,
      cancel: () => {
        _cancel();
      }
    };
    operationsMap.set(operationId, state);
    let nFinished = 0;
    const stoppers = keys.map(
      (key) => getDescendantValues(
        key,
        blockHash,
        (values) => {
          onMsg(
            operationNotification(
              subscription,
              "operationStorageItems",
              operationId,
              { items: values.map(([key2, value]) => ({ key: key2, value })) }
            )
          );
        },
        (error) => {
          _cancel();
          if (!state.isOutterDone) {
            originalSend(
              jsonObj({
                method: "chainHead_v1_stopOperation",
                params: [operationId]
              })
            );
          }
          onMsg(
            operationNotification(
              subscription,
              "operationError",
              operationId,
              {
                error: typeof error === "string" ? error : JSON.stringify(error)
              }
            )
          );
        },
        () => {
          if (++nFinished === keys.length) {
            if (state.isOutterDone) {
              _cancel();
              onMsg(
                operationNotification(
                  subscription,
                  "operationStorageDone",
                  operationId
                )
              );
            } else state.isInnerDone = true;
          }
        }
      )
    );
    _cancel = () => {
      operationsMap.delete(operationId);
      stoppers.forEach((cb) => cb());
    };
  };
  const send = (msg) => {
    switch (msg.method) {
      case chainHead.storage: {
        const [followSub, blockHash, items] = msg.params;
        const descendantsValuesKeys = [];
        const actualItems = items.filter((x) => {
          const isDescendantsValues = x.type === "descendantsValues";
          if (isDescendantsValues) descendantsValuesKeys.push(x.key);
          return !isDescendantsValues;
        });
        const startGetDescendantValues = getStartDescendantValues(
          followSub,
          blockHash,
          descendantsValuesKeys
        );
        if (!actualItems.length) {
          const operationId = operationPrefix + nextOperationId++;
          onMsg(
            jsonObj({
              id: msg.id,
              result: { result: "started", operationId }
            })
          );
          startGetDescendantValues(operationId);
          onGoing.get(followSub).get(operationId).isOutterDone = true;
          return;
        } else if (descendantsValuesKeys.length) {
          preOpId.set(msg.id, startGetDescendantValues);
        }
        msg.params[2] = actualItems;
        break;
      }
      case chainHead.stopOperation: {
        const [followSubscription, operationId] = msg.params;
        const data = onGoing.get(followSubscription)?.get(operationId);
        if (data) {
          data.cancel();
          if (data.isOutterDone) return;
        }
        break;
      }
      case chainHead.unfollow: {
        const [followSubscription] = msg.params;
        onGoing.get(followSubscription)?.forEach((x) => x.cancel());
        onGoing.delete(followSubscription);
        break;
      }
    }
    originalSend(msg);
  };
  return {
    send,
    disconnect
  };
};
const getDescendantValuesFromOldRpc = (request) => (rootKey, at, onValues, onError, onDone) => {
  let isRunning = true;
  let areAllKeysDone = false;
  let onGoingValues = 0;
  const _onError = (e) => {
    if (isRunning) {
      isRunning = false;
      onError(e);
    }
  };
  const PAGE_SIZE = 1e3;
  const pullKeys = (startAtKey) => {
    request(
      "state_getKeysPaged",
      [rootKey, PAGE_SIZE, startAtKey || void 0, at],
      (result) => {
        if (isRunning) {
          if (result.length > 0) {
            onGoingValues++;
            request(
              "state_queryStorageAt",
              [result, at],
              ([{ changes }]) => {
                if (isRunning) {
                  onGoingValues--;
                  onValues(changes);
                  if (areAllKeysDone && !onGoingValues) onDone();
                }
              },
              _onError
            );
          }
          if (result.length < PAGE_SIZE) {
            areAllKeysDone = true;
            if (!onGoingValues) onDone();
          } else pullKeys(result.at(-1));
        }
      },
      _onError
    );
  };
  pullKeys();
  return () => {
    isRunning = false;
  };
};

const fixUnorderedBlocks = (base) => (onMsg) => {
  const pendingChainHeadSubs = /* @__PURE__ */ new Set();
  const pinnedBlocksInSub = /* @__PURE__ */ new Map();
  const uknownBlocksNotifications = /* @__PURE__ */ new Map();
  const { send: originalSend, disconnect } = base((message) => {
    if ("id" in message) {
      onMsg(message);
      const { id, result } = message;
      if (pendingChainHeadSubs.has(id)) {
        pendingChainHeadSubs.delete(id);
        pinnedBlocksInSub.set(result, /* @__PURE__ */ new Set());
        uknownBlocksNotifications.set(result, /* @__PURE__ */ new Map());
        return;
      }
    } else {
      const { subscription } = message.params;
      const pinnedBlocks = pinnedBlocksInSub.get(subscription);
      const premature = uknownBlocksNotifications.get(subscription);
      if (pinnedBlocks) {
        const result = message.params.result;
        const { event } = result;
        if (event === "initialized") {
          result.finalizedBlockHashes.forEach((hash) => {
            pinnedBlocks.add(hash);
          });
        }
        if (event === "finalized") {
          result.prunedBlockHashes = result.prunedBlockHashes.filter(
            (x) => pinnedBlocks.has(x)
          );
        }
        if (event === "newBlock") {
          pinnedBlocks.add(result.blockHash);
          const hash = result.blockHash;
          const missing = premature.get(hash);
          if (missing) {
            premature.delete(hash);
            onMsg(message);
            Promise.resolve().then(() => {
              onMsg(missing);
            });
            return;
          }
        }
        if (event === "bestBlockChanged") {
          const hash = result.bestBlockHash;
          if (!pinnedBlocks.has(hash)) {
            uknownBlocksNotifications.get(subscription).set(hash, message);
            return;
          }
        }
        if (event === "stop") {
          pinnedBlocks.delete(subscription);
          uknownBlocksNotifications.delete(subscription);
        }
      }
      onMsg(message);
    }
  });
  const send = (msg) => {
    const subId = msg.params[0];
    switch (msg.method) {
      case chainHead.follow:
        pendingChainHeadSubs.add(msg.id);
        break;
      case chainHead.unpin:
        const [subscription, blocks] = msg.params;
        blocks.forEach((block) => {
          pinnedBlocksInSub.get(subscription)?.delete(block);
          uknownBlocksNotifications.get(subscription)?.delete(block);
        });
        break;
      case chainHead.unfollow:
        pinnedBlocksInSub.delete(subId);
        uknownBlocksNotifications.delete(subId);
        break;
    }
    originalSend(msg);
  };
  return {
    send,
    disconnect
  };
};

const terminalOperationEvents = new Set(
  ["BodyDone", "CallDone", "StorageDone", "Inaccessible", "Error"].map(
    (x) => "operation" + x
  )
);
const isTerminalNotification = (msg) => terminalOperationEvents.has(msg.params?.result?.event);
const fixUnorderedEvents = (base) => (onMsg) => {
  const pendingChainHeadSubs = /* @__PURE__ */ new Set();
  const pendingOperationIds = /* @__PURE__ */ new Map();
  const activeOperationIds = /* @__PURE__ */ new Map();
  const uknownOperationNotifications = /* @__PURE__ */ new Map();
  const { send: originalSend, disconnect } = base((message) => {
    if ("id" in message) {
      onMsg(message);
      const { id, result } = message;
      if (pendingChainHeadSubs.has(id)) {
        pendingChainHeadSubs.delete(id);
        activeOperationIds.set(result, /* @__PURE__ */ new Set());
        uknownOperationNotifications.set(result, /* @__PURE__ */ new Map());
        return;
      }
      const subId = pendingOperationIds.get(id);
      if (subId !== void 0) {
        pendingOperationIds.delete(id);
        const opId = message.result?.operationId;
        if (opId !== void 0 && activeOperationIds.has(subId)) {
          const subOperations = activeOperationIds.get(subId);
          subOperations.add(opId);
          const pendingNotifications = uknownOperationNotifications.get(subId)?.get(opId);
          if (pendingNotifications) {
            pendingNotifications.forEach(onMsg);
            uknownOperationNotifications.get(subId).delete(opId);
            if (isTerminalNotification(pendingNotifications.at(-1)))
              subOperations.delete(opId);
          }
        }
      }
    } else {
      const { subscription, result } = message.params;
      const operationIds = activeOperationIds.get(subscription);
      if (operationIds) {
        const { operationId } = message.params.result;
        if (operationId !== void 0) {
          if (!operationIds.has(operationId)) {
            const subscriptionPending = uknownOperationNotifications.get(subscription);
            const pendingMessages = subscriptionPending.get(operationId) ?? [];
            pendingMessages.push(message);
            subscriptionPending.set(operationId, pendingMessages);
            return;
          } else if (isTerminalNotification(message))
            operationIds.delete(operationId);
        } else if (result?.event === "stop") {
          activeOperationIds.delete(subscription);
          uknownOperationNotifications.delete(subscription);
        }
      }
      onMsg(message);
    }
  });
  const send = (msg) => {
    const subId = msg.params[0];
    switch (msg.method) {
      case chainHead.follow:
        pendingChainHeadSubs.add(msg.id);
        break;
      case chainHead.body:
      case chainHead.call:
      case chainHead.storage:
        pendingOperationIds.set(msg.id, subId);
        break;
      case chainHead.unfollow:
        activeOperationIds.delete(subId);
        uknownOperationNotifications.delete(subId);
        break;
      case chainHead.stopOperation:
        activeOperationIds.get(subId)?.delete(msg.params[1]);
    }
    originalSend(msg);
  };
  return {
    send,
    disconnect
  };
};

const patchChainHeadEvents = (base) => (onMsg) => base((message) => {
  const result = message.params?.result;
  if (!("id" in message) && result) {
    const { prunedBlockHashes, finalizedBlockHash, event } = result;
    if (event === "finalized" && Array.isArray(prunedBlockHashes))
      result.prunedBlockHashes = [...new Set(result.prunedBlockHashes)];
    else if (event === "initialized" && finalizedBlockHash) {
      result.finalizedBlockHashes = [result.finalizedBlockHash];
      delete result.finalizedBlockHash;
    }
  }
  onMsg(message);
});

const unpinHash = (base) => (onMsg) => {
  const { send: _send, disconnect } = base(onMsg);
  const send = (msg) => {
    const { method, params, id, ...rest } = msg;
    if (method == chainHead.unpin && params && Array.isArray(params[1])) {
      params[1].forEach((hash, idx) => {
        _send({
          ...rest,
          id: idx === 0 ? id : `${id}-patched-${idx}`,
          method,
          params: [params[0], hash]
        });
      });
    } else _send(msg);
  };
  return { send, disconnect };
};

const jsonRpcMsg = (msg) => ({
  jsonrpc: "2.0",
  ...msg
});
const [transactionGroup] = transaction.stop.split("_");
const unstable = "unstable";
const rpcMethods = "rpc_methods";
const RPC_METHODS_ID = "__INTERNAL_ID";
const translate = (base) => {
  return (originalOnMsg) => {
    let isRunning = true;
    let bufferedMsgs = [];
    let _send = (msg) => {
      bufferedMsgs.push(msg);
    };
    const preOnMsg = ({
      id,
      result,
      error
    }) => {
      if (id !== RPC_METHODS_ID || !isRunning) return;
      if (!result) {
        console.error(error);
        if (nTries < 4) {
          setTimeout(sendMethodsRequest, 200);
          return;
        }
        result = { methods: [] };
      }
      const methodsSet = new Set(result.methods);
      const methodMappings = {};
      [chainHead, chainSpec, transaction].forEach((obj) => {
        Object.values(obj).forEach((method) => {
          if (methodsSet.has(method)) {
            methodMappings[method] = method;
          } else {
            const [group, , name] = method.split("_");
            const unstableMethod = `${group}_${unstable}_${name}`;
            if (methodsSet.has(unstableMethod)) {
              methodMappings[method] = unstableMethod;
              methodsSet.delete(unstableMethod);
              methodsSet.add(method);
            } else {
              methodMappings[method] = null;
              if (group === transactionGroup) {
                let matchedMethod;
                const translatedMethod = method === "stop" ? "unwatch" : "submitAndWatch";
                const txGroup = [
                  transactionGroup + "Watch",
                  transactionGroup
                ].find(
                  (group2) => ["v1", unstable].find(
                    (v) => methodsSet.has(
                      matchedMethod = `${group2}_${v}_${translatedMethod}`
                    )
                  )
                );
                if (txGroup) {
                  methodMappings[method] = matchedMethod;
                  methodsSet.add(method);
                }
              }
            }
          }
        });
      });
      _onMsg = originalOnMsg;
      const enhancedSend = ({
        method,
        ...rest
      }) => {
        if (method === rpcMethods) {
          Promise.resolve().then(() => {
            originalOnMsg(
              jsonRpcMsg({
                id: rest.id,
                result: { methods: [...methodsSet] }
              })
            );
          });
          return;
        }
        const mapping = methodMappings[method];
        if (mapping === null) {
          if (method.split("_")[2] === "follow") {
            reset();
            _send({ method, ...rest });
          } else {
            Promise.resolve().then(() => {
              originalOnMsg({
                error: { code: -32603, message: `Method not found: ${method}` },
                id: rest.id
              });
            });
          }
        } else
          originalSend({
            method: mapping || method,
            ...rest
          });
      };
      const bufferCopy = [...bufferedMsgs];
      bufferedMsgs = [];
      for (let i = 0; isRunning && i < bufferCopy.length; i++)
        enhancedSend(bufferCopy[i]);
      if (isRunning) _send = enhancedSend;
    };
    let _onMsg = preOnMsg;
    const { send: originalSend, disconnect } = base((msg) => {
      _onMsg(msg);
    });
    const reset = () => {
      isRunning = true;
      bufferedMsgs = [];
      _send = (msg) => {
        bufferedMsgs.push(msg);
      };
      _onMsg = preOnMsg;
      sendMethodsRequest();
    };
    let nTries = 0;
    const sendMethodsRequest = () => {
      nTries++;
      originalSend(
        jsonRpcMsg({
          id: RPC_METHODS_ID,
          method: rpcMethods,
          params: []
        })
      );
    };
    sendMethodsRequest();
    return {
      send: (msg) => {
        _send(msg);
      },
      disconnect() {
        isRunning = false;
        _send = _onMsg = () => {
        };
        bufferedMsgs = [];
        disconnect();
      }
    };
  };
};

const withNumericIds = (base) => (onMsg) => {
  let nextId = 0;
  const numberToOriginal = /* @__PURE__ */ new Map();
  const { send: originalSend, disconnect } = base((message) => {
    if (numberToOriginal.has(message.id))
      message.id = numberToOriginal.get(message.id);
    onMsg(message);
  });
  return {
    send: (msg) => {
      if ("id" in msg) {
        const id = nextId++;
        numberToOriginal.set(id, msg.id);
        msg.id = id;
      }
      originalSend(msg);
    },
    disconnect
  };
};

const withPolkadotSdkCompat = parsed(
  withNumericIds,
  translate,
  fixUnorderedEvents,
  unpinHash,
  patchChainHeadEvents,
  fixPrematureBlocks,
  fixUnorderedBlocks,
  fixChainSpec,
  fixDescendantValues
);

exports.fixDescendantValues = fixDescendantValues;
exports.fixPrematureBlocks = fixPrematureBlocks;
exports.fixUnorderedBlocks = fixUnorderedBlocks;
exports.fixUnorderedEvents = fixUnorderedEvents;
exports.fromParsed = fromParsed;
exports.methods = methods;
exports.parsed = parsed;
exports.patchChainHeadEvents = patchChainHeadEvents;
exports.toParsed = toParsed;
exports.translate = translate;
exports.unpinHash = unpinHash;
exports.withNumericIds = withNumericIds;
exports.withPolkadotSdkCompat = withPolkadotSdkCompat;
//# sourceMappingURL=index.js.map
