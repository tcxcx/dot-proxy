import { chainHead } from '../methods.mjs';
import { getRequest, jsonObj, operationNotification } from '../utils.mjs';

const operationPrefix = "__INNER_OP_DesV";
let nextOperationId = 0;
const fixDescendantValues = (base) => (onMsg) => {
  const [provider, request] = getRequest(base);
  const getDescendantValues = getDescendantValuesFromOldRpc(request);
  const preOpId = /* @__PURE__ */ new Map();
  const onGoing = /* @__PURE__ */ new Map();
  const { send: originalSend, disconnect } = provider((msg) => {
    if ("id" in msg) {
      const opIdCb = preOpId.get(msg.id);
      if (opIdCb) {
        preOpId.delete(msg.id);
        if (msg.result.result === "started") opIdCb(msg.result.operationId);
      }
    } else if (msg.params) {
      const { subscription, result } = msg.params;
      const { operationId } = result || {};
      const operations = onGoing.get(subscription);
      if (operations && result.event === "stop") {
        operations.forEach((x) => {
          x.cancel();
        });
        onGoing.delete(subscription);
      }
      const operation = operations?.get(operationId);
      if (operation) {
        switch (result.event) {
          case "operationInaccessible":
          case "operationError":
            operation.cancel();
            break;
          case "operationStorageDone": {
            if (operation.isInnerDone) {
              operations.delete(operationId);
            } else {
              operation.isOutterDone = true;
              return;
            }
          }
        }
      }
    }
    onMsg(msg);
  });
  const getStartDescendantValues = (subscription, blockHash, keys) => (operationId) => {
    let _cancel = () => {
    };
    if (!onGoing.has(subscription)) {
      onGoing.set(subscription, /* @__PURE__ */ new Map());
    }
    const operationsMap = onGoing.get(subscription);
    const state = {
      isOutterDone: false,
      isInnerDone: false,
      cancel: () => {
        _cancel();
      }
    };
    operationsMap.set(operationId, state);
    let nFinished = 0;
    const stoppers = keys.map(
      (key) => getDescendantValues(
        key,
        blockHash,
        (values) => {
          onMsg(
            operationNotification(
              subscription,
              "operationStorageItems",
              operationId,
              { items: values.map(([key2, value]) => ({ key: key2, value })) }
            )
          );
        },
        (error) => {
          _cancel();
          if (!state.isOutterDone) {
            originalSend(
              jsonObj({
                method: "chainHead_v1_stopOperation",
                params: [operationId]
              })
            );
          }
          onMsg(
            operationNotification(
              subscription,
              "operationError",
              operationId,
              {
                error: typeof error === "string" ? error : JSON.stringify(error)
              }
            )
          );
        },
        () => {
          if (++nFinished === keys.length) {
            if (state.isOutterDone) {
              _cancel();
              onMsg(
                operationNotification(
                  subscription,
                  "operationStorageDone",
                  operationId
                )
              );
            } else state.isInnerDone = true;
          }
        }
      )
    );
    _cancel = () => {
      operationsMap.delete(operationId);
      stoppers.forEach((cb) => cb());
    };
  };
  const send = (msg) => {
    switch (msg.method) {
      case chainHead.storage: {
        const [followSub, blockHash, items] = msg.params;
        const descendantsValuesKeys = [];
        const actualItems = items.filter((x) => {
          const isDescendantsValues = x.type === "descendantsValues";
          if (isDescendantsValues) descendantsValuesKeys.push(x.key);
          return !isDescendantsValues;
        });
        const startGetDescendantValues = getStartDescendantValues(
          followSub,
          blockHash,
          descendantsValuesKeys
        );
        if (!actualItems.length) {
          const operationId = operationPrefix + nextOperationId++;
          onMsg(
            jsonObj({
              id: msg.id,
              result: { result: "started", operationId }
            })
          );
          startGetDescendantValues(operationId);
          onGoing.get(followSub).get(operationId).isOutterDone = true;
          return;
        } else if (descendantsValuesKeys.length) {
          preOpId.set(msg.id, startGetDescendantValues);
        }
        msg.params[2] = actualItems;
        break;
      }
      case chainHead.stopOperation: {
        const [followSubscription, operationId] = msg.params;
        const data = onGoing.get(followSubscription)?.get(operationId);
        if (data) {
          data.cancel();
          if (data.isOutterDone) return;
        }
        break;
      }
      case chainHead.unfollow: {
        const [followSubscription] = msg.params;
        onGoing.get(followSubscription)?.forEach((x) => x.cancel());
        onGoing.delete(followSubscription);
        break;
      }
    }
    originalSend(msg);
  };
  return {
    send,
    disconnect
  };
};
const getDescendantValuesFromOldRpc = (request) => (rootKey, at, onValues, onError, onDone) => {
  let isRunning = true;
  let areAllKeysDone = false;
  let onGoingValues = 0;
  const _onError = (e) => {
    if (isRunning) {
      isRunning = false;
      onError(e);
    }
  };
  const PAGE_SIZE = 1e3;
  const pullKeys = (startAtKey) => {
    request(
      "state_getKeysPaged",
      [rootKey, PAGE_SIZE, startAtKey || void 0, at],
      (result) => {
        if (isRunning) {
          if (result.length > 0) {
            onGoingValues++;
            request(
              "state_queryStorageAt",
              [result, at],
              ([{ changes }]) => {
                if (isRunning) {
                  onGoingValues--;
                  onValues(changes);
                  if (areAllKeysDone && !onGoingValues) onDone();
                }
              },
              _onError
            );
          }
          if (result.length < PAGE_SIZE) {
            areAllKeysDone = true;
            if (!onGoingValues) onDone();
          } else pullKeys(result.at(-1));
        }
      },
      _onError
    );
  };
  pullKeys();
  return () => {
    isRunning = false;
  };
};

export { fixDescendantValues };
//# sourceMappingURL=fix-descendant-values.mjs.map
