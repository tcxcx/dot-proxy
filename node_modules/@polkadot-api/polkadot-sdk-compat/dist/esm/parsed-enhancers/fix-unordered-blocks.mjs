import { chainHead } from '../methods.mjs';

const fixUnorderedBlocks = (base) => (onMsg) => {
  const pendingChainHeadSubs = /* @__PURE__ */ new Set();
  const pinnedBlocksInSub = /* @__PURE__ */ new Map();
  const uknownBlocksNotifications = /* @__PURE__ */ new Map();
  const { send: originalSend, disconnect } = base((message) => {
    if ("id" in message) {
      onMsg(message);
      const { id, result } = message;
      if (pendingChainHeadSubs.has(id)) {
        pendingChainHeadSubs.delete(id);
        pinnedBlocksInSub.set(result, /* @__PURE__ */ new Set());
        uknownBlocksNotifications.set(result, /* @__PURE__ */ new Map());
        return;
      }
    } else {
      const { subscription } = message.params;
      const pinnedBlocks = pinnedBlocksInSub.get(subscription);
      const premature = uknownBlocksNotifications.get(subscription);
      if (pinnedBlocks) {
        const result = message.params.result;
        const { event } = result;
        if (event === "initialized") {
          result.finalizedBlockHashes.forEach((hash) => {
            pinnedBlocks.add(hash);
          });
        }
        if (event === "finalized") {
          result.prunedBlockHashes = result.prunedBlockHashes.filter(
            (x) => pinnedBlocks.has(x)
          );
        }
        if (event === "newBlock") {
          pinnedBlocks.add(result.blockHash);
          const hash = result.blockHash;
          const missing = premature.get(hash);
          if (missing) {
            premature.delete(hash);
            onMsg(message);
            Promise.resolve().then(() => {
              onMsg(missing);
            });
            return;
          }
        }
        if (event === "bestBlockChanged") {
          const hash = result.bestBlockHash;
          if (!pinnedBlocks.has(hash)) {
            uknownBlocksNotifications.get(subscription).set(hash, message);
            return;
          }
        }
        if (event === "stop") {
          pinnedBlocks.delete(subscription);
          uknownBlocksNotifications.delete(subscription);
        }
      }
      onMsg(message);
    }
  });
  const send = (msg) => {
    const subId = msg.params[0];
    switch (msg.method) {
      case chainHead.follow:
        pendingChainHeadSubs.add(msg.id);
        break;
      case chainHead.unpin:
        const [subscription, blocks] = msg.params;
        blocks.forEach((block) => {
          pinnedBlocksInSub.get(subscription)?.delete(block);
          uknownBlocksNotifications.get(subscription)?.delete(block);
        });
        break;
      case chainHead.unfollow:
        pinnedBlocksInSub.delete(subId);
        uknownBlocksNotifications.delete(subId);
        break;
    }
    originalSend(msg);
  };
  return {
    send,
    disconnect
  };
};

export { fixUnorderedBlocks };
//# sourceMappingURL=fix-unordered-blocks.mjs.map
