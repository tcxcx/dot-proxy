import { chainHead } from '../methods.mjs';

const fixPrematureBlocks = (base) => (onMsg) => {
  const pendingChainHeadSubs = /* @__PURE__ */ new Set();
  const pinnedBlocksInSub = /* @__PURE__ */ new Map();
  const prematureBlocks = /* @__PURE__ */ new Map();
  const { send: originalSend, disconnect } = base((message) => {
    if ("id" in message) {
      onMsg(message);
      const { id, result } = message;
      if (pendingChainHeadSubs.has(id)) {
        pendingChainHeadSubs.delete(id);
        pinnedBlocksInSub.set(result, /* @__PURE__ */ new Set());
        prematureBlocks.set(result, /* @__PURE__ */ new Map());
        return;
      }
    } else {
      const { subscription } = message.params;
      const pinnedBlocks = pinnedBlocksInSub.get(subscription);
      const prematureSub = prematureBlocks.get(subscription);
      if (pinnedBlocks) {
        const result = message.params.result;
        const { event } = result;
        if (event === "initialized") {
          result.finalizedBlockHashes.forEach((hash) => {
            pinnedBlocks.add(hash);
          });
        }
        if (event === "newBlock") {
          const { parentBlockHash } = result;
          if (!pinnedBlocks.has(parentBlockHash)) {
            const list = prematureSub.get(parentBlockHash) ?? [];
            list.push(message);
            prematureSub.set(parentBlockHash, list);
            return;
          }
          const hash = result.blockHash;
          pinnedBlocks.add(result.blockHash);
          onMsg(message);
          const prematureMessages = prematureSub.get(hash);
          if (prematureMessages) {
            prematureSub.delete(hash);
            prematureMessages.forEach((msg) => {
              pinnedBlocks.add(msg.params.result.blockHash);
              onMsg(msg);
            });
          }
          return;
        }
        if (event === "stop") {
          pinnedBlocks.delete(subscription);
          prematureBlocks.delete(subscription);
        }
      }
      onMsg(message);
    }
  });
  const send = (msg) => {
    const subId = msg.params[0];
    switch (msg.method) {
      case chainHead.follow:
        pendingChainHeadSubs.add(msg.id);
        break;
      case chainHead.unpin:
        const [subscription, blocks] = msg.params;
        blocks.forEach((block) => {
          pinnedBlocksInSub.get(subscription)?.delete(block);
          prematureBlocks.get(subscription)?.delete(block);
        });
        break;
      case chainHead.unfollow:
        pinnedBlocksInSub.delete(subId);
        prematureBlocks.delete(subId);
        break;
    }
    originalSend(msg);
  };
  return {
    send,
    disconnect
  };
};

export { fixPrematureBlocks };
//# sourceMappingURL=fix-premature-blocks.mjs.map
