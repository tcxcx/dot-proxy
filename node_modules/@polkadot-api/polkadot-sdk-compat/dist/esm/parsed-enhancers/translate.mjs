import { transaction, chainHead, chainSpec } from '../methods.mjs';

const jsonRpcMsg = (msg) => ({
  jsonrpc: "2.0",
  ...msg
});
const [transactionGroup] = transaction.stop.split("_");
const unstable = "unstable";
const rpcMethods = "rpc_methods";
const RPC_METHODS_ID = "__INTERNAL_ID";
const translate = (base) => {
  return (originalOnMsg) => {
    let isRunning = true;
    let bufferedMsgs = [];
    let _send = (msg) => {
      bufferedMsgs.push(msg);
    };
    const preOnMsg = ({
      id,
      result,
      error
    }) => {
      if (id !== RPC_METHODS_ID || !isRunning) return;
      if (!result) {
        console.error(error);
        if (nTries < 4) {
          setTimeout(sendMethodsRequest, 200);
          return;
        }
        result = { methods: [] };
      }
      const methodsSet = new Set(result.methods);
      const methodMappings = {};
      [chainHead, chainSpec, transaction].forEach((obj) => {
        Object.values(obj).forEach((method) => {
          if (methodsSet.has(method)) {
            methodMappings[method] = method;
          } else {
            const [group, , name] = method.split("_");
            const unstableMethod = `${group}_${unstable}_${name}`;
            if (methodsSet.has(unstableMethod)) {
              methodMappings[method] = unstableMethod;
              methodsSet.delete(unstableMethod);
              methodsSet.add(method);
            } else {
              methodMappings[method] = null;
              if (group === transactionGroup) {
                let matchedMethod;
                const translatedMethod = method === "stop" ? "unwatch" : "submitAndWatch";
                const txGroup = [
                  transactionGroup + "Watch",
                  transactionGroup
                ].find(
                  (group2) => ["v1", unstable].find(
                    (v) => methodsSet.has(
                      matchedMethod = `${group2}_${v}_${translatedMethod}`
                    )
                  )
                );
                if (txGroup) {
                  methodMappings[method] = matchedMethod;
                  methodsSet.add(method);
                }
              }
            }
          }
        });
      });
      _onMsg = originalOnMsg;
      const enhancedSend = ({
        method,
        ...rest
      }) => {
        if (method === rpcMethods) {
          Promise.resolve().then(() => {
            originalOnMsg(
              jsonRpcMsg({
                id: rest.id,
                result: { methods: [...methodsSet] }
              })
            );
          });
          return;
        }
        const mapping = methodMappings[method];
        if (mapping === null) {
          if (method.split("_")[2] === "follow") {
            reset();
            _send({ method, ...rest });
          } else {
            Promise.resolve().then(() => {
              originalOnMsg({
                error: { code: -32603, message: `Method not found: ${method}` },
                id: rest.id
              });
            });
          }
        } else
          originalSend({
            method: mapping || method,
            ...rest
          });
      };
      const bufferCopy = [...bufferedMsgs];
      bufferedMsgs = [];
      for (let i = 0; isRunning && i < bufferCopy.length; i++)
        enhancedSend(bufferCopy[i]);
      if (isRunning) _send = enhancedSend;
    };
    let _onMsg = preOnMsg;
    const { send: originalSend, disconnect } = base((msg) => {
      _onMsg(msg);
    });
    const reset = () => {
      isRunning = true;
      bufferedMsgs = [];
      _send = (msg) => {
        bufferedMsgs.push(msg);
      };
      _onMsg = preOnMsg;
      sendMethodsRequest();
    };
    let nTries = 0;
    const sendMethodsRequest = () => {
      nTries++;
      originalSend(
        jsonRpcMsg({
          id: RPC_METHODS_ID,
          method: rpcMethods,
          params: []
        })
      );
    };
    sendMethodsRequest();
    return {
      send: (msg) => {
        _send(msg);
      },
      disconnect() {
        isRunning = false;
        _send = _onMsg = () => {
        };
        bufferedMsgs = [];
        disconnect();
      }
    };
  };
};

export { translate };
//# sourceMappingURL=translate.mjs.map
