import { chainHead } from '../methods.mjs';

const terminalOperationEvents = new Set(
  ["BodyDone", "CallDone", "StorageDone", "Inaccessible", "Error"].map(
    (x) => "operation" + x
  )
);
const isTerminalNotification = (msg) => terminalOperationEvents.has(msg.params?.result?.event);
const fixUnorderedEvents = (base) => (onMsg) => {
  const pendingChainHeadSubs = /* @__PURE__ */ new Set();
  const pendingOperationIds = /* @__PURE__ */ new Map();
  const activeOperationIds = /* @__PURE__ */ new Map();
  const uknownOperationNotifications = /* @__PURE__ */ new Map();
  const { send: originalSend, disconnect } = base((message) => {
    if ("id" in message) {
      onMsg(message);
      const { id, result } = message;
      if (pendingChainHeadSubs.has(id)) {
        pendingChainHeadSubs.delete(id);
        activeOperationIds.set(result, /* @__PURE__ */ new Set());
        uknownOperationNotifications.set(result, /* @__PURE__ */ new Map());
        return;
      }
      const subId = pendingOperationIds.get(id);
      if (subId !== void 0) {
        pendingOperationIds.delete(id);
        const opId = message.result?.operationId;
        if (opId !== void 0 && activeOperationIds.has(subId)) {
          const subOperations = activeOperationIds.get(subId);
          subOperations.add(opId);
          const pendingNotifications = uknownOperationNotifications.get(subId)?.get(opId);
          if (pendingNotifications) {
            pendingNotifications.forEach(onMsg);
            uknownOperationNotifications.get(subId).delete(opId);
            if (isTerminalNotification(pendingNotifications.at(-1)))
              subOperations.delete(opId);
          }
        }
      }
    } else {
      const { subscription, result } = message.params;
      const operationIds = activeOperationIds.get(subscription);
      if (operationIds) {
        const { operationId } = message.params.result;
        if (operationId !== void 0) {
          if (!operationIds.has(operationId)) {
            const subscriptionPending = uknownOperationNotifications.get(subscription);
            const pendingMessages = subscriptionPending.get(operationId) ?? [];
            pendingMessages.push(message);
            subscriptionPending.set(operationId, pendingMessages);
            return;
          } else if (isTerminalNotification(message))
            operationIds.delete(operationId);
        } else if (result?.event === "stop") {
          activeOperationIds.delete(subscription);
          uknownOperationNotifications.delete(subscription);
        }
      }
      onMsg(message);
    }
  });
  const send = (msg) => {
    const subId = msg.params[0];
    switch (msg.method) {
      case chainHead.follow:
        pendingChainHeadSubs.add(msg.id);
        break;
      case chainHead.body:
      case chainHead.call:
      case chainHead.storage:
        pendingOperationIds.set(msg.id, subId);
        break;
      case chainHead.unfollow:
        activeOperationIds.delete(subId);
        uknownOperationNotifications.delete(subId);
        break;
      case chainHead.stopOperation:
        activeOperationIds.get(subId)?.delete(msg.params[1]);
    }
    originalSend(msg);
  };
  return {
    send,
    disconnect
  };
};

export { fixUnorderedEvents };
//# sourceMappingURL=fix-unordered-events.mjs.map
