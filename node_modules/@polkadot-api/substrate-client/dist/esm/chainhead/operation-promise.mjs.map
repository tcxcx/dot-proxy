{"version":3,"file":"operation-promise.mjs","sources":["../../../src/chainhead/operation-promise.ts"],"sourcesContent":["import { abortablePromiseFn, noop } from \"@/internal-utils\"\nimport {\n  CommonOperationEventsRpc,\n  OperationResponseRpc,\n} from \"./json-rpc-types\"\nimport {\n  OperationError,\n  OperationInaccessibleError,\n  OperationLimitError,\n} from \"./errors\"\nimport { ClientInnerRequest } from \"./public-types\"\nimport { chainHead } from \"@/methods\"\n\nexport const createOperationPromise =\n  <I extends { operationId: string; event: string }, O, A extends Array<any>>(\n    operationName: string,\n    factory: (\n      ...args: A\n    ) => [\n      Array<any>,\n      (e: I, res: (x: O) => void, rej: (e: Error) => void) => void,\n    ],\n  ) =>\n  (\n    request: ClientInnerRequest<\n      OperationResponseRpc,\n      I | CommonOperationEventsRpc\n    >,\n  ) =>\n    abortablePromiseFn<O, A>((res, rej, ...args) => {\n      let isRunning = true\n      let cancel = () => {\n        isRunning = false\n      }\n\n      const [requestArgs, logicCb] = factory(...args)\n      request(operationName, requestArgs, {\n        onSuccess: (response, followSubscription) => {\n          if (response.result === \"limitReached\")\n            return rej(new OperationLimitError())\n\n          const { operationId } = response\n          const stopOperation = () => {\n            request(chainHead.stopOperation, [operationId])\n          }\n\n          if (!isRunning) return stopOperation()\n\n          let done = noop\n          const _res = (x: O) => {\n            isRunning = false\n            done()\n            res(x)\n          }\n          const _rej = (x: Error) => {\n            isRunning = false\n            done()\n            rej(x)\n          }\n\n          done = followSubscription(operationId, {\n            next: (e) => {\n              const _e = e as CommonOperationEventsRpc\n              if (_e.event === \"operationError\")\n                rej(new OperationError(_e.error))\n              else if (_e.event === \"operationInaccessible\")\n                rej(new OperationInaccessibleError())\n              else logicCb(e as I, _res, _rej)\n            },\n            error: _rej,\n          })\n\n          cancel = () => {\n            if (isRunning) {\n              done()\n              stopOperation()\n            }\n          }\n        },\n        onError: rej,\n      })\n\n      return () => {\n        cancel()\n      }\n    })\n"],"names":[],"mappings":";;;;;AAaa,MAAA,sBAAA,GACX,CACE,aAAA,EACA,OAOF,KAAA,CACE,YAKA,kBAAyB,CAAA,CAAC,GAAK,EAAA,GAAA,EAAA,GAAQ,IAAS,KAAA;AAC9C,EAAA,IAAI,SAAY,GAAA,IAAA;AAChB,EAAA,IAAI,SAAS,MAAM;AACjB,IAAY,SAAA,GAAA,KAAA;AAAA,GACd;AAEA,EAAA,MAAM,CAAC,WAAa,EAAA,OAAO,CAAI,GAAA,OAAA,CAAQ,GAAG,IAAI,CAAA;AAC9C,EAAA,OAAA,CAAQ,eAAe,WAAa,EAAA;AAAA,IAClC,SAAA,EAAW,CAAC,QAAA,EAAU,kBAAuB,KAAA;AAC3C,MAAA,IAAI,SAAS,MAAW,KAAA,cAAA;AACtB,QAAO,OAAA,GAAA,CAAI,IAAI,mBAAA,EAAqB,CAAA;AAEtC,MAAM,MAAA,EAAE,aAAgB,GAAA,QAAA;AACxB,MAAA,MAAM,gBAAgB,MAAM;AAC1B,QAAA,OAAA,CAAQ,SAAU,CAAA,aAAA,EAAe,CAAC,WAAW,CAAC,CAAA;AAAA,OAChD;AAEA,MAAI,IAAA,CAAC,SAAW,EAAA,OAAO,aAAc,EAAA;AAErC,MAAA,IAAI,IAAO,GAAA,IAAA;AACX,MAAM,MAAA,IAAA,GAAO,CAAC,CAAS,KAAA;AACrB,QAAY,SAAA,GAAA,KAAA;AACZ,QAAK,IAAA,EAAA;AACL,QAAA,GAAA,CAAI,CAAC,CAAA;AAAA,OACP;AACA,MAAM,MAAA,IAAA,GAAO,CAAC,CAAa,KAAA;AACzB,QAAY,SAAA,GAAA,KAAA;AACZ,QAAK,IAAA,EAAA;AACL,QAAA,GAAA,CAAI,CAAC,CAAA;AAAA,OACP;AAEA,MAAA,IAAA,GAAO,mBAAmB,WAAa,EAAA;AAAA,QACrC,IAAA,EAAM,CAAC,CAAM,KAAA;AACX,UAAA,MAAM,EAAK,GAAA,CAAA;AACX,UAAA,IAAI,GAAG,KAAU,KAAA,gBAAA;AACf,YAAA,GAAA,CAAI,IAAI,cAAA,CAAe,EAAG,CAAA,KAAK,CAAC,CAAA;AAAA,eAAA,IACzB,GAAG,KAAU,KAAA,uBAAA;AACpB,YAAI,GAAA,CAAA,IAAI,4BAA4B,CAAA;AAAA,eACjC,OAAA,CAAQ,CAAQ,EAAA,IAAA,EAAM,IAAI,CAAA;AAAA,SACjC;AAAA,QACA,KAAO,EAAA;AAAA,OACR,CAAA;AAED,MAAA,MAAA,GAAS,MAAM;AACb,QAAA,IAAI,SAAW,EAAA;AACb,UAAK,IAAA,EAAA;AACL,UAAc,aAAA,EAAA;AAAA;AAChB,OACF;AAAA,KACF;AAAA,IACA,OAAS,EAAA;AAAA,GACV,CAAA;AAED,EAAA,OAAO,MAAM;AACX,IAAO,MAAA,EAAA;AAAA,GACT;AACF,CAAC;;;;"}