{"version":3,"file":"createClient.mjs","sources":["../../../src/client/createClient.ts"],"sourcesContent":["import type {\n  JsonRpcConnection,\n  JsonRpcProvider,\n} from \"@polkadot-api/json-rpc-provider\"\nimport { UnsubscribeFn } from \"../common-types\"\nimport { RpcError, IRpcError } from \"./RpcError\"\nimport { getSubscriptionsManager, Subscriber } from \"@/internal-utils\"\nimport { DestroyedError } from \"./DestroyedError\"\n\nexport type FollowSubscriptionCb<T> = (\n  subscriptionId: string,\n  cb: Subscriber<T>,\n) => UnsubscribeFn\n\nexport type ClientRequestCb<T, TT> = {\n  onSuccess: (result: T, followSubscription: FollowSubscriptionCb<TT>) => void\n  onError: (e: Error) => void\n}\n\nexport type ClientRequest<T, TT> = (\n  method: string,\n  params: Array<any>,\n  cb?: ClientRequestCb<T, TT>,\n) => UnsubscribeFn\n\nexport interface Client {\n  disconnect: () => void\n  request: ClientRequest<any, any>\n}\n\nlet nextClientId = 1\nexport const createClient = (gProvider: JsonRpcProvider): Client => {\n  let clientId = nextClientId++\n  const responses = new Map<string, ClientRequestCb<any, any>>()\n  const subscriptions = getSubscriptionsManager()\n\n  let connection: JsonRpcConnection | null = null\n\n  const send = (\n    id: string,\n    method: string,\n    params: Array<boolean | string | number | null>,\n  ) => {\n    connection!.send(\n      JSON.stringify({\n        jsonrpc: \"2.0\",\n        id,\n        method,\n        params,\n      }),\n    )\n  }\n\n  function onMessage(message: string): void {\n    try {\n      let id: string,\n        result,\n        error: IRpcError | undefined,\n        params: { subscription: any; result: any; error?: IRpcError },\n        subscription: string\n\n      const parsed = JSON.parse(message)\n      ;({ id, result, error, params } = parsed)\n\n      if (id) {\n        const cb = responses.get(id)\n        if (!cb) return\n\n        responses.delete(id)\n\n        return error\n          ? cb.onError(new RpcError(error))\n          : cb.onSuccess(result, (opaqueId, subscriber) => {\n              const subscriptionId = opaqueId\n              subscriptions.subscribe(subscriptionId, subscriber)\n              return () => {\n                subscriptions.unsubscribe(subscriptionId)\n              }\n            })\n      }\n\n      // at this point, it means that it should be a notification\n      ;({ subscription, result, error } = params)\n      if (!subscription || (!error && !Object.hasOwn(params, \"result\"))) throw 0\n\n      const subscriptionId = subscription\n\n      if (error) {\n        subscriptions.error(subscriptionId, new RpcError(error!))\n      } else {\n        subscriptions.next(subscriptionId, result)\n      }\n    } catch (e) {\n      console.warn(\"Error parsing incomming message: \" + message)\n      console.error(e)\n    }\n  }\n  connection = gProvider(onMessage)\n\n  const disconnect = () => {\n    connection?.disconnect()\n    connection = null\n    subscriptions.errorAll(new DestroyedError())\n    responses.forEach((r) => r.onError(new DestroyedError()))\n    responses.clear()\n  }\n\n  let nextId = 1\n  const request = <T, TT>(\n    method: string,\n    params: Array<any>,\n    cb?: ClientRequestCb<T, TT>,\n  ): UnsubscribeFn => {\n    if (!connection) throw new Error(\"Not connected\")\n    const id = `${clientId}-${nextId++}`\n\n    if (cb) responses.set(id, cb)\n    send(id, method, params)\n\n    return (): void => {\n      responses.delete(id)\n    }\n  }\n\n  return {\n    request,\n    disconnect,\n  }\n}\n"],"names":["subscriptionId"],"mappings":"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"}