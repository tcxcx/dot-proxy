import { enhanceEncoder, u8, compact } from '@polkadot-api/substrate-bindings';
import { mergeUint8 } from '@polkadot-api/utils';
import { getLookupFn } from '@polkadot-api/metadata-builders';

const versionCodec = enhanceEncoder(
  u8.enc,
  (value) => +!!value.signed << 7 | value.version
);
const unkownSignerType = () => new Error("Unkown signer");
const getSignerType = (metadata) => {
  const { extrinsic } = metadata;
  const getLookup = getLookupFn(metadata);
  let address;
  let signature;
  if ("address" in extrinsic) {
    address = getLookup(extrinsic.address);
    signature = getLookup(extrinsic.signature);
  } else {
    const extProps = Object.fromEntries(
      metadata.lookup[extrinsic.type].params.filter((x) => x.type != null).map((x) => [x.name, getLookup(x.type)])
    );
    address = extProps["Address"];
    signature = extProps["Signature"];
    if (!address || !signature) throw unkownSignerType();
  }
  if (address.type === "AccountId20" && signature.type === "array" && signature.len === 65 && signature.value.type === "primitive" && signature.value.value === "u8")
    return [1 /* Ethereum */, []];
  if (signature.type !== "enum" || ["Ecdsa", "Ed25519", "Sr25519"].some((x) => !(x in signature.value)))
    throw unkownSignerType();
  if (address.type === "enum") {
    const id = address.value["Id"];
    if (id.type === "lookupEntry" && id.value.type === "AccountId32")
      return [0 /* Polkadot */, [id.idx]];
  } else if (address.type === "AccountId32") return [0 /* Polkadot */, []];
  throw unkownSignerType();
};
const signingTypeId = {
  Ed25519: 0,
  Sr25519: 1,
  Ecdsa: 2
};
const createV4Tx = (metadata, publicKey, signed, extra, callData, signingType) => {
  const [signerType, addressPrefix] = getSignerType(metadata);
  const preResult = mergeUint8(
    versionCodec({ signed: true, version: 4 }),
    // converting it to a `MultiAddress` enum, where the index 0 is `Id(AccountId)`
    signerType === 1 /* Ethereum */ ? publicKey : new Uint8Array([...addressPrefix, ...publicKey]),
    signerType === 1 /* Ethereum */ || !signingType ? signed : new Uint8Array([signingTypeId[signingType], ...signed]),
    ...extra,
    callData
  );
  return mergeUint8(compact.enc(preResult.length), preResult);
};

export { createV4Tx };
//# sourceMappingURL=v4.mjs.map
