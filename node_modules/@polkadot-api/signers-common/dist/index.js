'use strict';

var substrateBindings = require('@polkadot-api/substrate-bindings');
var utils = require('@polkadot-api/utils');
var metadataBuilders = require('@polkadot-api/metadata-builders');

const versionCodec = substrateBindings.enhanceEncoder(
  substrateBindings.u8.enc,
  (value) => +!!value.signed << 7 | value.version
);
const unkownSignerType = () => new Error("Unkown signer");
const getSignerType = (metadata) => {
  const { extrinsic } = metadata;
  const getLookup = metadataBuilders.getLookupFn(metadata);
  let address;
  let signature;
  if ("address" in extrinsic) {
    address = getLookup(extrinsic.address);
    signature = getLookup(extrinsic.signature);
  } else {
    const extProps = Object.fromEntries(
      metadata.lookup[extrinsic.type].params.filter((x) => x.type != null).map((x) => [x.name, getLookup(x.type)])
    );
    address = extProps["Address"];
    signature = extProps["Signature"];
    if (!address || !signature) throw unkownSignerType();
  }
  if (address.type === "AccountId20" && signature.type === "array" && signature.len === 65 && signature.value.type === "primitive" && signature.value.value === "u8")
    return [1 /* Ethereum */, []];
  if (signature.type !== "enum" || ["Ecdsa", "Ed25519", "Sr25519"].some((x) => !(x in signature.value)))
    throw unkownSignerType();
  if (address.type === "enum") {
    const id = address.value["Id"];
    if (id.type === "lookupEntry" && id.value.type === "AccountId32")
      return [0 /* Polkadot */, [id.idx]];
  } else if (address.type === "AccountId32") return [0 /* Polkadot */, []];
  throw unkownSignerType();
};
const signingTypeId = {
  Ed25519: 0,
  Sr25519: 1,
  Ecdsa: 2
};
const createV4Tx = (metadata, publicKey, signed, extra, callData, signingType) => {
  const [signerType, addressPrefix] = getSignerType(metadata);
  const preResult = utils.mergeUint8(
    versionCodec({ signed: true, version: 4 }),
    // converting it to a `MultiAddress` enum, where the index 0 is `Id(AccountId)`
    signerType === 1 /* Ethereum */ ? publicKey : new Uint8Array([...addressPrefix, ...publicKey]),
    signerType === 1 /* Ethereum */ || !signingType ? signed : new Uint8Array([signingTypeId[signingType], ...signed]),
    ...extra,
    callData
  );
  return utils.mergeUint8(substrateBindings.compact.enc(preResult.length), preResult);
};

const [preBytes, postBytes] = ["<Bytes>", "</Bytes>"].map(
  (str) => substrateBindings.Binary.fromText(str).asBytes()
);
const getSignBytes = (sign) => async (data) => {
  let isPadded = true;
  let i;
  for (i = 0; isPadded && i < preBytes.length; i++)
    isPadded = preBytes[i] === data[i];
  isPadded = isPadded && i === preBytes.length;
  const postDataStart = data.length - postBytes.length;
  for (i = 0; isPadded && i < postBytes.length; i++)
    isPadded = postBytes[i] === data[postDataStart + i];
  isPadded = isPadded && i === postBytes.length;
  return sign(isPadded ? data : utils.mergeUint8(preBytes, data, postBytes));
};

exports.createV4Tx = createV4Tx;
exports.getSignBytes = getSignBytes;
//# sourceMappingURL=index.js.map
