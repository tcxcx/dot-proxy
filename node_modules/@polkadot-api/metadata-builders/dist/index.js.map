{"version":3,"file":"index.js","sources":["../src/lookups.ts","../src/with-cache.ts","../src/lookup-codec-builder.ts","../src/dynamic-builder.ts","../src/lookup-graph.ts","../src/checksum-builder.ts"],"sourcesContent":["import type {\n  StringRecord,\n  V14,\n  V14Lookup,\n  V15,\n} from \"@polkadot-api/substrate-bindings\"\n\nexport type SignedPrimitive = \"i8\" | \"i16\" | \"i32\" | \"i64\" | \"i128\" | \"i256\"\nexport type UnsignedPrimitive = \"u8\" | \"u16\" | \"u32\" | \"u64\" | \"u128\" | \"u256\"\nexport type MetadataPrimitives =\n  | \"bool\"\n  | \"char\"\n  | \"str\"\n  | SignedPrimitive\n  | UnsignedPrimitive\n\nexport type PrimitiveVar = {\n  type: \"primitive\"\n  value: MetadataPrimitives\n}\n\nexport type VoidVar = { type: \"void\" }\nexport type CompactVar = {\n  type: \"compact\"\n  isBig: boolean\n  size: UnsignedPrimitive\n}\nexport type BitSequenceVar = { type: \"bitSequence\" }\nexport type AccountId32 = { type: \"AccountId32\" }\nexport type AccountId20 = { type: \"AccountId20\" }\nexport type TerminalVar =\n  | PrimitiveVar\n  | VoidVar\n  | CompactVar\n  | BitSequenceVar\n  | AccountId32\n  | AccountId20\n\n/* Array-like vars:\n * - TupleVar: Mixed types, fixed length\n * - Sequence: One type, arbitrary length\n * - Array: One type, fixed length\n */\nexport type TupleVar = {\n  type: \"tuple\"\n  value: LookupEntry[]\n  innerDocs: Array<string[]>\n}\nexport type StructVar = {\n  type: \"struct\"\n  value: StringRecord<LookupEntry>\n  innerDocs: StringRecord<string[]>\n}\nexport type EnumVar = {\n  type: \"enum\"\n  value: StringRecord<\n    (\n      | { type: \"lookupEntry\"; value: LookupEntry }\n      | VoidVar\n      | TupleVar\n      | StructVar\n      | ArrayVar\n    ) & { idx: number }\n  >\n  innerDocs: StringRecord<string[]>\n  byteLength?: number\n}\nexport type OptionVar = {\n  type: \"option\"\n  value: LookupEntry\n}\nexport type ResultVar = {\n  type: \"result\"\n  value: { ok: LookupEntry; ko: LookupEntry }\n}\nexport type SequenceVar = {\n  type: \"sequence\"\n  value: LookupEntry\n}\nexport type ArrayVar = {\n  type: \"array\"\n  value: LookupEntry\n  len: number\n}\n\nexport type ComposedVar =\n  | TupleVar\n  | StructVar\n  | SequenceVar\n  | ArrayVar\n  | OptionVar\n  | ResultVar\n  | EnumVar\n\nexport type Var = TerminalVar | ComposedVar\n\nexport type LookupEntry = {\n  id: number\n} & Var\n\nconst isBytes = (value: LookupEntry, nBytes: number) =>\n  value.type === \"array\" &&\n  value.len === nBytes &&\n  value.value.type === \"primitive\" &&\n  value.value.value === \"u8\"\n\nconst _void: VoidVar = { type: \"void\" }\n\nexport interface MetadataLookup {\n  (id: number): LookupEntry\n  metadata: V14 | V15\n  call: number | null\n}\n\nconst _denormalizeLookup = (\n  lookupData: V14Lookup,\n  customMap: (value: V14Lookup[number]) => Var | null = () => null,\n): ((id: number) => LookupEntry) => {\n  const lookups = new Map<number, LookupEntry>()\n  const from = new Set<number>()\n\n  const withCache = (\n    fn: (id: number) => Var,\n  ): ((id: number) => LookupEntry) => {\n    return (id) => {\n      let entry = lookups.get(id)\n\n      if (entry) return entry\n\n      if (from.has(id)) {\n        const entry = {\n          id,\n        } as LookupEntry\n\n        lookups.set(id, entry)\n        return entry\n      }\n\n      from.add(id)\n      const value = fn(id)\n      entry = lookups.get(id)\n\n      if (entry) {\n        Object.assign(entry, value)\n      } else {\n        entry = {\n          id,\n          ...value,\n        }\n        lookups.set(id, entry!)\n      }\n      from.delete(id)\n      return entry\n    }\n  }\n\n  let isAccountId32SearchOn = true\n  let isAccountId20SearchOn = true\n  const getLookupEntryDef = withCache((id): Var => {\n    const custom = customMap(lookupData[id])\n    if (custom) return custom\n\n    const { def, path, params } = lookupData[id]\n\n    if (def.tag === \"composite\") {\n      if (def.value.length === 0) return _void\n\n      // used to be a \"pointer\"\n      if (def.value.length === 1) {\n        const inner = getLookupEntryDef(def.value[0].type as number)\n\n        if (\n          isAccountId32SearchOn &&\n          path.at(-1) === \"AccountId32\" &&\n          isBytes(inner, 32)\n        ) {\n          isAccountId32SearchOn = false\n          return { type: \"AccountId32\" }\n        }\n\n        if (\n          isAccountId20SearchOn &&\n          path.at(-1) === \"AccountId20\" &&\n          isBytes(inner, 20)\n        ) {\n          isAccountId20SearchOn = false\n          return { type: \"AccountId20\" }\n        }\n\n        return inner\n      }\n\n      return getComplexVar(def.value)\n    }\n\n    if (def.tag === \"variant\") {\n      if (\n        path.length === 1 &&\n        path[0] === \"Option\" &&\n        params.length === 1 &&\n        params[0].name === \"T\"\n      ) {\n        const value = getLookupEntryDef(params[0].type!)\n        return value.type === \"void\"\n          ? // Option<void> would return a Codec<undefined> which makes no sense\n            // Therefore, we better treat it as a bool\n            { type: \"primitive\", value: \"bool\" }\n          : {\n              type: \"option\",\n              value,\n            }\n      }\n\n      if (\n        path.length === 1 &&\n        path[0] === \"Result\" &&\n        params.length === 2 &&\n        params[0].name === \"T\" &&\n        params[1].name === \"E\"\n      ) {\n        return {\n          type: \"result\",\n          value: {\n            ok: getLookupEntryDef(params[0].type as number),\n            ko: getLookupEntryDef(params[1].type as number),\n          },\n        }\n      }\n      if (def.value.length === 0) return _void\n\n      const enumValue: StringRecord<EnumVar[\"value\"][keyof EnumVar[\"value\"]]> =\n        {}\n      const enumDocs: StringRecord<string[]> = {}\n\n      def.value.forEach((x) => {\n        const key = x.name\n        enumDocs[key] = x.docs\n\n        if (x.fields.length === 0) {\n          enumValue[key] = { ..._void, idx: x.index }\n          return\n        }\n\n        if (x.fields.length === 1 && !x.fields[0].name) {\n          enumValue[key] = {\n            type: \"lookupEntry\",\n            value: getLookupEntryDef(x.fields[0].type),\n            idx: x.index,\n          }\n          return\n        }\n\n        enumValue[key] = { ...getComplexVar(x.fields), idx: x.index }\n      })\n\n      return {\n        type: \"enum\",\n        value: enumValue,\n        innerDocs: enumDocs,\n      }\n    }\n\n    if (def.tag === \"sequence\")\n      return {\n        type: \"sequence\",\n        value: getLookupEntryDef(def.value as number),\n      }\n\n    if (def.tag === \"array\") {\n      const { len } = def.value\n      const value = getLookupEntryDef(def.value.type)\n\n      return !len || value.type === \"void\"\n        ? _void\n        : len > 1\n          ? {\n              type: \"array\",\n              value,\n              len: def.value.len,\n            }\n          : value\n    }\n\n    if (def.tag === \"tuple\") {\n      if (def.value.length === 0) return _void\n\n      return def.value.length > 1\n        ? getArrayOrTuple(\n            def.value.map((x) => getLookupEntryDef(x as number)),\n            def.value.map((x) => lookupData[x].docs),\n          )\n        : getLookupEntryDef(def.value[0] as number) // use to be a \"pointer\"\n    }\n\n    if (def.tag === \"primitive\") {\n      return {\n        type: \"primitive\",\n        value: def.value.tag,\n      }\n    }\n\n    if (def.tag === \"compact\") {\n      const translated = getLookupEntryDef(def.value) as PrimitiveVar | VoidVar\n      if (translated.type === \"void\") return _void\n\n      const isBig = Number(translated.value.slice(1)) > 32\n\n      return {\n        type: \"compact\",\n        isBig,\n        size: translated.value as UnsignedPrimitive,\n      }\n    }\n\n    // bitSequence\n    return {\n      type: def.tag,\n    }\n  })\n\n  const getComplexVar = (\n    input: Array<{ type: number; name?: string; docs: string[] }>,\n  ): TupleVar | StructVar | ArrayVar | VoidVar => {\n    let allKey = true\n\n    const values: Record<string | number, LookupEntry> = {}\n    const innerDocs: Record<string | number, string[]> = {}\n\n    input.forEach((x, idx) => {\n      allKey = allKey && !!x.name\n      const key = x.name || idx\n      const value = getLookupEntryDef(x.type as number)\n      if (value.type !== \"void\") {\n        values[key] = value\n        innerDocs[key] = x.docs\n      }\n    })\n    return allKey\n      ? {\n          type: \"struct\",\n          value: values as StringRecord<LookupEntry>,\n          innerDocs: innerDocs as StringRecord<string[]>,\n        }\n      : getArrayOrTuple(Object.values(values), Object.values(innerDocs))\n  }\n\n  const getArrayOrTuple = (\n    values: Array<LookupEntry>,\n    innerDocs: Array<string[]>,\n  ): TupleVar | ArrayVar | VoidVar => {\n    if (\n      values.every((v) => v.id === values[0].id) &&\n      innerDocs.every((doc) => !doc.length)\n    ) {\n      const [value] = values\n      return value.type === \"void\"\n        ? _void\n        : {\n            type: \"array\",\n            value: values[0],\n            len: values.length,\n          }\n    }\n    return {\n      type: \"tuple\",\n      value: values,\n      innerDocs: innerDocs,\n    }\n  }\n\n  return getLookupEntryDef\n}\n\nexport const denormalizeLookup = (lookupData: V14Lookup) =>\n  _denormalizeLookup(lookupData)\n\nexport const getLookupFn = (metadata: V14 | V15): MetadataLookup => {\n  const getLookupEntryDef = _denormalizeLookup(metadata.lookup, ({ def }) => {\n    if (def.tag === \"composite\") {\n      const moduleErrorLength = getModuleErrorLength(def)\n      if (moduleErrorLength) {\n        return {\n          type: \"enum\",\n          innerDocs: {},\n          value: Object.fromEntries(\n            metadata.pallets.map((p) => [\n              p.name,\n              p.errors == null\n                ? { ..._void, idx: p.index }\n                : {\n                    type: \"lookupEntry\" as const,\n                    value: getLookupEntryDef(p.errors),\n                    idx: p.index,\n                  },\n            ]),\n          ) as StringRecord<\n            (\n              | VoidVar\n              | {\n                  type: \"lookupEntry\"\n                  value: LookupEntry\n                }\n            ) & { idx: number }\n          >,\n          byteLength: moduleErrorLength,\n        }\n      }\n    }\n    return null\n  })\n\n  function getModuleErrorLength(def: {\n    tag: \"composite\"\n    value: {\n      name: string | undefined\n      type: number\n      typeName: string | undefined\n      docs: string[]\n    }[]\n  }) {\n    const preChecks =\n      def.value.length === 2 &&\n      def.value[0].name === \"index\" &&\n      def.value[1].name === \"error\"\n    if (!preChecks) return null\n\n    const index = getLookupEntryDef(def.value[0].type)\n    const error = getLookupEntryDef(def.value[1].type)\n\n    return index.type === \"primitive\" &&\n      index.value === \"u8\" &&\n      error.type === \"array\" &&\n      error.value.type === \"primitive\" &&\n      error.value.value === \"u8\"\n      ? 1 + error.len\n      : null\n  }\n\n  const getCall = () => {\n    if (\"outerEnums\" in metadata) {\n      return metadata.outerEnums.call\n    }\n\n    const extrinsic = metadata.lookup[metadata.extrinsic?.type]\n    const call = extrinsic?.params.find((p) => p.name === \"Call\")\n\n    return call?.type ?? null\n  }\n\n  return Object.assign(getLookupEntryDef, { metadata, call: getCall() })\n}\n","import { LookupEntry } from \"./lookups\"\n\ntype FnWithStack<Other extends Array<any>, T> = (\n  input: LookupEntry,\n  cache: Map<number, T>,\n  stack: Set<number>,\n  ...rest: Other\n) => T\n\nexport const withCache =\n  <Other extends Array<any>, T>(\n    fn: FnWithStack<Other, T>,\n    onEnterCircular: (\n      cacheGetter: () => T,\n      circular: LookupEntry,\n      ...rest: Other\n    ) => T,\n    onExitCircular: (\n      outter: T,\n      inner: T,\n      circular: LookupEntry,\n      ...rest: Other\n    ) => T,\n  ): FnWithStack<Other, T> =>\n  (input, cache, stack, ...rest) => {\n    const { id } = input\n    if (cache.has(id)) return cache.get(id)!\n\n    if (stack.has(id)) {\n      const res = onEnterCircular(() => cache.get(id)!, input, ...rest)\n      cache.set(id, res)\n      return res\n    }\n\n    stack.add(id)\n    let result = fn(input, cache, stack, ...rest)\n    stack.delete(id)\n\n    if (cache.has(id))\n      result = onExitCircular(result, cache.get(id)!, input, ...rest)\n\n    cache.set(id, result)\n    return result\n  }\n","import type { Codec, StringRecord } from \"@polkadot-api/substrate-bindings\"\nimport * as scale from \"@polkadot-api/substrate-bindings\"\nimport type { LookupEntry } from \"./lookups\"\nimport { withCache } from \"./with-cache\"\n\nconst _bytes = scale.Bin()\n\nconst _buildCodec = (\n  input: LookupEntry,\n  cache: Map<number, Codec<any>>,\n  stack: Set<number>,\n  _accountId: Codec<scale.SS58String>,\n): Codec<any> => {\n  if (input.type === \"primitive\") return scale[input.value]\n  if (input.type === \"void\") return scale._void\n  if (input.type === \"AccountId32\") return _accountId\n  if (input.type === \"AccountId20\") return scale.ethAccount\n  if (input.type === \"compact\")\n    return input.isBig ? scale.compactBn : scale.compactNumber\n  if (input.type === \"bitSequence\") return scale.bitSequence\n\n  const buildNextCodec = (nextInput: LookupEntry): Codec<any> =>\n    buildCodec(nextInput, cache, stack, _accountId)\n\n  const buildVector = (inner: LookupEntry, len?: number) => {\n    const innerCodec = buildNextCodec(inner)\n    return len ? scale.Vector(innerCodec, len) : scale.Vector(innerCodec)\n  }\n\n  const buildTuple = (value: LookupEntry[]) =>\n    scale.Tuple(...value.map(buildNextCodec))\n\n  const buildStruct = (value: StringRecord<LookupEntry>) => {\n    const inner = Object.fromEntries(\n      Object.entries(value).map(([key, value]) => [key, buildNextCodec(value)]),\n    ) as StringRecord<Codec<any>>\n    return scale.Struct(inner)\n  }\n\n  if (\n    input.type === \"sequence\" &&\n    input.value.type === \"primitive\" &&\n    input.value.value === \"u8\"\n  ) {\n    return _bytes\n  }\n\n  if (input.type === \"array\") {\n    // Bytes case\n    if (input.value.type === \"primitive\" && input.value.value === \"u8\")\n      return scale.Bin(input.len)\n\n    return buildVector(input.value, input.len)\n  }\n\n  if (input.type === \"sequence\") return buildVector(input.value)\n  if (input.type === \"tuple\") return buildTuple(input.value)\n  if (input.type === \"struct\") return buildStruct(input.value)\n\n  if (input.type === \"option\") return scale.Option(buildNextCodec(input.value))\n\n  if (input.type === \"result\")\n    return scale.Result(\n      buildNextCodec(input.value.ok),\n      buildNextCodec(input.value.ko),\n    )\n\n  // it has to be an enum by now\n  const dependencies = Object.values(input.value).map((v) => {\n    switch (v.type) {\n      case \"void\":\n        return scale._void\n      case \"lookupEntry\":\n        return buildNextCodec(v.value)\n      case \"tuple\":\n        return buildTuple(v.value)\n      case \"struct\":\n        return buildStruct(v.value)\n      case \"array\":\n        return buildVector(v.value, v.len)\n    }\n  })\n\n  const inner = Object.fromEntries(\n    Object.keys(input.value).map((key, idx) => {\n      return [key, dependencies[idx]]\n    }),\n  ) as StringRecord<Codec<any>>\n\n  const indexes = Object.values(input.value).map((x) => x.idx)\n  const areIndexesSorted = indexes.every((idx, i) => idx === i)\n\n  const variantCodec = areIndexesSorted\n    ? scale.Variant(inner)\n    : scale.Variant(inner, indexes as any)\n  return input.byteLength\n    ? fixedSizeCodec(variantCodec, input.byteLength)\n    : variantCodec\n}\nconst buildCodec = withCache(_buildCodec, scale.Self, (res) => res)\n\nexport const getLookupCodecBuilder = (\n  lookup: (id: number) => LookupEntry,\n  accountId = scale.AccountId(),\n) => {\n  const cache = new Map()\n  const buildDefinition = (id: number) =>\n    buildCodec(lookup(id), cache, new Set(), accountId)\n\n  return (id: number) => buildDefinition(id)\n}\n\nconst fixedSizeCodec = <T>(codec: Codec<T>, size: number): Codec<T> => {\n  const allBytes = scale.Bytes(size)\n  return scale.createCodec<T>(\n    (value: T) => allBytes.enc(codec.enc(value)),\n    (data) => codec.dec(allBytes.dec(data)),\n  )\n}\n","import type { Codec, StringRecord } from \"@polkadot-api/substrate-bindings\"\nimport * as scale from \"@polkadot-api/substrate-bindings\"\nimport { mapObject } from \"@polkadot-api/utils\"\nimport type { EnumVar, MetadataLookup } from \"./lookups\"\nimport { getLookupCodecBuilder } from \"./lookup-codec-builder\"\n\nexport const getDynamicBuilder = (getLookupEntryDef: MetadataLookup) => {\n  const { metadata } = getLookupEntryDef\n  let buildDefinition = getLookupCodecBuilder(getLookupEntryDef)\n\n  const prefix = metadata.pallets\n    .find((x) => x.name === \"System\")\n    ?.constants.find((x) => x.name === \"SS58Prefix\")\n\n  let ss58Prefix: number | undefined\n  if (prefix) {\n    try {\n      const prefixVal = buildDefinition(prefix.type).dec(prefix.value)\n      if (typeof prefixVal === \"number\") {\n        ss58Prefix = prefixVal\n        buildDefinition = getLookupCodecBuilder(\n          getLookupEntryDef,\n          scale.AccountId(prefixVal),\n        )\n      }\n    } catch (_) {}\n  }\n\n  const storagePallets = new Map<string, ReturnType<typeof scale.Storage>>()\n\n  const buildStorage = (pallet: string, entry: string) => {\n    let storagePallet = storagePallets.get(pallet)\n    if (!storagePallet)\n      storagePallets.set(pallet, (storagePallet = scale.Storage(pallet)))\n\n    const storageEntry = metadata.pallets\n      .find((x) => x.name === pallet)!\n      .storage!.items.find((s) => s.name === entry)!\n\n    const storageWithFallback = (\n      len: number,\n      value: Codec<any>,\n      ...args: Parameters<ReturnType<typeof scale.Storage>>\n    ) => {\n      const keys = storagePallet!(...args)\n      return {\n        keys,\n        value,\n        len,\n        fallback:\n          storageEntry.modifier === 1\n            ? value.dec(storageEntry.fallback)\n            : undefined,\n      }\n    }\n\n    if (storageEntry.type.tag === \"plain\")\n      return storageWithFallback(\n        0,\n        buildDefinition(storageEntry.type.value),\n        entry,\n      )\n\n    const { key, value, hashers } = storageEntry.type.value\n    const val = buildDefinition(value)\n    const hashes = hashers.map((x) => scale[x.tag])\n\n    const hashArgs: scale.EncoderWithHash<unknown>[] = (() => {\n      if (hashes.length === 1) {\n        return [[buildDefinition(key), hashes[0]]]\n      }\n\n      const keyDef = getLookupEntryDef(key)\n\n      switch (keyDef.type) {\n        case \"array\":\n          return hashes.map((hash) => [buildDefinition(keyDef.value.id), hash])\n        case \"tuple\":\n          return keyDef.value.map((x, idx) => [\n            buildDefinition(x.id),\n            hashes[idx],\n          ])\n        default:\n          throw new Error(\"Invalid key type\")\n      }\n    })()\n\n    return storageWithFallback(hashes.length, val, entry, ...hashArgs)\n  }\n\n  const buildEnumEntry = (\n    entry: EnumVar[\"value\"][keyof EnumVar[\"value\"]],\n  ): Codec<any> => {\n    switch (entry.type) {\n      case \"void\":\n        return scale._void\n      case \"lookupEntry\":\n        return buildDefinition(entry.value.id)\n      case \"tuple\":\n        return scale.Tuple(\n          ...Object.values(entry.value).map((l) => buildDefinition(l.id)),\n        )\n      case \"struct\":\n        return scale.Struct(\n          mapObject(entry.value, (x) => buildDefinition(x.id)) as StringRecord<\n            Codec<any>\n          >,\n        )\n      case \"array\":\n        return scale.Vector(buildDefinition(entry.value.id), entry.len)\n    }\n  }\n\n  const buildConstant = (pallet: string, constantName: string) => {\n    const storageEntry = metadata.pallets\n      .find((x) => x.name === pallet)!\n      .constants!.find((s) => s.name === constantName)!\n\n    return buildDefinition(storageEntry.type as number)\n  }\n\n  const buildVariant =\n    (type: \"errors\" | \"events\" | \"calls\") =>\n    (\n      pallet: string,\n      name: string,\n    ): {\n      codec: Codec<any>\n      location: [number, number]\n    } => {\n      const palletEntry = metadata.pallets.find((x) => x.name === pallet)!\n      const lookup = getLookupEntryDef(palletEntry[type]!)\n      if (lookup.type !== \"enum\") throw null\n      const entry = lookup.value[name]\n\n      return {\n        location: [palletEntry.index, entry.idx],\n        codec: buildEnumEntry(lookup.value[name]),\n      }\n    }\n\n  const buildRuntimeCall = (api: string, method: string) => {\n    const entry = metadata.apis\n      .find((x) => x.name === api)\n      ?.methods.find((x) => x.name === method)\n    if (!entry) throw null\n\n    return {\n      args: scale.Tuple(...entry.inputs.map((x) => buildDefinition(x.type))),\n      value: buildDefinition(entry.output),\n    }\n  }\n\n  return {\n    buildDefinition,\n    buildStorage,\n    buildEvent: buildVariant(\"events\"),\n    buildError: buildVariant(\"errors\"),\n    buildRuntimeCall,\n    buildCall: buildVariant(\"calls\"),\n    buildConstant,\n    ss58Prefix,\n  }\n}\n","import { LookupEntry } from \"./lookups\"\n\nexport type LookupGraph = Map<\n  number,\n  { entry: LookupEntry; backRefs: Set<number>; refs: Set<number> }\n>\n\nexport function buildLookupGraph(\n  lookupFn: (id: number) => LookupEntry,\n  lookupLength: number,\n): LookupGraph {\n  const result: LookupGraph = new Map()\n  const visited = new Set<number>()\n\n  const addEdge = (from: number, to: number) => {\n    if (!result.has(from))\n      result.set(from, {\n        entry: lookupFn(from),\n        backRefs: new Set(),\n        refs: new Set(),\n      })\n    if (!result.has(to))\n      result.set(to, {\n        entry: lookupFn(to),\n        backRefs: new Set(),\n        refs: new Set(),\n      })\n    result.get(from)!.refs.add(to)\n    result.get(to)!.backRefs.add(from)\n  }\n\n  for (let i = 0; i < lookupLength; i++) {\n    const entry = lookupFn(i)\n    if (i !== entry.id) {\n      // Lookup solved a pointer, but we still need to add that node into our\n      // graph in case someone access it from there.\n      addEdge(i, entry.id)\n    }\n    if (visited.has(entry.id)) continue\n    visited.add(entry.id)\n\n    switch (entry.type) {\n      case \"array\":\n      case \"option\":\n      case \"sequence\":\n        addEdge(entry.id, entry.value.id)\n        break\n      case \"enum\":\n        Object.values(entry.value).forEach((enumEntry) => {\n          switch (enumEntry.type) {\n            case \"array\":\n            case \"lookupEntry\":\n              addEdge(entry.id, enumEntry.value.id)\n              break\n            case \"struct\":\n            case \"tuple\":\n              Object.values(enumEntry.value).forEach((v) =>\n                addEdge(entry.id, v.id),\n              )\n              break\n          }\n        })\n        break\n      case \"result\":\n        addEdge(entry.id, entry.value.ok.id)\n        addEdge(entry.id, entry.value.ko.id)\n        break\n      case \"struct\":\n      case \"tuple\":\n        Object.values(entry.value).forEach((v) => addEdge(entry.id, v.id))\n        break\n    }\n\n    // It could be that this node is not being referenced by any other type\n    // nor it references anything. We still have to add it into the graph.\n    if (!result.has(entry.id)) {\n      result.set(entry.id, {\n        backRefs: new Set(),\n        refs: new Set(),\n        entry,\n      })\n    }\n  }\n\n  return result\n}\n\nconst subgraphCache = new WeakMap<LookupGraph, Map<number, LookupGraph>>()\nfunction _getSubgraph(\n  id: number,\n  graph: LookupGraph,\n  result: LookupGraph,\n  cache: Map<number, LookupGraph>,\n) {\n  if (result.has(id)) return\n  const node = graph.get(id)!\n  result.set(id, node)\n  cache.set(id, result)\n\n  node.refs.forEach((ref) => _getSubgraph(ref, graph, result, cache))\n  node.backRefs.forEach((ref) => _getSubgraph(ref, graph, result, cache))\n}\n\nexport function getSubgraph(id: number, graph: LookupGraph) {\n  if (!subgraphCache.has(graph)) {\n    subgraphCache.set(graph, new Map())\n  }\n  const cache = subgraphCache.get(graph)!\n  if (cache.has(id)) return cache.get(id)!\n\n  const result: LookupGraph = new Map()\n  _getSubgraph(id, graph, result, cache)\n  return result\n}\n\nexport function getStronglyConnectedComponents(graph: LookupGraph) {\n  // Tarjan's strongly connected components\n  const tarjanState = new Map<\n    number,\n    {\n      index: number\n      lowLink: number\n      onStack: boolean\n    }\n  >()\n  let index = 0\n  const stack: number[] = []\n  const result: Array<Set<number>> = []\n\n  function strongConnect(v: number): void {\n    const state = {\n      index: index,\n      lowLink: index,\n      onStack: true,\n    }\n    tarjanState.set(v, state)\n    index++\n    stack.push(v)\n\n    const edges = graph.get(v)!.refs\n    for (let w of edges) {\n      const edgeState = tarjanState.get(w)\n      if (!edgeState) {\n        strongConnect(w)\n        state.lowLink = Math.min(state.lowLink, tarjanState.get(w)!.lowLink)\n      } else if (edgeState.onStack) {\n        state.lowLink = Math.min(state.lowLink, edgeState.index)\n      }\n    }\n\n    if (state.lowLink === state.index) {\n      const component = new Set<number>()\n\n      let poppedNode = -1\n      do {\n        poppedNode = stack.pop()!\n        tarjanState.get(poppedNode)!.onStack = false\n        component.add(poppedNode)\n      } while (poppedNode !== v)\n\n      result.push(component)\n    }\n  }\n\n  for (const node of graph.keys()) {\n    if (!tarjanState.has(node)) {\n      strongConnect(node)\n    }\n  }\n\n  return result\n}\n\nexport function mergeSCCsWithCommonNodes(\n  stronglyConnectedComponents: Array<Set<number>>,\n) {\n  /**\n   * For Nodes that are shared between two sets of SCCs, we need to calculate\n   * the checksum for the both of them, which wouldn't work (it would give\n   * different checksums).\n   * So we merge the SCCs that are using shared nodes into one group.\n   */\n  const scc = stronglyConnectedComponents\n  const ungroupedCycles = new Set(scc.map((_, i) => i))\n  const edges = new Map(scc.map((_, i) => [i, new Set<number>()]))\n  scc.forEach((cycle, i) => {\n    scc.slice(i + 1).forEach((otherCycle, _j) => {\n      const j = _j + i + 1\n      const combined = new Set([...cycle, ...otherCycle])\n      if (combined.size !== cycle.size + otherCycle.size) {\n        edges.get(i)!.add(j)\n        edges.get(j)!.add(i)\n      }\n    })\n  })\n  const groups: Array<Set<number>> = []\n\n  while (ungroupedCycles.size) {\n    const group = new Set<number>()\n    const toVisit = [ungroupedCycles.values().next().value!]\n    while (toVisit.length) {\n      const idx = toVisit.pop()!\n      if (!ungroupedCycles.has(idx)) continue\n      ungroupedCycles.delete(idx)\n\n      const cycle = scc[idx]\n      cycle.forEach((v) => group.add(Number(v)))\n      edges.get(idx)!.forEach((n) => toVisit.push(n))\n    }\n    groups.push(group)\n  }\n\n  return groups\n}\n","import type { StringRecord } from \"@polkadot-api/substrate-bindings\"\nimport { h64 } from \"@polkadot-api/substrate-bindings\"\nimport {\n  LookupGraph,\n  buildLookupGraph,\n  getStronglyConnectedComponents,\n  getSubgraph,\n  mergeSCCsWithCommonNodes,\n} from \"./lookup-graph\"\nimport {\n  ArrayVar,\n  LookupEntry,\n  MetadataLookup,\n  MetadataPrimitives,\n  StructVar,\n  TupleVar,\n  VoidVar,\n} from \"./lookups\"\n\nconst textEncoder = new TextEncoder()\nconst encodeText = textEncoder.encode.bind(textEncoder)\n\nconst getChecksum = (values: Array<bigint>) => {\n  const res = new Uint8Array(values.length * 8)\n  const dv = new DataView(res.buffer)\n\n  for (let i = 0; i < values.length; i++) dv.setBigUint64(i * 8, values[i])\n\n  return h64(res)\n}\nconst getStringChecksum = (values: Array<string>) =>\n  getChecksum(values.map((v) => h64(encodeText(v))))\n\ntype Shape =\n  | \"primitive\"\n  | \"void\"\n  | \"vector\"\n  | \"tuple\"\n  | \"struct\"\n  | \"option\"\n  | \"result\"\n  | \"enum\"\nconst shapeIds: Record<Shape, bigint> = {\n  primitive: 0n,\n  vector: 1n,\n  tuple: 2n,\n  struct: 3n,\n  option: 4n,\n  result: 5n,\n  enum: 6n,\n  void: 7n,\n}\n\ntype RuntimePrimitives =\n  | \"undefined\"\n  | \"number\"\n  | \"string\"\n  | \"bigint\"\n  | \"boolean\"\n  | \"bitSequence\"\n  | \"byteSequence\"\n  | \"accountId32\"\n  | \"accountId20\"\n\nconst runtimePrimitiveIds: Record<RuntimePrimitives, bigint> = {\n  undefined: 0n,\n  number: 1n,\n  string: 2n,\n  bigint: 3n,\n  boolean: 4n,\n  bitSequence: 5n, // {bitsLen: number, bytes: Uint8Array}\n  byteSequence: 6n, // Binary\n  accountId32: 7n, // SS58String\n  accountId20: 8n, // EthAccount\n}\n\nconst metadataPrimitiveIds: Record<MetadataPrimitives, bigint> = {\n  bool: runtimePrimitiveIds.boolean,\n  char: runtimePrimitiveIds.string,\n  str: runtimePrimitiveIds.string,\n  u8: runtimePrimitiveIds.number,\n  u16: runtimePrimitiveIds.number,\n  u32: runtimePrimitiveIds.number,\n  u64: runtimePrimitiveIds.bigint,\n  u128: runtimePrimitiveIds.bigint,\n  u256: runtimePrimitiveIds.bigint,\n  i8: runtimePrimitiveIds.number,\n  i16: runtimePrimitiveIds.number,\n  i32: runtimePrimitiveIds.number,\n  i64: runtimePrimitiveIds.bigint,\n  i128: runtimePrimitiveIds.bigint,\n  i256: runtimePrimitiveIds.bigint,\n}\n\nconst structLikeBuilder = <T>(\n  shapeId: bigint,\n  input: StringRecord<T>,\n  innerChecksum: (value: T) => bigint,\n) => {\n  const sortedEntries = Object.entries(input).sort(([a], [b]) =>\n    a.localeCompare(b),\n  )\n  const keysChecksum = getStringChecksum(sortedEntries.map(([key]) => key))\n  const valuesChecksum = getChecksum(\n    sortedEntries.map(([, entry]) => innerChecksum(entry)),\n  )\n\n  return getChecksum([shapeId, keysChecksum, valuesChecksum])\n}\n\nconst _buildChecksum = (\n  input: LookupEntry,\n  buildNextChecksum: (entry: LookupEntry) => bigint,\n): bigint => {\n  if (input.type === \"primitive\")\n    return getChecksum([shapeIds.primitive, metadataPrimitiveIds[input.value]])\n\n  if (input.type === \"void\") return getChecksum([shapeIds.void])\n\n  if (input.type === \"compact\")\n    return getChecksum([\n      shapeIds.primitive,\n      runtimePrimitiveIds[input.isBig ? \"bigint\" : \"number\"],\n    ])\n\n  if (input.type === \"bitSequence\")\n    return getChecksum([shapeIds.primitive, runtimePrimitiveIds.bitSequence])\n\n  if (input.type === \"AccountId32\") {\n    return getChecksum([shapeIds.primitive, runtimePrimitiveIds.accountId32])\n  }\n\n  if (input.type === \"AccountId20\") {\n    return getChecksum([shapeIds.primitive, runtimePrimitiveIds.accountId20])\n  }\n\n  const buildVector = (entry: LookupEntry, length?: number) => {\n    const innerChecksum = buildNextChecksum(entry)\n    return getChecksum(\n      length !== undefined\n        ? [shapeIds.vector, innerChecksum, BigInt(length)]\n        : [shapeIds.vector, innerChecksum],\n    )\n  }\n\n  if (input.type === \"array\") {\n    const innerValue = input.value\n    if (innerValue.type === \"primitive\" && innerValue.value === \"u8\") {\n      return getChecksum([\n        shapeIds.primitive,\n        runtimePrimitiveIds.byteSequence,\n        BigInt(input.len),\n      ])\n    }\n    return buildVector(innerValue, input.len)\n  }\n\n  if (input.type === \"sequence\") {\n    const innerValue = input.value\n    if (innerValue.type === \"primitive\" && innerValue.value === \"u8\") {\n      return getChecksum([shapeIds.primitive, runtimePrimitiveIds.byteSequence])\n    }\n    return buildVector(innerValue)\n  }\n\n  const buildTuple = (entries: LookupEntry[]) =>\n    getChecksum([shapeIds.tuple, ...entries.map(buildNextChecksum)])\n\n  const buildStruct = (entries: StringRecord<LookupEntry>) =>\n    structLikeBuilder(shapeIds.struct, entries, buildNextChecksum)\n\n  if (input.type === \"tuple\") return buildTuple(input.value)\n\n  if (input.type === \"struct\") return buildStruct(input.value)\n\n  if (input.type === \"option\")\n    return getChecksum([shapeIds.option, buildNextChecksum(input.value)])\n\n  if (input.type === \"result\")\n    return getChecksum([\n      shapeIds.result,\n      buildNextChecksum(input.value.ok),\n      buildNextChecksum(input.value.ko),\n    ])\n\n  return structLikeBuilder(shapeIds.enum, input.value, (entry) => {\n    if (entry.type === \"lookupEntry\") return buildNextChecksum(entry.value)\n    switch (entry.type) {\n      case \"void\":\n        return getChecksum([shapeIds.void])\n      case \"tuple\":\n        return buildTuple(entry.value)\n      case \"struct\":\n        return buildStruct(entry.value)\n      case \"array\":\n        return buildVector(entry.value, entry.len)\n    }\n  })\n}\n\nconst sortCyclicGroups = (groups: Array<Set<number>>, graph: LookupGraph) => {\n  const getReachableNodes = (group: Set<number>) => {\n    const result = new Set<number>()\n    const toVisit = Array.from(group)\n    while (toVisit.length) {\n      const id = toVisit.pop()!\n      if (result.has(id)) continue\n      result.add(id)\n\n      graph.get(id)?.refs.forEach((id) => toVisit.push(id))\n    }\n\n    return Array.from(result)\n  }\n\n  const result: Array<Set<number>> = new Array()\n\n  function dependentsFirst(group: Set<number>) {\n    if (result.includes(group)) return\n    const dependents = groups.filter(\n      (candidate) =>\n        candidate !== group &&\n        getReachableNodes(group).some((node) => candidate.has(node)),\n    )\n    dependents.forEach((group) => dependentsFirst(group))\n    if (result.includes(group)) return\n    result.push(group)\n  }\n\n  groups.forEach((group) => dependentsFirst(group))\n  return result\n}\n\nfunction iterateChecksums(\n  group: Set<number>,\n  iterations: number,\n  cache: Map<number, bigint>,\n  graph: LookupGraph,\n) {\n  // Keep the values that are getting changed on each iteration in a separate\n  // cache, because two nodes referencing the same one should read the same\n  // previous iteration checksum for that node.\n  const groupReadCache = new Map([...group].map((id) => [id, 0n]))\n  const groupWriteCache = new Map<number, bigint>()\n\n  const recursiveBuildChecksum = (\n    entry: LookupEntry,\n    // The first call has to skip the cache, otherwise it would return the\n    // previous iteration result.\n    skipCache = true,\n  ): bigint => {\n    if (!skipCache && (groupReadCache.has(entry.id) || cache.has(entry.id))) {\n      return groupReadCache.get(entry.id) ?? cache.get(entry.id)!\n    }\n    const result = _buildChecksum(entry, (nextEntry) =>\n      recursiveBuildChecksum(nextEntry, false),\n    )\n    if (group.has(entry.id)) {\n      groupWriteCache.set(entry.id, result)\n    } else {\n      cache.set(entry.id, result)\n    }\n    return result\n  }\n\n  for (let i = 0; i < iterations; i++) {\n    group.forEach((id) => recursiveBuildChecksum(graph.get(id)!.entry))\n\n    group.forEach((id) => groupReadCache.set(id, groupWriteCache.get(id)!))\n  }\n\n  return groupReadCache\n}\n\nfunction getMirroredNodes(\n  cyclicGroups: Array<Set<number>>,\n  graph: LookupGraph,\n) {\n  const maxSize = cyclicGroups.reduce(\n    (acc, group) => Math.max(acc, group.size),\n    0,\n  )\n  const allEntries = new Set([...graph.values()].map((v) => v.entry.id))\n\n  const resultingChecksums = iterateChecksums(\n    allEntries,\n    maxSize,\n    // Cache won't be used, since it's using the internal one for every node.\n    new Map(),\n    graph,\n  )\n\n  const checksumToNodes = new Map<bigint, number[]>()\n  for (const id of allEntries) {\n    const checksum = resultingChecksums.get(id)\n    if (checksum == undefined) throw new Error(\"Unreachable\")\n    if (!checksumToNodes.has(checksum)) {\n      checksumToNodes.set(checksum, [])\n    }\n    checksumToNodes.get(checksum)!.push(id)\n  }\n\n  const checksumsWithDuplicates = [...checksumToNodes.entries()].filter(\n    ([, nodes]) => nodes.length > 1,\n  )\n\n  const duplicatesMap: Record<number, number[]> = {}\n  checksumsWithDuplicates.forEach(([, nodes]) => {\n    nodes.forEach((n) => (duplicatesMap[n] = nodes))\n  })\n\n  return duplicatesMap\n}\n\nconst buildChecksum = (\n  entry: LookupEntry,\n  cache: Map<number, bigint>,\n  graph: LookupGraph,\n) => {\n  if (cache.has(entry.id)) return cache.get(entry.id)!\n\n  const subGraph = getSubgraph(entry.id, graph)\n\n  const cycles = getStronglyConnectedComponents(subGraph).filter(\n    // SCCs can be of length=1, but for those we're only interested with those that are circular with themselves\n    (group) => group.size > 1 || isSelfCircular(group, subGraph),\n  )\n  const cyclicGroups = mergeSCCsWithCommonNodes(cycles).filter((group) => {\n    // Exclude groups that were previously calculated\n    return !cache.has(group.values().next().value!)\n  })\n  const mirrored = getMirroredNodes(cyclicGroups, subGraph)\n  const sortedCyclicGroups = sortCyclicGroups(cyclicGroups, subGraph)\n\n  sortedCyclicGroups.forEach((group) => {\n    if (cache.has(group.values().next().value!)) {\n      // exclude mirrored groups\n      return\n    }\n\n    const result = iterateChecksums(group, group.size, cache, graph)\n    group.forEach((id) => {\n      const checksum = result.get(id)!\n      if (id in mirrored) {\n        mirrored[id].forEach((id) => cache.set(id, checksum))\n      } else {\n        cache.set(id, checksum)\n      }\n    })\n  })\n\n  const getChecksum = (entry: LookupEntry) => {\n    if (cache.has(entry.id)) return cache.get(entry.id)!\n    return _buildChecksum(entry, getChecksum)\n  }\n\n  return getChecksum(entry)\n}\n\nconst isSelfCircular = (group: Set<number>, graph: LookupGraph) => {\n  if (group.size !== 1) return false\n  const [id] = group\n\n  return graph.get(id)!.refs.has(id)\n}\n\nexport const getChecksumBuilder = (getLookupEntryDef: MetadataLookup) => {\n  const { metadata } = getLookupEntryDef\n  const graph = buildLookupGraph(getLookupEntryDef, metadata.lookup.length)\n\n  const cache = new Map<number, bigint>()\n\n  const buildDefinition = (id: number): bigint =>\n    buildChecksum(getLookupEntryDef(id), cache, graph)\n\n  const buildStorage = (pallet: string, entry: string): bigint | null => {\n    try {\n      const storageEntry = metadata.pallets\n        .find((x) => x.name === pallet)!\n        .storage!.items.find((s) => s.name === entry)!\n\n      if (storageEntry.type.tag === \"plain\")\n        return buildDefinition(storageEntry.type.value)\n\n      const { key, value } = storageEntry.type.value\n      const val = buildDefinition(value)\n      const returnKey = buildDefinition(key)\n      return getChecksum([val, returnKey])\n    } catch (_) {\n      return null\n    }\n  }\n\n  const buildRuntimeCall = (api: string, method: string): bigint | null => {\n    try {\n      const entry = metadata.apis\n        .find((x) => x.name === api)\n        ?.methods.find((x) => x.name === method)\n      if (!entry) throw null\n\n      const argNamesChecksum = getStringChecksum(\n        entry.inputs.map((x) => x.name),\n      )\n      const argValuesChecksum = getChecksum(\n        entry.inputs.map((x) => buildDefinition(x.type)),\n      )\n      const outputChecksum = buildDefinition(entry.output)\n\n      return getChecksum([argNamesChecksum, argValuesChecksum, outputChecksum])\n    } catch (_) {\n      return null\n    }\n  }\n\n  const buildComposite = (\n    input: TupleVar | StructVar | VoidVar | ArrayVar,\n  ): bigint => {\n    if (input.type === \"void\") return getChecksum([0n])\n\n    if (input.type === \"tuple\") {\n      const values = Object.values(input.value).map((entry) =>\n        buildDefinition(entry.id),\n      )\n\n      return getChecksum([shapeIds.tuple, ...values])\n    }\n\n    if (input.type === \"array\") {\n      return getChecksum([\n        shapeIds.vector,\n        buildDefinition(input.value.id),\n        BigInt(input.len),\n      ])\n    }\n\n    // Otherwise struct\n    return structLikeBuilder(shapeIds.struct, input.value, (entry) =>\n      buildDefinition(entry.id),\n    )\n  }\n\n  const buildNamedTuple = (input: StructVar): bigint => {\n    return structLikeBuilder(shapeIds.tuple, input.value, (entry) =>\n      buildDefinition(entry.id),\n    )\n  }\n\n  const variantShapeId = {\n    errors: 1n,\n    events: 2n,\n    calls: 3n,\n  }\n  const buildVariant =\n    (variantType: \"errors\" | \"events\" | \"calls\") =>\n    (pallet: string, name: string): bigint | null => {\n      try {\n        const palletEntry = metadata.pallets.find((x) => x.name === pallet)!\n        const enumLookup = getLookupEntryDef(\n          palletEntry[variantType]! as number,\n        )\n        buildDefinition(enumLookup.id)\n\n        if (enumLookup.type !== \"enum\") throw null\n        const entry = enumLookup.value[name]\n        const valueChecksum =\n          entry.type === \"lookupEntry\"\n            ? buildDefinition(entry.value.id)\n            : buildComposite(entry)\n        return getChecksum([variantShapeId[variantType], valueChecksum])\n      } catch (_) {\n        return null\n      }\n    }\n\n  const buildConstant = (\n    pallet: string,\n    constantName: string,\n  ): bigint | null => {\n    try {\n      const storageEntry = metadata.pallets\n        .find((x) => x.name === pallet)!\n        .constants!.find((s) => s.name === constantName)!\n\n      return buildDefinition(storageEntry.type)\n    } catch (_) {\n      return null\n    }\n  }\n\n  const toStringEnhancer =\n    <Args extends Array<any>>(\n      fn: (...args: Args) => bigint | null,\n    ): ((...args: Args) => string | null) =>\n    (...args) =>\n      fn(...args)?.toString(32) ?? null\n\n  return {\n    buildDefinition: toStringEnhancer(buildDefinition),\n    buildRuntimeCall: toStringEnhancer(buildRuntimeCall),\n    buildStorage: toStringEnhancer(buildStorage),\n    buildCall: toStringEnhancer(buildVariant(\"calls\")),\n    buildEvent: toStringEnhancer(buildVariant(\"events\")),\n    buildError: toStringEnhancer(buildVariant(\"errors\")),\n    buildConstant: toStringEnhancer(buildConstant),\n    buildComposite: toStringEnhancer(buildComposite),\n    buildNamedTuple: toStringEnhancer(buildNamedTuple),\n    getAllGeneratedChecksums: () =>\n      Array.from(cache.values()).map((v) => v.toString(32)),\n  }\n}\n"],"names":["entry","scale","inner","value","mapObject","h64","result","id","group","getChecksum"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;AAoGA,MAAM,UAAU,CAAC,KAAA,EAAoB,MACnC,KAAA,KAAA,CAAM,SAAS,OACf,IAAA,KAAA,CAAM,GAAQ,KAAA,MAAA,IACd,MAAM,KAAM,CAAA,IAAA,KAAS,WACrB,IAAA,KAAA,CAAM,MAAM,KAAU,KAAA,IAAA;AAExB,MAAM,KAAA,GAAiB,EAAE,IAAA,EAAM,MAAO,EAAA;AAQtC,MAAM,kBAAqB,GAAA,CACzB,UACA,EAAA,SAAA,GAAsD,MAAM,IAC1B,KAAA;AAClC,EAAM,MAAA,OAAA,uBAAc,GAAyB,EAAA;AAC7C,EAAM,MAAA,IAAA,uBAAW,GAAY,EAAA;AAE7B,EAAM,MAAA,SAAA,GAAY,CAChB,EACkC,KAAA;AAClC,IAAA,OAAO,CAAC,EAAO,KAAA;AACb,MAAI,IAAA,KAAA,GAAQ,OAAQ,CAAA,GAAA,CAAI,EAAE,CAAA;AAE1B,MAAA,IAAI,OAAc,OAAA,KAAA;AAElB,MAAI,IAAA,IAAA,CAAK,GAAI,CAAA,EAAE,CAAG,EAAA;AAChB,QAAA,MAAMA,MAAQ,GAAA;AAAA,UACZ;AAAA,SACF;AAEA,QAAQ,OAAA,CAAA,GAAA,CAAI,IAAIA,MAAK,CAAA;AACrB,QAAOA,OAAAA,MAAAA;AAAA;AAGT,MAAA,IAAA,CAAK,IAAI,EAAE,CAAA;AACX,MAAM,MAAA,KAAA,GAAQ,GAAG,EAAE,CAAA;AACnB,MAAQ,KAAA,GAAA,OAAA,CAAQ,IAAI,EAAE,CAAA;AAEtB,MAAA,IAAI,KAAO,EAAA;AACT,QAAO,MAAA,CAAA,MAAA,CAAO,OAAO,KAAK,CAAA;AAAA,OACrB,MAAA;AACL,QAAQ,KAAA,GAAA;AAAA,UACN,EAAA;AAAA,UACA,GAAG;AAAA,SACL;AACA,QAAQ,OAAA,CAAA,GAAA,CAAI,IAAI,KAAM,CAAA;AAAA;AAExB,MAAA,IAAA,CAAK,OAAO,EAAE,CAAA;AACd,MAAO,OAAA,KAAA;AAAA,KACT;AAAA,GACF;AAEA,EAAA,IAAI,qBAAwB,GAAA,IAAA;AAC5B,EAAA,IAAI,qBAAwB,GAAA,IAAA;AAC5B,EAAM,MAAA,iBAAA,GAAoB,SAAU,CAAA,CAAC,EAAY,KAAA;AAC/C,IAAA,MAAM,MAAS,GAAA,SAAA,CAAU,UAAW,CAAA,EAAE,CAAC,CAAA;AACvC,IAAA,IAAI,QAAe,OAAA,MAAA;AAEnB,IAAA,MAAM,EAAE,GAAK,EAAA,IAAA,EAAM,MAAO,EAAA,GAAI,WAAW,EAAE,CAAA;AAE3C,IAAI,IAAA,GAAA,CAAI,QAAQ,WAAa,EAAA;AAC3B,MAAA,IAAI,GAAI,CAAA,KAAA,CAAM,MAAW,KAAA,CAAA,EAAU,OAAA,KAAA;AAGnC,MAAI,IAAA,GAAA,CAAI,KAAM,CAAA,MAAA,KAAW,CAAG,EAAA;AAC1B,QAAA,MAAM,QAAQ,iBAAkB,CAAA,GAAA,CAAI,KAAM,CAAA,CAAC,EAAE,IAAc,CAAA;AAE3D,QACE,IAAA,qBAAA,IACA,KAAK,EAAG,CAAA,EAAE,MAAM,aAChB,IAAA,OAAA,CAAQ,KAAO,EAAA,EAAE,CACjB,EAAA;AACA,UAAwB,qBAAA,GAAA,KAAA;AACxB,UAAO,OAAA,EAAE,MAAM,aAAc,EAAA;AAAA;AAG/B,QACE,IAAA,qBAAA,IACA,KAAK,EAAG,CAAA,EAAE,MAAM,aAChB,IAAA,OAAA,CAAQ,KAAO,EAAA,EAAE,CACjB,EAAA;AACA,UAAwB,qBAAA,GAAA,KAAA;AACxB,UAAO,OAAA,EAAE,MAAM,aAAc,EAAA;AAAA;AAG/B,QAAO,OAAA,KAAA;AAAA;AAGT,MAAO,OAAA,aAAA,CAAc,IAAI,KAAK,CAAA;AAAA;AAGhC,IAAI,IAAA,GAAA,CAAI,QAAQ,SAAW,EAAA;AACzB,MAAA,IACE,IAAK,CAAA,MAAA,KAAW,CAChB,IAAA,IAAA,CAAK,CAAC,CAAM,KAAA,QAAA,IACZ,MAAO,CAAA,MAAA,KAAW,CAClB,IAAA,MAAA,CAAO,CAAC,CAAA,CAAE,SAAS,GACnB,EAAA;AACA,QAAA,MAAM,KAAQ,GAAA,iBAAA,CAAkB,MAAO,CAAA,CAAC,EAAE,IAAK,CAAA;AAC/C,QAAA,OAAO,MAAM,IAAS,KAAA,MAAA;AAAA;AAAA;AAAA,UAGlB,EAAE,IAAA,EAAM,WAAa,EAAA,KAAA,EAAO,MAAO;AAAA,YACnC;AAAA,UACE,IAAM,EAAA,QAAA;AAAA,UACN;AAAA,SACF;AAAA;AAGN,MAAA,IACE,KAAK,MAAW,KAAA,CAAA,IAChB,KAAK,CAAC,CAAA,KAAM,YACZ,MAAO,CAAA,MAAA,KAAW,KAClB,MAAO,CAAA,CAAC,EAAE,IAAS,KAAA,GAAA,IACnB,OAAO,CAAC,CAAA,CAAE,SAAS,GACnB,EAAA;AACA,QAAO,OAAA;AAAA,UACL,IAAM,EAAA,QAAA;AAAA,UACN,KAAO,EAAA;AAAA,YACL,EAAI,EAAA,iBAAA,CAAkB,MAAO,CAAA,CAAC,EAAE,IAAc,CAAA;AAAA,YAC9C,EAAI,EAAA,iBAAA,CAAkB,MAAO,CAAA,CAAC,EAAE,IAAc;AAAA;AAChD,SACF;AAAA;AAEF,MAAA,IAAI,GAAI,CAAA,KAAA,CAAM,MAAW,KAAA,CAAA,EAAU,OAAA,KAAA;AAEnC,MAAA,MAAM,YACJ,EAAC;AACH,MAAA,MAAM,WAAmC,EAAC;AAE1C,MAAI,GAAA,CAAA,KAAA,CAAM,OAAQ,CAAA,CAAC,CAAM,KAAA;AACvB,QAAA,MAAM,MAAM,CAAE,CAAA,IAAA;AACd,QAAS,QAAA,CAAA,GAAG,IAAI,CAAE,CAAA,IAAA;AAElB,QAAI,IAAA,CAAA,CAAE,MAAO,CAAA,MAAA,KAAW,CAAG,EAAA;AACzB,UAAA,SAAA,CAAU,GAAG,CAAI,GAAA,EAAE,GAAG,KAAO,EAAA,GAAA,EAAK,EAAE,KAAM,EAAA;AAC1C,UAAA;AAAA;AAGF,QAAI,IAAA,CAAA,CAAE,OAAO,MAAW,KAAA,CAAA,IAAK,CAAC,CAAE,CAAA,MAAA,CAAO,CAAC,CAAA,CAAE,IAAM,EAAA;AAC9C,UAAA,SAAA,CAAU,GAAG,CAAI,GAAA;AAAA,YACf,IAAM,EAAA,aAAA;AAAA,YACN,OAAO,iBAAkB,CAAA,CAAA,CAAE,MAAO,CAAA,CAAC,EAAE,IAAI,CAAA;AAAA,YACzC,KAAK,CAAE,CAAA;AAAA,WACT;AACA,UAAA;AAAA;AAGF,QAAU,SAAA,CAAA,GAAG,CAAI,GAAA,EAAE,GAAG,aAAA,CAAc,EAAE,MAAM,CAAA,EAAG,GAAK,EAAA,CAAA,CAAE,KAAM,EAAA;AAAA,OAC7D,CAAA;AAED,MAAO,OAAA;AAAA,QACL,IAAM,EAAA,MAAA;AAAA,QACN,KAAO,EAAA,SAAA;AAAA,QACP,SAAW,EAAA;AAAA,OACb;AAAA;AAGF,IAAA,IAAI,IAAI,GAAQ,KAAA,UAAA;AACd,MAAO,OAAA;AAAA,QACL,IAAM,EAAA,UAAA;AAAA,QACN,KAAA,EAAO,iBAAkB,CAAA,GAAA,CAAI,KAAe;AAAA,OAC9C;AAEF,IAAI,IAAA,GAAA,CAAI,QAAQ,OAAS,EAAA;AACvB,MAAM,MAAA,EAAE,GAAI,EAAA,GAAI,GAAI,CAAA,KAAA;AACpB,MAAA,MAAM,KAAQ,GAAA,iBAAA,CAAkB,GAAI,CAAA,KAAA,CAAM,IAAI,CAAA;AAE9C,MAAA,OAAO,CAAC,GAAO,IAAA,KAAA,CAAM,SAAS,MAC1B,GAAA,KAAA,GACA,MAAM,CACJ,GAAA;AAAA,QACE,IAAM,EAAA,OAAA;AAAA,QACN,KAAA;AAAA,QACA,GAAA,EAAK,IAAI,KAAM,CAAA;AAAA,OAEjB,GAAA,KAAA;AAAA;AAGR,IAAI,IAAA,GAAA,CAAI,QAAQ,OAAS,EAAA;AACvB,MAAA,IAAI,GAAI,CAAA,KAAA,CAAM,MAAW,KAAA,CAAA,EAAU,OAAA,KAAA;AAEnC,MAAO,OAAA,GAAA,CAAI,KAAM,CAAA,MAAA,GAAS,CACtB,GAAA,eAAA;AAAA,QACE,IAAI,KAAM,CAAA,GAAA,CAAI,CAAC,CAAM,KAAA,iBAAA,CAAkB,CAAW,CAAC,CAAA;AAAA,QACnD,GAAA,CAAI,MAAM,GAAI,CAAA,CAAC,MAAM,UAAW,CAAA,CAAC,EAAE,IAAI;AAAA,OAEzC,GAAA,iBAAA,CAAkB,GAAI,CAAA,KAAA,CAAM,CAAC,CAAW,CAAA;AAAA;AAG9C,IAAI,IAAA,GAAA,CAAI,QAAQ,WAAa,EAAA;AAC3B,MAAO,OAAA;AAAA,QACL,IAAM,EAAA,WAAA;AAAA,QACN,KAAA,EAAO,IAAI,KAAM,CAAA;AAAA,OACnB;AAAA;AAGF,IAAI,IAAA,GAAA,CAAI,QAAQ,SAAW,EAAA;AACzB,MAAM,MAAA,UAAA,GAAa,iBAAkB,CAAA,GAAA,CAAI,KAAK,CAAA;AAC9C,MAAI,IAAA,UAAA,CAAW,IAAS,KAAA,MAAA,EAAe,OAAA,KAAA;AAEvC,MAAA,MAAM,QAAQ,MAAO,CAAA,UAAA,CAAW,MAAM,KAAM,CAAA,CAAC,CAAC,CAAI,GAAA,EAAA;AAElD,MAAO,OAAA;AAAA,QACL,IAAM,EAAA,SAAA;AAAA,QACN,KAAA;AAAA,QACA,MAAM,UAAW,CAAA;AAAA,OACnB;AAAA;AAIF,IAAO,OAAA;AAAA,MACL,MAAM,GAAI,CAAA;AAAA,KACZ;AAAA,GACD,CAAA;AAED,EAAM,MAAA,aAAA,GAAgB,CACpB,KAC8C,KAAA;AAC9C,IAAA,IAAI,MAAS,GAAA,IAAA;AAEb,IAAA,MAAM,SAA+C,EAAC;AACtD,IAAA,MAAM,YAA+C,EAAC;AAEtD,IAAM,KAAA,CAAA,OAAA,CAAQ,CAAC,CAAA,EAAG,GAAQ,KAAA;AACxB,MAAS,MAAA,GAAA,MAAA,IAAU,CAAC,CAAC,CAAE,CAAA,IAAA;AACvB,MAAM,MAAA,GAAA,GAAM,EAAE,IAAQ,IAAA,GAAA;AACtB,MAAM,MAAA,KAAA,GAAQ,iBAAkB,CAAA,CAAA,CAAE,IAAc,CAAA;AAChD,MAAI,IAAA,KAAA,CAAM,SAAS,MAAQ,EAAA;AACzB,QAAA,MAAA,CAAO,GAAG,CAAI,GAAA,KAAA;AACd,QAAU,SAAA,CAAA,GAAG,IAAI,CAAE,CAAA,IAAA;AAAA;AACrB,KACD,CAAA;AACD,IAAA,OAAO,MACH,GAAA;AAAA,MACE,IAAM,EAAA,QAAA;AAAA,MACN,KAAO,EAAA,MAAA;AAAA,MACP;AAAA,KACF,GACA,gBAAgB,MAAO,CAAA,MAAA,CAAO,MAAM,CAAG,EAAA,MAAA,CAAO,MAAO,CAAA,SAAS,CAAC,CAAA;AAAA,GACrE;AAEA,EAAM,MAAA,eAAA,GAAkB,CACtB,MAAA,EACA,SACkC,KAAA;AAClC,IAAA,IACE,OAAO,KAAM,CAAA,CAAC,MAAM,CAAE,CAAA,EAAA,KAAO,OAAO,CAAC,CAAA,CAAE,EAAE,CAAA,IACzC,UAAU,KAAM,CAAA,CAAC,QAAQ,CAAC,GAAA,CAAI,MAAM,CACpC,EAAA;AACA,MAAM,MAAA,CAAC,KAAK,CAAI,GAAA,MAAA;AAChB,MAAO,OAAA,KAAA,CAAM,IAAS,KAAA,MAAA,GAClB,KACA,GAAA;AAAA,QACE,IAAM,EAAA,OAAA;AAAA,QACN,KAAA,EAAO,OAAO,CAAC,CAAA;AAAA,QACf,KAAK,MAAO,CAAA;AAAA,OACd;AAAA;AAEN,IAAO,OAAA;AAAA,MACL,IAAM,EAAA,OAAA;AAAA,MACN,KAAO,EAAA,MAAA;AAAA,MACP;AAAA,KACF;AAAA,GACF;AAEA,EAAO,OAAA,iBAAA;AACT,CAAA;AAEO,MAAM,iBAAoB,GAAA,CAAC,UAChC,KAAA,kBAAA,CAAmB,UAAU;AAElB,MAAA,WAAA,GAAc,CAAC,QAAwC,KAAA;AAClE,EAAA,MAAM,oBAAoB,kBAAmB,CAAA,QAAA,CAAS,QAAQ,CAAC,EAAE,KAAU,KAAA;AACzE,IAAI,IAAA,GAAA,CAAI,QAAQ,WAAa,EAAA;AAC3B,MAAM,MAAA,iBAAA,GAAoB,qBAAqB,GAAG,CAAA;AAClD,MAAA,IAAI,iBAAmB,EAAA;AACrB,QAAO,OAAA;AAAA,UACL,IAAM,EAAA,MAAA;AAAA,UACN,WAAW,EAAC;AAAA,UACZ,OAAO,MAAO,CAAA,WAAA;AAAA,YACZ,QAAS,CAAA,OAAA,CAAQ,GAAI,CAAA,CAAC,CAAM,KAAA;AAAA,cAC1B,CAAE,CAAA,IAAA;AAAA,cACF,CAAA,CAAE,UAAU,IACR,GAAA,EAAE,GAAG,KAAO,EAAA,GAAA,EAAK,CAAE,CAAA,KAAA,EACnB,GAAA;AAAA,gBACE,IAAM,EAAA,aAAA;AAAA,gBACN,KAAA,EAAO,iBAAkB,CAAA,CAAA,CAAE,MAAM,CAAA;AAAA,gBACjC,KAAK,CAAE,CAAA;AAAA;AACT,aACL;AAAA,WACH;AAAA,UASA,UAAY,EAAA;AAAA,SACd;AAAA;AACF;AAEF,IAAO,OAAA,IAAA;AAAA,GACR,CAAA;AAED,EAAA,SAAS,qBAAqB,GAQ3B,EAAA;AACD,IAAA,MAAM,SACJ,GAAA,GAAA,CAAI,KAAM,CAAA,MAAA,KAAW,KACrB,GAAI,CAAA,KAAA,CAAM,CAAC,CAAA,CAAE,SAAS,OACtB,IAAA,GAAA,CAAI,KAAM,CAAA,CAAC,EAAE,IAAS,KAAA,OAAA;AACxB,IAAI,IAAA,CAAC,WAAkB,OAAA,IAAA;AAEvB,IAAA,MAAM,QAAQ,iBAAkB,CAAA,GAAA,CAAI,KAAM,CAAA,CAAC,EAAE,IAAI,CAAA;AACjD,IAAA,MAAM,QAAQ,iBAAkB,CAAA,GAAA,CAAI,KAAM,CAAA,CAAC,EAAE,IAAI,CAAA;AAEjD,IAAA,OAAO,MAAM,IAAS,KAAA,WAAA,IACpB,MAAM,KAAU,KAAA,IAAA,IAChB,MAAM,IAAS,KAAA,OAAA,IACf,MAAM,KAAM,CAAA,IAAA,KAAS,eACrB,KAAM,CAAA,KAAA,CAAM,UAAU,IACpB,GAAA,CAAA,GAAI,MAAM,GACV,GAAA,IAAA;AAAA;AAGN,EAAA,MAAM,UAAU,MAAM;AACpB,IAAA,IAAI,gBAAgB,QAAU,EAAA;AAC5B,MAAA,OAAO,SAAS,UAAW,CAAA,IAAA;AAAA;AAG7B,IAAA,MAAM,SAAY,GAAA,QAAA,CAAS,MAAO,CAAA,QAAA,CAAS,WAAW,IAAI,CAAA;AAC1D,IAAM,MAAA,IAAA,GAAO,WAAW,MAAO,CAAA,IAAA,CAAK,CAAC,CAAM,KAAA,CAAA,CAAE,SAAS,MAAM,CAAA;AAE5D,IAAA,OAAO,MAAM,IAAQ,IAAA,IAAA;AAAA,GACvB;AAEA,EAAO,OAAA,MAAA,CAAO,OAAO,iBAAmB,EAAA,EAAE,UAAU,IAAM,EAAA,OAAA,IAAW,CAAA;AACvE;;ACzba,MAAA,SAAA,GACX,CACE,EACA,EAAA,eAAA,EAKA,mBAOF,CAAC,KAAA,EAAO,KAAO,EAAA,KAAA,EAAA,GAAU,IAAS,KAAA;AAChC,EAAM,MAAA,EAAE,IAAO,GAAA,KAAA;AACf,EAAA,IAAI,MAAM,GAAI,CAAA,EAAE,GAAU,OAAA,KAAA,CAAM,IAAI,EAAE,CAAA;AAEtC,EAAI,IAAA,KAAA,CAAM,GAAI,CAAA,EAAE,CAAG,EAAA;AACjB,IAAM,MAAA,GAAA,GAAM,gBAAgB,MAAM,KAAA,CAAM,IAAI,EAAE,CAAA,EAAI,KAAO,EAAA,GAAG,IAAI,CAAA;AAChE,IAAM,KAAA,CAAA,GAAA,CAAI,IAAI,GAAG,CAAA;AACjB,IAAO,OAAA,GAAA;AAAA;AAGT,EAAA,KAAA,CAAM,IAAI,EAAE,CAAA;AACZ,EAAA,IAAI,SAAS,EAAG,CAAA,KAAA,EAAO,KAAO,EAAA,KAAA,EAAO,GAAG,IAAI,CAAA;AAC5C,EAAA,KAAA,CAAM,OAAO,EAAE,CAAA;AAEf,EAAI,IAAA,KAAA,CAAM,IAAI,EAAE,CAAA;AACd,IAAS,MAAA,GAAA,cAAA,CAAe,QAAQ,KAAM,CAAA,GAAA,CAAI,EAAE,CAAI,EAAA,KAAA,EAAO,GAAG,IAAI,CAAA;AAEhE,EAAM,KAAA,CAAA,GAAA,CAAI,IAAI,MAAM,CAAA;AACpB,EAAO,OAAA,MAAA;AACT,CAAA;;ACtCF,MAAM,MAAA,GAASC,iBAAM,GAAI,EAAA;AAEzB,MAAM,WAAc,GAAA,CAClB,KACA,EAAA,KAAA,EACA,OACA,UACe,KAAA;AACf,EAAA,IAAI,MAAM,IAAS,KAAA,WAAA,EAAoB,OAAAA,gBAAA,CAAM,MAAM,KAAK,CAAA;AACxD,EAAA,IAAI,KAAM,CAAA,IAAA,KAAS,MAAQ,EAAA,OAAOA,gBAAM,CAAA,KAAA;AACxC,EAAI,IAAA,KAAA,CAAM,IAAS,KAAA,aAAA,EAAsB,OAAA,UAAA;AACzC,EAAA,IAAI,KAAM,CAAA,IAAA,KAAS,aAAe,EAAA,OAAOA,gBAAM,CAAA,UAAA;AAC/C,EAAA,IAAI,MAAM,IAAS,KAAA,SAAA;AACjB,IAAA,OAAO,KAAM,CAAA,KAAA,GAAQA,gBAAM,CAAA,SAAA,GAAYA,gBAAM,CAAA,aAAA;AAC/C,EAAA,IAAI,KAAM,CAAA,IAAA,KAAS,aAAe,EAAA,OAAOA,gBAAM,CAAA,WAAA;AAE/C,EAAA,MAAM,iBAAiB,CAAC,SAAA,KACtB,WAAW,SAAW,EAAA,KAAA,EAAO,OAAO,UAAU,CAAA;AAEhD,EAAM,MAAA,WAAA,GAAc,CAACC,MAAAA,EAAoB,GAAiB,KAAA;AACxD,IAAM,MAAA,UAAA,GAAa,eAAeA,MAAK,CAAA;AACvC,IAAO,OAAA,GAAA,GAAMD,iBAAM,MAAO,CAAA,UAAA,EAAY,GAAG,CAAI,GAAAA,gBAAA,CAAM,OAAO,UAAU,CAAA;AAAA,GACtE;AAEA,EAAM,MAAA,UAAA,GAAa,CAAC,KAClB,KAAAA,gBAAA,CAAM,MAAM,GAAG,KAAA,CAAM,GAAI,CAAA,cAAc,CAAC,CAAA;AAE1C,EAAM,MAAA,WAAA,GAAc,CAAC,KAAqC,KAAA;AACxD,IAAA,MAAMC,SAAQ,MAAO,CAAA,WAAA;AAAA,MACnB,MAAO,CAAA,OAAA,CAAQ,KAAK,CAAA,CAAE,IAAI,CAAC,CAAC,GAAKC,EAAAA,MAAK,MAAM,CAAC,GAAA,EAAK,cAAeA,CAAAA,MAAK,CAAC,CAAC;AAAA,KAC1E;AACA,IAAO,OAAAF,gBAAA,CAAM,OAAOC,MAAK,CAAA;AAAA,GAC3B;AAEA,EACE,IAAA,KAAA,CAAM,IAAS,KAAA,UAAA,IACf,KAAM,CAAA,KAAA,CAAM,SAAS,WACrB,IAAA,KAAA,CAAM,KAAM,CAAA,KAAA,KAAU,IACtB,EAAA;AACA,IAAO,OAAA,MAAA;AAAA;AAGT,EAAI,IAAA,KAAA,CAAM,SAAS,OAAS,EAAA;AAE1B,IAAA,IAAI,MAAM,KAAM,CAAA,IAAA,KAAS,WAAe,IAAA,KAAA,CAAM,MAAM,KAAU,KAAA,IAAA;AAC5D,MAAO,OAAAD,gBAAA,CAAM,GAAI,CAAA,KAAA,CAAM,GAAG,CAAA;AAE5B,IAAA,OAAO,WAAY,CAAA,KAAA,CAAM,KAAO,EAAA,KAAA,CAAM,GAAG,CAAA;AAAA;AAG3C,EAAA,IAAI,MAAM,IAAS,KAAA,UAAA,EAAmB,OAAA,WAAA,CAAY,MAAM,KAAK,CAAA;AAC7D,EAAA,IAAI,MAAM,IAAS,KAAA,OAAA,EAAgB,OAAA,UAAA,CAAW,MAAM,KAAK,CAAA;AACzD,EAAA,IAAI,MAAM,IAAS,KAAA,QAAA,EAAiB,OAAA,WAAA,CAAY,MAAM,KAAK,CAAA;AAE3D,EAAI,IAAA,KAAA,CAAM,SAAS,QAAU,EAAA,OAAOA,iBAAM,MAAO,CAAA,cAAA,CAAe,KAAM,CAAA,KAAK,CAAC,CAAA;AAE5E,EAAA,IAAI,MAAM,IAAS,KAAA,QAAA;AACjB,IAAA,OAAOA,gBAAM,CAAA,MAAA;AAAA,MACX,cAAA,CAAe,KAAM,CAAA,KAAA,CAAM,EAAE,CAAA;AAAA,MAC7B,cAAA,CAAe,KAAM,CAAA,KAAA,CAAM,EAAE;AAAA,KAC/B;AAGF,EAAM,MAAA,YAAA,GAAe,OAAO,MAAO,CAAA,KAAA,CAAM,KAAK,CAAE,CAAA,GAAA,CAAI,CAAC,CAAM,KAAA;AACzD,IAAA,QAAQ,EAAE,IAAM;AAAA,MACd,KAAK,MAAA;AACH,QAAA,OAAOA,gBAAM,CAAA,KAAA;AAAA,MACf,KAAK,aAAA;AACH,QAAO,OAAA,cAAA,CAAe,EAAE,KAAK,CAAA;AAAA,MAC/B,KAAK,OAAA;AACH,QAAO,OAAA,UAAA,CAAW,EAAE,KAAK,CAAA;AAAA,MAC3B,KAAK,QAAA;AACH,QAAO,OAAA,WAAA,CAAY,EAAE,KAAK,CAAA;AAAA,MAC5B,KAAK,OAAA;AACH,QAAA,OAAO,WAAY,CAAA,CAAA,CAAE,KAAO,EAAA,CAAA,CAAE,GAAG,CAAA;AAAA;AACrC,GACD,CAAA;AAED,EAAA,MAAM,QAAQ,MAAO,CAAA,WAAA;AAAA,IACnB,MAAA,CAAO,KAAK,KAAM,CAAA,KAAK,EAAE,GAAI,CAAA,CAAC,KAAK,GAAQ,KAAA;AACzC,MAAA,OAAO,CAAC,GAAA,EAAK,YAAa,CAAA,GAAG,CAAC,CAAA;AAAA,KAC/B;AAAA,GACH;AAEA,EAAM,MAAA,OAAA,GAAU,MAAO,CAAA,MAAA,CAAO,KAAM,CAAA,KAAK,EAAE,GAAI,CAAA,CAAC,CAAM,KAAA,CAAA,CAAE,GAAG,CAAA;AAC3D,EAAA,MAAM,mBAAmB,OAAQ,CAAA,KAAA,CAAM,CAAC,GAAK,EAAA,CAAA,KAAM,QAAQ,CAAC,CAAA;AAE5D,EAAM,MAAA,YAAA,GAAe,mBACjBA,gBAAM,CAAA,OAAA,CAAQ,KAAK,CACnB,GAAAA,gBAAA,CAAM,OAAQ,CAAA,KAAA,EAAO,OAAc,CAAA;AACvC,EAAA,OAAO,MAAM,UACT,GAAA,cAAA,CAAe,YAAc,EAAA,KAAA,CAAM,UAAU,CAC7C,GAAA,YAAA;AACN,CAAA;AACA,MAAM,aAAa,SAAU,CAAA,WAAA,EAAaA,iBAAM,IAAM,EAAA,CAAC,QAAQ,GAAG,CAAA;AAE3D,MAAM,wBAAwB,CACnC,MAAA,EACA,SAAY,GAAAA,gBAAA,CAAM,WACf,KAAA;AACH,EAAM,MAAA,KAAA,uBAAY,GAAI,EAAA;AACtB,EAAM,MAAA,eAAA,GAAkB,CAAC,EAAA,KACvB,UAAW,CAAA,MAAA,CAAO,EAAE,CAAA,EAAG,KAAO,kBAAA,IAAI,GAAI,EAAA,EAAG,SAAS,CAAA;AAEpD,EAAO,OAAA,CAAC,EAAe,KAAA,eAAA,CAAgB,EAAE,CAAA;AAC3C;AAEA,MAAM,cAAA,GAAiB,CAAI,KAAA,EAAiB,IAA2B,KAAA;AACrE,EAAM,MAAA,QAAA,GAAWA,gBAAM,CAAA,KAAA,CAAM,IAAI,CAAA;AACjC,EAAA,OAAOA,gBAAM,CAAA,WAAA;AAAA,IACX,CAAC,KAAa,KAAA,QAAA,CAAS,IAAI,KAAM,CAAA,GAAA,CAAI,KAAK,CAAC,CAAA;AAAA,IAC3C,CAAC,IAAS,KAAA,KAAA,CAAM,IAAI,QAAS,CAAA,GAAA,CAAI,IAAI,CAAC;AAAA,GACxC;AACF,CAAA;;AChHa,MAAA,iBAAA,GAAoB,CAAC,iBAAsC,KAAA;AACtE,EAAM,MAAA,EAAE,UAAa,GAAA,iBAAA;AACrB,EAAI,IAAA,eAAA,GAAkB,sBAAsB,iBAAiB,CAAA;AAE7D,EAAA,MAAM,SAAS,QAAS,CAAA,OAAA,CACrB,IAAK,CAAA,CAAC,MAAM,CAAE,CAAA,IAAA,KAAS,QAAQ,CAAA,EAC9B,UAAU,IAAK,CAAA,CAAC,CAAM,KAAA,CAAA,CAAE,SAAS,YAAY,CAAA;AAEjD,EAAI,IAAA,UAAA;AACJ,EAAA,IAAI,MAAQ,EAAA;AACV,IAAI,IAAA;AACF,MAAA,MAAM,YAAY,eAAgB,CAAA,MAAA,CAAO,IAAI,CAAE,CAAA,GAAA,CAAI,OAAO,KAAK,CAAA;AAC/D,MAAI,IAAA,OAAO,cAAc,QAAU,EAAA;AACjC,QAAa,UAAA,GAAA,SAAA;AACb,QAAkB,eAAA,GAAA,qBAAA;AAAA,UAChB,iBAAA;AAAA,UACAA,gBAAA,CAAM,UAAU,SAAS;AAAA,SAC3B;AAAA;AACF,aACO,CAAG,EAAA;AAAA;AAAC;AAGf,EAAM,MAAA,cAAA,uBAAqB,GAA8C,EAAA;AAEzE,EAAM,MAAA,YAAA,GAAe,CAAC,MAAA,EAAgB,KAAkB,KAAA;AACtD,IAAI,IAAA,aAAA,GAAgB,cAAe,CAAA,GAAA,CAAI,MAAM,CAAA;AAC7C,IAAA,IAAI,CAAC,aAAA;AACH,MAAA,cAAA,CAAe,IAAI,MAAS,EAAA,aAAA,GAAgBA,gBAAM,CAAA,OAAA,CAAQ,MAAM,CAAE,CAAA;AAEpE,IAAA,MAAM,eAAe,QAAS,CAAA,OAAA,CAC3B,IAAK,CAAA,CAAC,MAAM,CAAE,CAAA,IAAA,KAAS,MAAM,CAAA,CAC7B,QAAS,KAAM,CAAA,IAAA,CAAK,CAAC,CAAM,KAAA,CAAA,CAAE,SAAS,KAAK,CAAA;AAE9C,IAAA,MAAM,mBAAsB,GAAA,CAC1B,GACAE,EAAAA,MAAAA,EAAAA,GACG,IACA,KAAA;AACH,MAAM,MAAA,IAAA,GAAO,aAAe,CAAA,GAAG,IAAI,CAAA;AACnC,MAAO,OAAA;AAAA,QACL,IAAA;AAAA,QACA,KAAAA,EAAAA,MAAAA;AAAA,QACA,GAAA;AAAA,QACA,QAAA,EACE,aAAa,QAAa,KAAA,CAAA,GACtBA,OAAM,GAAI,CAAA,YAAA,CAAa,QAAQ,CAC/B,GAAA;AAAA,OACR;AAAA,KACF;AAEA,IAAI,IAAA,YAAA,CAAa,KAAK,GAAQ,KAAA,OAAA;AAC5B,MAAO,OAAA,mBAAA;AAAA,QACL,CAAA;AAAA,QACA,eAAA,CAAgB,YAAa,CAAA,IAAA,CAAK,KAAK,CAAA;AAAA,QACvC;AAAA,OACF;AAEF,IAAA,MAAM,EAAE,GAAK,EAAA,KAAA,EAAO,OAAQ,EAAA,GAAI,aAAa,IAAK,CAAA,KAAA;AAClD,IAAM,MAAA,GAAA,GAAM,gBAAgB,KAAK,CAAA;AACjC,IAAM,MAAA,MAAA,GAAS,QAAQ,GAAI,CAAA,CAAC,MAAMF,gBAAM,CAAA,CAAA,CAAE,GAAG,CAAC,CAAA;AAE9C,IAAA,MAAM,YAA8C,MAAM;AACxD,MAAI,IAAA,MAAA,CAAO,WAAW,CAAG,EAAA;AACvB,QAAO,OAAA,CAAC,CAAC,eAAgB,CAAA,GAAG,GAAG,MAAO,CAAA,CAAC,CAAC,CAAC,CAAA;AAAA;AAG3C,MAAM,MAAA,MAAA,GAAS,kBAAkB,GAAG,CAAA;AAEpC,MAAA,QAAQ,OAAO,IAAM;AAAA,QACnB,KAAK,OAAA;AACH,UAAO,OAAA,MAAA,CAAO,GAAI,CAAA,CAAC,IAAS,KAAA,CAAC,eAAgB,CAAA,MAAA,CAAO,KAAM,CAAA,EAAE,CAAG,EAAA,IAAI,CAAC,CAAA;AAAA,QACtE,KAAK,OAAA;AACH,UAAA,OAAO,MAAO,CAAA,KAAA,CAAM,GAAI,CAAA,CAAC,GAAG,GAAQ,KAAA;AAAA,YAClC,eAAA,CAAgB,EAAE,EAAE,CAAA;AAAA,YACpB,OAAO,GAAG;AAAA,WACX,CAAA;AAAA,QACH;AACE,UAAM,MAAA,IAAI,MAAM,kBAAkB,CAAA;AAAA;AACtC,KACC,GAAA;AAEH,IAAA,OAAO,oBAAoB,MAAO,CAAA,MAAA,EAAQ,GAAK,EAAA,KAAA,EAAO,GAAG,QAAQ,CAAA;AAAA,GACnE;AAEA,EAAM,MAAA,cAAA,GAAiB,CACrB,KACe,KAAA;AACf,IAAA,QAAQ,MAAM,IAAM;AAAA,MAClB,KAAK,MAAA;AACH,QAAA,OAAOA,gBAAM,CAAA,KAAA;AAAA,MACf,KAAK,aAAA;AACH,QAAO,OAAA,eAAA,CAAgB,KAAM,CAAA,KAAA,CAAM,EAAE,CAAA;AAAA,MACvC,KAAK,OAAA;AACH,QAAA,OAAOA,gBAAM,CAAA,KAAA;AAAA,UACX,GAAG,MAAA,CAAO,MAAO,CAAA,KAAA,CAAM,KAAK,CAAA,CAAE,GAAI,CAAA,CAAC,CAAM,KAAA,eAAA,CAAgB,CAAE,CAAA,EAAE,CAAC;AAAA,SAChE;AAAA,MACF,KAAK,QAAA;AACH,QAAA,OAAOA,gBAAM,CAAA,MAAA;AAAA,UACXG,eAAA,CAAU,MAAM,KAAO,EAAA,CAAC,MAAM,eAAgB,CAAA,CAAA,CAAE,EAAE,CAAC;AAAA,SAGrD;AAAA,MACF,KAAK,OAAA;AACH,QAAO,OAAAH,gBAAA,CAAM,OAAO,eAAgB,CAAA,KAAA,CAAM,MAAM,EAAE,CAAA,EAAG,MAAM,GAAG,CAAA;AAAA;AAClE,GACF;AAEA,EAAM,MAAA,aAAA,GAAgB,CAAC,MAAA,EAAgB,YAAyB,KAAA;AAC9D,IAAA,MAAM,eAAe,QAAS,CAAA,OAAA,CAC3B,IAAK,CAAA,CAAC,MAAM,CAAE,CAAA,IAAA,KAAS,MAAM,CAAA,CAC7B,UAAW,IAAK,CAAA,CAAC,CAAM,KAAA,CAAA,CAAE,SAAS,YAAY,CAAA;AAEjD,IAAO,OAAA,eAAA,CAAgB,aAAa,IAAc,CAAA;AAAA,GACpD;AAEA,EAAA,MAAM,YACJ,GAAA,CAAC,IACD,KAAA,CACE,QACA,IAIG,KAAA;AACH,IAAM,MAAA,WAAA,GAAc,SAAS,OAAQ,CAAA,IAAA,CAAK,CAAC,CAAM,KAAA,CAAA,CAAE,SAAS,MAAM,CAAA;AAClE,IAAA,MAAM,MAAS,GAAA,iBAAA,CAAkB,WAAY,CAAA,IAAI,CAAE,CAAA;AACnD,IAAI,IAAA,MAAA,CAAO,IAAS,KAAA,MAAA,EAAc,MAAA,IAAA;AAClC,IAAM,MAAA,KAAA,GAAQ,MAAO,CAAA,KAAA,CAAM,IAAI,CAAA;AAE/B,IAAO,OAAA;AAAA,MACL,QAAU,EAAA,CAAC,WAAY,CAAA,KAAA,EAAO,MAAM,GAAG,CAAA;AAAA,MACvC,KAAO,EAAA,cAAA,CAAe,MAAO,CAAA,KAAA,CAAM,IAAI,CAAC;AAAA,KAC1C;AAAA,GACF;AAEF,EAAM,MAAA,gBAAA,GAAmB,CAAC,GAAA,EAAa,MAAmB,KAAA;AACxD,IAAA,MAAM,QAAQ,QAAS,CAAA,IAAA,CACpB,IAAK,CAAA,CAAC,MAAM,CAAE,CAAA,IAAA,KAAS,GAAG,CAAA,EACzB,QAAQ,IAAK,CAAA,CAAC,CAAM,KAAA,CAAA,CAAE,SAAS,MAAM,CAAA;AACzC,IAAI,IAAA,CAAC,OAAa,MAAA,IAAA;AAElB,IAAO,OAAA;AAAA,MACL,IAAM,EAAAA,gBAAA,CAAM,KAAM,CAAA,GAAG,KAAM,CAAA,MAAA,CAAO,GAAI,CAAA,CAAC,CAAM,KAAA,eAAA,CAAgB,CAAE,CAAA,IAAI,CAAC,CAAC,CAAA;AAAA,MACrE,KAAA,EAAO,eAAgB,CAAA,KAAA,CAAM,MAAM;AAAA,KACrC;AAAA,GACF;AAEA,EAAO,OAAA;AAAA,IACL,eAAA;AAAA,IACA,YAAA;AAAA,IACA,UAAA,EAAY,aAAa,QAAQ,CAAA;AAAA,IACjC,UAAA,EAAY,aAAa,QAAQ,CAAA;AAAA,IACjC,gBAAA;AAAA,IACA,SAAA,EAAW,aAAa,OAAO,CAAA;AAAA,IAC/B,aAAA;AAAA,IACA;AAAA,GACF;AACF;;AC5JgB,SAAA,gBAAA,CACd,UACA,YACa,EAAA;AACb,EAAM,MAAA,MAAA,uBAA0B,GAAI,EAAA;AACpC,EAAM,MAAA,OAAA,uBAAc,GAAY,EAAA;AAEhC,EAAM,MAAA,OAAA,GAAU,CAAC,IAAA,EAAc,EAAe,KAAA;AAC5C,IAAI,IAAA,CAAC,MAAO,CAAA,GAAA,CAAI,IAAI,CAAA;AAClB,MAAA,MAAA,CAAO,IAAI,IAAM,EAAA;AAAA,QACf,KAAA,EAAO,SAAS,IAAI,CAAA;AAAA,QACpB,QAAA,sBAAc,GAAI,EAAA;AAAA,QAClB,IAAA,sBAAU,GAAI;AAAA,OACf,CAAA;AACH,IAAI,IAAA,CAAC,MAAO,CAAA,GAAA,CAAI,EAAE,CAAA;AAChB,MAAA,MAAA,CAAO,IAAI,EAAI,EAAA;AAAA,QACb,KAAA,EAAO,SAAS,EAAE,CAAA;AAAA,QAClB,QAAA,sBAAc,GAAI,EAAA;AAAA,QAClB,IAAA,sBAAU,GAAI;AAAA,OACf,CAAA;AACH,IAAA,MAAA,CAAO,GAAI,CAAA,IAAI,CAAG,CAAA,IAAA,CAAK,IAAI,EAAE,CAAA;AAC7B,IAAA,MAAA,CAAO,GAAI,CAAA,EAAE,CAAG,CAAA,QAAA,CAAS,IAAI,IAAI,CAAA;AAAA,GACnC;AAEA,EAAA,KAAA,IAAS,CAAI,GAAA,CAAA,EAAG,CAAI,GAAA,YAAA,EAAc,CAAK,EAAA,EAAA;AACrC,IAAM,MAAA,KAAA,GAAQ,SAAS,CAAC,CAAA;AACxB,IAAI,IAAA,CAAA,KAAM,MAAM,EAAI,EAAA;AAGlB,MAAQ,OAAA,CAAA,CAAA,EAAG,MAAM,EAAE,CAAA;AAAA;AAErB,IAAA,IAAI,OAAQ,CAAA,GAAA,CAAI,KAAM,CAAA,EAAE,CAAG,EAAA;AAC3B,IAAQ,OAAA,CAAA,GAAA,CAAI,MAAM,EAAE,CAAA;AAEpB,IAAA,QAAQ,MAAM,IAAM;AAAA,MAClB,KAAK,OAAA;AAAA,MACL,KAAK,QAAA;AAAA,MACL,KAAK,UAAA;AACH,QAAA,OAAA,CAAQ,KAAM,CAAA,EAAA,EAAI,KAAM,CAAA,KAAA,CAAM,EAAE,CAAA;AAChC,QAAA;AAAA,MACF,KAAK,MAAA;AACH,QAAA,MAAA,CAAO,OAAO,KAAM,CAAA,KAAK,CAAE,CAAA,OAAA,CAAQ,CAAC,SAAc,KAAA;AAChD,UAAA,QAAQ,UAAU,IAAM;AAAA,YACtB,KAAK,OAAA;AAAA,YACL,KAAK,aAAA;AACH,cAAA,OAAA,CAAQ,KAAM,CAAA,EAAA,EAAI,SAAU,CAAA,KAAA,CAAM,EAAE,CAAA;AACpC,cAAA;AAAA,YACF,KAAK,QAAA;AAAA,YACL,KAAK,OAAA;AACH,cAAO,MAAA,CAAA,MAAA,CAAO,SAAU,CAAA,KAAK,CAAE,CAAA,OAAA;AAAA,gBAAQ,CAAC,CACtC,KAAA,OAAA,CAAQ,KAAM,CAAA,EAAA,EAAI,EAAE,EAAE;AAAA,eACxB;AACA,cAAA;AAAA;AACJ,SACD,CAAA;AACD,QAAA;AAAA,MACF,KAAK,QAAA;AACH,QAAA,OAAA,CAAQ,KAAM,CAAA,EAAA,EAAI,KAAM,CAAA,KAAA,CAAM,GAAG,EAAE,CAAA;AACnC,QAAA,OAAA,CAAQ,KAAM,CAAA,EAAA,EAAI,KAAM,CAAA,KAAA,CAAM,GAAG,EAAE,CAAA;AACnC,QAAA;AAAA,MACF,KAAK,QAAA;AAAA,MACL,KAAK,OAAA;AACH,QAAA,MAAA,CAAO,MAAO,CAAA,KAAA,CAAM,KAAK,CAAA,CAAE,OAAQ,CAAA,CAAC,CAAM,KAAA,OAAA,CAAQ,KAAM,CAAA,EAAA,EAAI,CAAE,CAAA,EAAE,CAAC,CAAA;AACjE,QAAA;AAAA;AAKJ,IAAA,IAAI,CAAC,MAAA,CAAO,GAAI,CAAA,KAAA,CAAM,EAAE,CAAG,EAAA;AACzB,MAAO,MAAA,CAAA,GAAA,CAAI,MAAM,EAAI,EAAA;AAAA,QACnB,QAAA,sBAAc,GAAI,EAAA;AAAA,QAClB,IAAA,sBAAU,GAAI,EAAA;AAAA,QACd;AAAA,OACD,CAAA;AAAA;AACH;AAGF,EAAO,OAAA,MAAA;AACT;AAEA,MAAM,aAAA,uBAAoB,OAA+C,EAAA;AACzE,SAAS,YACP,CAAA,EAAA,EACA,KACA,EAAA,MAAA,EACA,KACA,EAAA;AACA,EAAI,IAAA,MAAA,CAAO,GAAI,CAAA,EAAE,CAAG,EAAA;AACpB,EAAM,MAAA,IAAA,GAAO,KAAM,CAAA,GAAA,CAAI,EAAE,CAAA;AACzB,EAAO,MAAA,CAAA,GAAA,CAAI,IAAI,IAAI,CAAA;AACnB,EAAM,KAAA,CAAA,GAAA,CAAI,IAAI,MAAM,CAAA;AAEpB,EAAK,IAAA,CAAA,IAAA,CAAK,QAAQ,CAAC,GAAA,KAAQ,aAAa,GAAK,EAAA,KAAA,EAAO,MAAQ,EAAA,KAAK,CAAC,CAAA;AAClE,EAAK,IAAA,CAAA,QAAA,CAAS,QAAQ,CAAC,GAAA,KAAQ,aAAa,GAAK,EAAA,KAAA,EAAO,MAAQ,EAAA,KAAK,CAAC,CAAA;AACxE;AAEgB,SAAA,WAAA,CAAY,IAAY,KAAoB,EAAA;AAC1D,EAAA,IAAI,CAAC,aAAA,CAAc,GAAI,CAAA,KAAK,CAAG,EAAA;AAC7B,IAAA,aAAA,CAAc,GAAI,CAAA,KAAA,kBAAW,IAAA,GAAA,EAAK,CAAA;AAAA;AAEpC,EAAM,MAAA,KAAA,GAAQ,aAAc,CAAA,GAAA,CAAI,KAAK,CAAA;AACrC,EAAA,IAAI,MAAM,GAAI,CAAA,EAAE,GAAU,OAAA,KAAA,CAAM,IAAI,EAAE,CAAA;AAEtC,EAAM,MAAA,MAAA,uBAA0B,GAAI,EAAA;AACpC,EAAa,YAAA,CAAA,EAAA,EAAI,KAAO,EAAA,MAAA,EAAQ,KAAK,CAAA;AACrC,EAAO,OAAA,MAAA;AACT;AAEO,SAAS,+BAA+B,KAAoB,EAAA;AAEjE,EAAM,MAAA,WAAA,uBAAkB,GAOtB,EAAA;AACF,EAAA,IAAI,KAAQ,GAAA,CAAA;AACZ,EAAA,MAAM,QAAkB,EAAC;AACzB,EAAA,MAAM,SAA6B,EAAC;AAEpC,EAAA,SAAS,cAAc,CAAiB,EAAA;AACtC,IAAA,MAAM,KAAQ,GAAA;AAAA,MACZ,KAAA;AAAA,MACA,OAAS,EAAA,KAAA;AAAA,MACT,OAAS,EAAA;AAAA,KACX;AACA,IAAY,WAAA,CAAA,GAAA,CAAI,GAAG,KAAK,CAAA;AACxB,IAAA,KAAA,EAAA;AACA,IAAA,KAAA,CAAM,KAAK,CAAC,CAAA;AAEZ,IAAA,MAAM,KAAQ,GAAA,KAAA,CAAM,GAAI,CAAA,CAAC,CAAG,CAAA,IAAA;AAC5B,IAAA,KAAA,IAAS,KAAK,KAAO,EAAA;AACnB,MAAM,MAAA,SAAA,GAAY,WAAY,CAAA,GAAA,CAAI,CAAC,CAAA;AACnC,MAAA,IAAI,CAAC,SAAW,EAAA;AACd,QAAA,aAAA,CAAc,CAAC,CAAA;AACf,QAAM,KAAA,CAAA,OAAA,GAAU,KAAK,GAAI,CAAA,KAAA,CAAM,SAAS,WAAY,CAAA,GAAA,CAAI,CAAC,CAAA,CAAG,OAAO,CAAA;AAAA,OACrE,MAAA,IAAW,UAAU,OAAS,EAAA;AAC5B,QAAA,KAAA,CAAM,UAAU,IAAK,CAAA,GAAA,CAAI,KAAM,CAAA,OAAA,EAAS,UAAU,KAAK,CAAA;AAAA;AACzD;AAGF,IAAI,IAAA,KAAA,CAAM,OAAY,KAAA,KAAA,CAAM,KAAO,EAAA;AACjC,MAAM,MAAA,SAAA,uBAAgB,GAAY,EAAA;AAElC,MAAA,IAAI,UAAa,GAAA,EAAA;AACjB,MAAG,GAAA;AACD,QAAA,UAAA,GAAa,MAAM,GAAI,EAAA;AACvB,QAAY,WAAA,CAAA,GAAA,CAAI,UAAU,CAAA,CAAG,OAAU,GAAA,KAAA;AACvC,QAAA,SAAA,CAAU,IAAI,UAAU,CAAA;AAAA,eACjB,UAAe,KAAA,CAAA;AAExB,MAAA,MAAA,CAAO,KAAK,SAAS,CAAA;AAAA;AACvB;AAGF,EAAW,KAAA,MAAA,IAAA,IAAQ,KAAM,CAAA,IAAA,EAAQ,EAAA;AAC/B,IAAA,IAAI,CAAC,WAAA,CAAY,GAAI,CAAA,IAAI,CAAG,EAAA;AAC1B,MAAA,aAAA,CAAc,IAAI,CAAA;AAAA;AACpB;AAGF,EAAO,OAAA,MAAA;AACT;AAEO,SAAS,yBACd,2BACA,EAAA;AAOA,EAAA,MAAM,GAAM,GAAA,2BAAA;AACZ,EAAM,MAAA,eAAA,GAAkB,IAAI,GAAI,CAAA,GAAA,CAAI,IAAI,CAAC,CAAA,EAAG,CAAM,KAAA,CAAC,CAAC,CAAA;AACpD,EAAA,MAAM,KAAQ,GAAA,IAAI,GAAI,CAAA,GAAA,CAAI,IAAI,CAAC,CAAA,EAAG,CAAM,KAAA,CAAC,CAAG,kBAAA,IAAI,GAAY,EAAC,CAAC,CAAC,CAAA;AAC/D,EAAI,GAAA,CAAA,OAAA,CAAQ,CAAC,KAAA,EAAO,CAAM,KAAA;AACxB,IAAA,GAAA,CAAI,MAAM,CAAI,GAAA,CAAC,EAAE,OAAQ,CAAA,CAAC,YAAY,EAAO,KAAA;AAC3C,MAAM,MAAA,CAAA,GAAI,KAAK,CAAI,GAAA,CAAA;AACnB,MAAM,MAAA,QAAA,uBAAe,GAAI,CAAA,CAAC,GAAG,KAAO,EAAA,GAAG,UAAU,CAAC,CAAA;AAClD,MAAA,IAAI,QAAS,CAAA,IAAA,KAAS,KAAM,CAAA,IAAA,GAAO,WAAW,IAAM,EAAA;AAClD,QAAA,KAAA,CAAM,GAAI,CAAA,CAAC,CAAG,CAAA,GAAA,CAAI,CAAC,CAAA;AACnB,QAAA,KAAA,CAAM,GAAI,CAAA,CAAC,CAAG,CAAA,GAAA,CAAI,CAAC,CAAA;AAAA;AACrB,KACD,CAAA;AAAA,GACF,CAAA;AACD,EAAA,MAAM,SAA6B,EAAC;AAEpC,EAAA,OAAO,gBAAgB,IAAM,EAAA;AAC3B,IAAM,MAAA,KAAA,uBAAY,GAAY,EAAA;AAC9B,IAAA,MAAM,UAAU,CAAC,eAAA,CAAgB,QAAS,CAAA,IAAA,GAAO,KAAM,CAAA;AACvD,IAAA,OAAO,QAAQ,MAAQ,EAAA;AACrB,MAAM,MAAA,GAAA,GAAM,QAAQ,GAAI,EAAA;AACxB,MAAA,IAAI,CAAC,eAAA,CAAgB,GAAI,CAAA,GAAG,CAAG,EAAA;AAC/B,MAAA,eAAA,CAAgB,OAAO,GAAG,CAAA;AAE1B,MAAM,MAAA,KAAA,GAAQ,IAAI,GAAG,CAAA;AACrB,MAAM,KAAA,CAAA,OAAA,CAAQ,CAAC,CAAM,KAAA,KAAA,CAAM,IAAI,MAAO,CAAA,CAAC,CAAC,CAAC,CAAA;AACzC,MAAM,KAAA,CAAA,GAAA,CAAI,GAAG,CAAG,CAAA,OAAA,CAAQ,CAAC,CAAM,KAAA,OAAA,CAAQ,IAAK,CAAA,CAAC,CAAC,CAAA;AAAA;AAEhD,IAAA,MAAA,CAAO,KAAK,KAAK,CAAA;AAAA;AAGnB,EAAO,OAAA,MAAA;AACT;;AClMA,MAAM,WAAA,GAAc,IAAI,WAAY,EAAA;AACpC,MAAM,UAAa,GAAA,WAAA,CAAY,MAAO,CAAA,IAAA,CAAK,WAAW,CAAA;AAEtD,MAAM,WAAA,GAAc,CAAC,MAA0B,KAAA;AAC7C,EAAA,MAAM,GAAM,GAAA,IAAI,UAAW,CAAA,MAAA,CAAO,SAAS,CAAC,CAAA;AAC5C,EAAA,MAAM,EAAK,GAAA,IAAI,QAAS,CAAA,GAAA,CAAI,MAAM,CAAA;AAElC,EAAA,KAAA,IAAS,CAAI,GAAA,CAAA,EAAG,CAAI,GAAA,MAAA,CAAO,MAAQ,EAAA,CAAA,EAAA,EAAQ,EAAA,CAAA,YAAA,CAAa,CAAI,GAAA,CAAA,EAAG,MAAO,CAAA,CAAC,CAAC,CAAA;AAExE,EAAA,OAAOI,UAAI,GAAG,CAAA;AAChB,CAAA;AACA,MAAM,iBAAoB,GAAA,CAAC,MACzB,KAAA,WAAA,CAAY,MAAO,CAAA,GAAA,CAAI,CAAC,CAAA,KAAMA,SAAI,CAAA,UAAA,CAAW,CAAC,CAAC,CAAC,CAAC,CAAA;AAWnD,MAAM,QAAkC,GAAA;AAAA,EACtC,SAAW,EAAA,EAAA;AAAA,EACX,MAAQ,EAAA,EAAA;AAAA,EACR,KAAO,EAAA,EAAA;AAAA,EACP,MAAQ,EAAA,EAAA;AAAA,EACR,MAAQ,EAAA,EAAA;AAAA,EACR,MAAQ,EAAA,EAAA;AAAA,EACR,IAAM,EAAA,EAAA;AAAA,EACN,IAAM,EAAA;AACR,CAAA;AAaA,MAAM,mBAAyD,GAAA;AAAA,EAC7D,SAAW,EAAA,EAAA;AAAA,EACX,MAAQ,EAAA,EAAA;AAAA,EACR,MAAQ,EAAA,EAAA;AAAA,EACR,MAAQ,EAAA,EAAA;AAAA,EACR,OAAS,EAAA,EAAA;AAAA,EACT,WAAa,EAAA,EAAA;AAAA;AAAA,EACb,YAAc,EAAA,EAAA;AAAA;AAAA,EACd,WAAa,EAAA,EAAA;AAAA;AAAA,EACb,WAAa,EAAA;AAAA;AACf,CAAA;AAEA,MAAM,oBAA2D,GAAA;AAAA,EAC/D,MAAM,mBAAoB,CAAA,OAAA;AAAA,EAC1B,MAAM,mBAAoB,CAAA,MAAA;AAAA,EAC1B,KAAK,mBAAoB,CAAA,MAAA;AAAA,EACzB,IAAI,mBAAoB,CAAA,MAAA;AAAA,EACxB,KAAK,mBAAoB,CAAA,MAAA;AAAA,EACzB,KAAK,mBAAoB,CAAA,MAAA;AAAA,EACzB,KAAK,mBAAoB,CAAA,MAAA;AAAA,EACzB,MAAM,mBAAoB,CAAA,MAAA;AAAA,EAC1B,MAAM,mBAAoB,CAAA,MAAA;AAAA,EAC1B,IAAI,mBAAoB,CAAA,MAAA;AAAA,EACxB,KAAK,mBAAoB,CAAA,MAAA;AAAA,EACzB,KAAK,mBAAoB,CAAA,MAAA;AAAA,EACzB,KAAK,mBAAoB,CAAA,MAAA;AAAA,EACzB,MAAM,mBAAoB,CAAA,MAAA;AAAA,EAC1B,MAAM,mBAAoB,CAAA;AAC5B,CAAA;AAEA,MAAM,iBAAoB,GAAA,CACxB,OACA,EAAA,KAAA,EACA,aACG,KAAA;AACH,EAAA,MAAM,aAAgB,GAAA,MAAA,CAAO,OAAQ,CAAA,KAAK,CAAE,CAAA,IAAA;AAAA,IAAK,CAAC,CAAC,CAAC,CAAA,EAAG,CAAC,CAAC,CAAA,KACvD,CAAE,CAAA,aAAA,CAAc,CAAC;AAAA,GACnB;AACA,EAAM,MAAA,YAAA,GAAe,kBAAkB,aAAc,CAAA,GAAA,CAAI,CAAC,CAAC,GAAG,CAAM,KAAA,GAAG,CAAC,CAAA;AACxE,EAAA,MAAM,cAAiB,GAAA,WAAA;AAAA,IACrB,aAAA,CAAc,IAAI,CAAC,GAAG,KAAK,CAAA,KAAM,aAAc,CAAA,KAAK,CAAC;AAAA,GACvD;AAEA,EAAA,OAAO,WAAY,CAAA,CAAC,OAAS,EAAA,YAAA,EAAc,cAAc,CAAC,CAAA;AAC5D,CAAA;AAEA,MAAM,cAAA,GAAiB,CACrB,KAAA,EACA,iBACW,KAAA;AACX,EAAA,IAAI,MAAM,IAAS,KAAA,WAAA;AACjB,IAAO,OAAA,WAAA,CAAY,CAAC,QAAS,CAAA,SAAA,EAAW,qBAAqB,KAAM,CAAA,KAAK,CAAC,CAAC,CAAA;AAE5E,EAAI,IAAA,KAAA,CAAM,SAAS,MAAQ,EAAA,OAAO,YAAY,CAAC,QAAA,CAAS,IAAI,CAAC,CAAA;AAE7D,EAAA,IAAI,MAAM,IAAS,KAAA,SAAA;AACjB,IAAA,OAAO,WAAY,CAAA;AAAA,MACjB,QAAS,CAAA,SAAA;AAAA,MACT,mBAAoB,CAAA,KAAA,CAAM,KAAQ,GAAA,QAAA,GAAW,QAAQ;AAAA,KACtD,CAAA;AAEH,EAAA,IAAI,MAAM,IAAS,KAAA,aAAA;AACjB,IAAA,OAAO,YAAY,CAAC,QAAA,CAAS,SAAW,EAAA,mBAAA,CAAoB,WAAW,CAAC,CAAA;AAE1E,EAAI,IAAA,KAAA,CAAM,SAAS,aAAe,EAAA;AAChC,IAAA,OAAO,YAAY,CAAC,QAAA,CAAS,SAAW,EAAA,mBAAA,CAAoB,WAAW,CAAC,CAAA;AAAA;AAG1E,EAAI,IAAA,KAAA,CAAM,SAAS,aAAe,EAAA;AAChC,IAAA,OAAO,YAAY,CAAC,QAAA,CAAS,SAAW,EAAA,mBAAA,CAAoB,WAAW,CAAC,CAAA;AAAA;AAG1E,EAAM,MAAA,WAAA,GAAc,CAAC,KAAA,EAAoB,MAAoB,KAAA;AAC3D,IAAM,MAAA,aAAA,GAAgB,kBAAkB,KAAK,CAAA;AAC7C,IAAO,OAAA,WAAA;AAAA,MACL,MAAW,KAAA,MAAA,GACP,CAAC,QAAA,CAAS,MAAQ,EAAA,aAAA,EAAe,MAAO,CAAA,MAAM,CAAC,CAAA,GAC/C,CAAC,QAAA,CAAS,QAAQ,aAAa;AAAA,KACrC;AAAA,GACF;AAEA,EAAI,IAAA,KAAA,CAAM,SAAS,OAAS,EAAA;AAC1B,IAAA,MAAM,aAAa,KAAM,CAAA,KAAA;AACzB,IAAA,IAAI,UAAW,CAAA,IAAA,KAAS,WAAe,IAAA,UAAA,CAAW,UAAU,IAAM,EAAA;AAChE,MAAA,OAAO,WAAY,CAAA;AAAA,QACjB,QAAS,CAAA,SAAA;AAAA,QACT,mBAAoB,CAAA,YAAA;AAAA,QACpB,MAAA,CAAO,MAAM,GAAG;AAAA,OACjB,CAAA;AAAA;AAEH,IAAO,OAAA,WAAA,CAAY,UAAY,EAAA,KAAA,CAAM,GAAG,CAAA;AAAA;AAG1C,EAAI,IAAA,KAAA,CAAM,SAAS,UAAY,EAAA;AAC7B,IAAA,MAAM,aAAa,KAAM,CAAA,KAAA;AACzB,IAAA,IAAI,UAAW,CAAA,IAAA,KAAS,WAAe,IAAA,UAAA,CAAW,UAAU,IAAM,EAAA;AAChE,MAAA,OAAO,YAAY,CAAC,QAAA,CAAS,SAAW,EAAA,mBAAA,CAAoB,YAAY,CAAC,CAAA;AAAA;AAE3E,IAAA,OAAO,YAAY,UAAU,CAAA;AAAA;AAG/B,EAAA,MAAM,UAAa,GAAA,CAAC,OAClB,KAAA,WAAA,CAAY,CAAC,QAAA,CAAS,KAAO,EAAA,GAAG,OAAQ,CAAA,GAAA,CAAI,iBAAiB,CAAC,CAAC,CAAA;AAEjE,EAAA,MAAM,cAAc,CAAC,OAAA,KACnB,kBAAkB,QAAS,CAAA,MAAA,EAAQ,SAAS,iBAAiB,CAAA;AAE/D,EAAA,IAAI,MAAM,IAAS,KAAA,OAAA,EAAgB,OAAA,UAAA,CAAW,MAAM,KAAK,CAAA;AAEzD,EAAA,IAAI,MAAM,IAAS,KAAA,QAAA,EAAiB,OAAA,WAAA,CAAY,MAAM,KAAK,CAAA;AAE3D,EAAA,IAAI,MAAM,IAAS,KAAA,QAAA;AACjB,IAAO,OAAA,WAAA,CAAY,CAAC,QAAS,CAAA,MAAA,EAAQ,kBAAkB,KAAM,CAAA,KAAK,CAAC,CAAC,CAAA;AAEtE,EAAA,IAAI,MAAM,IAAS,KAAA,QAAA;AACjB,IAAA,OAAO,WAAY,CAAA;AAAA,MACjB,QAAS,CAAA,MAAA;AAAA,MACT,iBAAA,CAAkB,KAAM,CAAA,KAAA,CAAM,EAAE,CAAA;AAAA,MAChC,iBAAA,CAAkB,KAAM,CAAA,KAAA,CAAM,EAAE;AAAA,KACjC,CAAA;AAEH,EAAA,OAAO,kBAAkB,QAAS,CAAA,IAAA,EAAM,KAAM,CAAA,KAAA,EAAO,CAAC,KAAU,KAAA;AAC9D,IAAA,IAAI,MAAM,IAAS,KAAA,aAAA,EAAsB,OAAA,iBAAA,CAAkB,MAAM,KAAK,CAAA;AACtE,IAAA,QAAQ,MAAM,IAAM;AAAA,MAClB,KAAK,MAAA;AACH,QAAA,OAAO,WAAY,CAAA,CAAC,QAAS,CAAA,IAAI,CAAC,CAAA;AAAA,MACpC,KAAK,OAAA;AACH,QAAO,OAAA,UAAA,CAAW,MAAM,KAAK,CAAA;AAAA,MAC/B,KAAK,QAAA;AACH,QAAO,OAAA,WAAA,CAAY,MAAM,KAAK,CAAA;AAAA,MAChC,KAAK,OAAA;AACH,QAAA,OAAO,WAAY,CAAA,KAAA,CAAM,KAAO,EAAA,KAAA,CAAM,GAAG,CAAA;AAAA;AAC7C,GACD,CAAA;AACH,CAAA;AAEA,MAAM,gBAAA,GAAmB,CAAC,MAAA,EAA4B,KAAuB,KAAA;AAC3E,EAAM,MAAA,iBAAA,GAAoB,CAAC,KAAuB,KAAA;AAChD,IAAMC,MAAAA,OAAAA,uBAAa,GAAY,EAAA;AAC/B,IAAM,MAAA,OAAA,GAAU,KAAM,CAAA,IAAA,CAAK,KAAK,CAAA;AAChC,IAAA,OAAO,QAAQ,MAAQ,EAAA;AACrB,MAAM,MAAA,EAAA,GAAK,QAAQ,GAAI,EAAA;AACvB,MAAIA,IAAAA,OAAAA,CAAO,GAAI,CAAA,EAAE,CAAG,EAAA;AACpB,MAAAA,OAAAA,CAAO,IAAI,EAAE,CAAA;AAEb,MAAM,KAAA,CAAA,GAAA,CAAI,EAAE,CAAA,EAAG,IAAK,CAAA,OAAA,CAAQ,CAACC,GAAO,KAAA,OAAA,CAAQ,IAAKA,CAAAA,GAAE,CAAC,CAAA;AAAA;AAGtD,IAAO,OAAA,KAAA,CAAM,KAAKD,OAAM,CAAA;AAAA,GAC1B;AAEA,EAAM,MAAA,MAAA,GAA6B,IAAI,KAAM,EAAA;AAE7C,EAAA,SAAS,gBAAgB,KAAoB,EAAA;AAC3C,IAAI,IAAA,MAAA,CAAO,QAAS,CAAA,KAAK,CAAG,EAAA;AAC5B,IAAA,MAAM,aAAa,MAAO,CAAA,MAAA;AAAA,MACxB,CAAC,SAAA,KACC,SAAc,KAAA,KAAA,IACd,iBAAkB,CAAA,KAAK,CAAE,CAAA,IAAA,CAAK,CAAC,IAAA,KAAS,SAAU,CAAA,GAAA,CAAI,IAAI,CAAC;AAAA,KAC/D;AACA,IAAA,UAAA,CAAW,OAAQ,CAAA,CAACE,MAAU,KAAA,eAAA,CAAgBA,MAAK,CAAC,CAAA;AACpD,IAAI,IAAA,MAAA,CAAO,QAAS,CAAA,KAAK,CAAG,EAAA;AAC5B,IAAA,MAAA,CAAO,KAAK,KAAK,CAAA;AAAA;AAGnB,EAAA,MAAA,CAAO,OAAQ,CAAA,CAAC,KAAU,KAAA,eAAA,CAAgB,KAAK,CAAC,CAAA;AAChD,EAAO,OAAA,MAAA;AACT,CAAA;AAEA,SAAS,gBACP,CAAA,KAAA,EACA,UACA,EAAA,KAAA,EACA,KACA,EAAA;AAIA,EAAA,MAAM,cAAiB,GAAA,IAAI,GAAI,CAAA,CAAC,GAAG,KAAK,CAAA,CAAE,GAAI,CAAA,CAAC,EAAO,KAAA,CAAC,EAAI,EAAA,EAAE,CAAC,CAAC,CAAA;AAC/D,EAAM,MAAA,eAAA,uBAAsB,GAAoB,EAAA;AAEhD,EAAA,MAAM,sBAAyB,GAAA,CAC7B,KAGA,EAAA,SAAA,GAAY,IACD,KAAA;AACX,IAAI,IAAA,CAAC,SAAc,KAAA,cAAA,CAAe,GAAI,CAAA,KAAA,CAAM,EAAE,CAAA,IAAK,KAAM,CAAA,GAAA,CAAI,KAAM,CAAA,EAAE,CAAI,CAAA,EAAA;AACvE,MAAO,OAAA,cAAA,CAAe,IAAI,KAAM,CAAA,EAAE,KAAK,KAAM,CAAA,GAAA,CAAI,MAAM,EAAE,CAAA;AAAA;AAE3D,IAAA,MAAM,MAAS,GAAA,cAAA;AAAA,MAAe,KAAA;AAAA,MAAO,CAAC,SAAA,KACpC,sBAAuB,CAAA,SAAA,EAAW,KAAK;AAAA,KACzC;AACA,IAAA,IAAI,KAAM,CAAA,GAAA,CAAI,KAAM,CAAA,EAAE,CAAG,EAAA;AACvB,MAAgB,eAAA,CAAA,GAAA,CAAI,KAAM,CAAA,EAAA,EAAI,MAAM,CAAA;AAAA,KAC/B,MAAA;AACL,MAAM,KAAA,CAAA,GAAA,CAAI,KAAM,CAAA,EAAA,EAAI,MAAM,CAAA;AAAA;AAE5B,IAAO,OAAA,MAAA;AAAA,GACT;AAEA,EAAA,KAAA,IAAS,CAAI,GAAA,CAAA,EAAG,CAAI,GAAA,UAAA,EAAY,CAAK,EAAA,EAAA;AACnC,IAAM,KAAA,CAAA,OAAA,CAAQ,CAAC,EAAO,KAAA,sBAAA,CAAuB,MAAM,GAAI,CAAA,EAAE,CAAG,CAAA,KAAK,CAAC,CAAA;AAElE,IAAM,KAAA,CAAA,OAAA,CAAQ,CAAC,EAAA,KAAO,cAAe,CAAA,GAAA,CAAI,IAAI,eAAgB,CAAA,GAAA,CAAI,EAAE,CAAE,CAAC,CAAA;AAAA;AAGxE,EAAO,OAAA,cAAA;AACT;AAEA,SAAS,gBAAA,CACP,cACA,KACA,EAAA;AACA,EAAA,MAAM,UAAU,YAAa,CAAA,MAAA;AAAA,IAC3B,CAAC,GAAK,EAAA,KAAA,KAAU,KAAK,GAAI,CAAA,GAAA,EAAK,MAAM,IAAI,CAAA;AAAA,IACxC;AAAA,GACF;AACA,EAAA,MAAM,UAAa,GAAA,IAAI,GAAI,CAAA,CAAC,GAAG,KAAM,CAAA,MAAA,EAAQ,CAAA,CAAE,IAAI,CAAC,CAAA,KAAM,CAAE,CAAA,KAAA,CAAM,EAAE,CAAC,CAAA;AAErE,EAAA,MAAM,kBAAqB,GAAA,gBAAA;AAAA,IACzB,UAAA;AAAA,IACA,OAAA;AAAA;AAAA,wBAEI,GAAI,EAAA;AAAA,IACR;AAAA,GACF;AAEA,EAAM,MAAA,eAAA,uBAAsB,GAAsB,EAAA;AAClD,EAAA,KAAA,MAAW,MAAM,UAAY,EAAA;AAC3B,IAAM,MAAA,QAAA,GAAW,kBAAmB,CAAA,GAAA,CAAI,EAAE,CAAA;AAC1C,IAAA,IAAI,QAAY,IAAA,MAAA,EAAiB,MAAA,IAAI,MAAM,aAAa,CAAA;AACxD,IAAA,IAAI,CAAC,eAAA,CAAgB,GAAI,CAAA,QAAQ,CAAG,EAAA;AAClC,MAAgB,eAAA,CAAA,GAAA,CAAI,QAAU,EAAA,EAAE,CAAA;AAAA;AAElC,IAAA,eAAA,CAAgB,GAAI,CAAA,QAAQ,CAAG,CAAA,IAAA,CAAK,EAAE,CAAA;AAAA;AAGxC,EAAA,MAAM,0BAA0B,CAAC,GAAG,eAAgB,CAAA,OAAA,EAAS,CAAE,CAAA,MAAA;AAAA,IAC7D,CAAC,GAAG,KAAK,CAAA,KAAM,MAAM,MAAS,GAAA;AAAA,GAChC;AAEA,EAAA,MAAM,gBAA0C,EAAC;AACjD,EAAA,uBAAA,CAAwB,OAAQ,CAAA,CAAC,GAAG,KAAK,CAAM,KAAA;AAC7C,IAAA,KAAA,CAAM,QAAQ,CAAC,CAAA,KAAO,aAAc,CAAA,CAAC,IAAI,KAAM,CAAA;AAAA,GAChD,CAAA;AAED,EAAO,OAAA,aAAA;AACT;AAEA,MAAM,aAAgB,GAAA,CACpB,KACA,EAAA,KAAA,EACA,KACG,KAAA;AACH,EAAI,IAAA,KAAA,CAAM,IAAI,KAAM,CAAA,EAAE,GAAU,OAAA,KAAA,CAAM,GAAI,CAAA,KAAA,CAAM,EAAE,CAAA;AAElD,EAAA,MAAM,QAAW,GAAA,WAAA,CAAY,KAAM,CAAA,EAAA,EAAI,KAAK,CAAA;AAE5C,EAAM,MAAA,MAAA,GAAS,8BAA+B,CAAA,QAAQ,CAAE,CAAA,MAAA;AAAA;AAAA,IAEtD,CAAC,KAAU,KAAA,KAAA,CAAM,OAAO,CAAK,IAAA,cAAA,CAAe,OAAO,QAAQ;AAAA,GAC7D;AACA,EAAA,MAAM,eAAe,wBAAyB,CAAA,MAAM,CAAE,CAAA,MAAA,CAAO,CAAC,KAAU,KAAA;AAEtE,IAAO,OAAA,CAAC,MAAM,GAAI,CAAA,KAAA,CAAM,QAAS,CAAA,IAAA,GAAO,KAAM,CAAA;AAAA,GAC/C,CAAA;AACD,EAAM,MAAA,QAAA,GAAW,gBAAiB,CAAA,YAAA,EAAc,QAAQ,CAAA;AACxD,EAAM,MAAA,kBAAA,GAAqB,gBAAiB,CAAA,YAAA,EAAc,QAAQ,CAAA;AAElE,EAAmB,kBAAA,CAAA,OAAA,CAAQ,CAAC,KAAU,KAAA;AACpC,IAAI,IAAA,KAAA,CAAM,IAAI,KAAM,CAAA,MAAA,GAAS,IAAK,EAAA,CAAE,KAAM,CAAG,EAAA;AAE3C,MAAA;AAAA;AAGF,IAAA,MAAM,SAAS,gBAAiB,CAAA,KAAA,EAAO,KAAM,CAAA,IAAA,EAAM,OAAO,KAAK,CAAA;AAC/D,IAAM,KAAA,CAAA,OAAA,CAAQ,CAAC,EAAO,KAAA;AACpB,MAAM,MAAA,QAAA,GAAW,MAAO,CAAA,GAAA,CAAI,EAAE,CAAA;AAC9B,MAAA,IAAI,MAAM,QAAU,EAAA;AAClB,QAAS,QAAA,CAAA,EAAE,EAAE,OAAQ,CAAA,CAACD,QAAO,KAAM,CAAA,GAAA,CAAIA,GAAI,EAAA,QAAQ,CAAC,CAAA;AAAA,OAC/C,MAAA;AACL,QAAM,KAAA,CAAA,GAAA,CAAI,IAAI,QAAQ,CAAA;AAAA;AACxB,KACD,CAAA;AAAA,GACF,CAAA;AAED,EAAME,MAAAA,YAAAA,GAAc,CAACT,MAAuB,KAAA;AAC1C,IAAI,IAAA,KAAA,CAAM,IAAIA,MAAM,CAAA,EAAE,GAAU,OAAA,KAAA,CAAM,GAAIA,CAAAA,MAAAA,CAAM,EAAE,CAAA;AAClD,IAAO,OAAA,cAAA,CAAeA,QAAOS,YAAW,CAAA;AAAA,GAC1C;AAEA,EAAA,OAAOA,aAAY,KAAK,CAAA;AAC1B,CAAA;AAEA,MAAM,cAAA,GAAiB,CAAC,KAAA,EAAoB,KAAuB,KAAA;AACjE,EAAI,IAAA,KAAA,CAAM,IAAS,KAAA,CAAA,EAAU,OAAA,KAAA;AAC7B,EAAM,MAAA,CAAC,EAAE,CAAI,GAAA,KAAA;AAEb,EAAA,OAAO,MAAM,GAAI,CAAA,EAAE,CAAG,CAAA,IAAA,CAAK,IAAI,EAAE,CAAA;AACnC,CAAA;AAEa,MAAA,kBAAA,GAAqB,CAAC,iBAAsC,KAAA;AACvE,EAAM,MAAA,EAAE,UAAa,GAAA,iBAAA;AACrB,EAAA,MAAM,KAAQ,GAAA,gBAAA,CAAiB,iBAAmB,EAAA,QAAA,CAAS,OAAO,MAAM,CAAA;AAExE,EAAM,MAAA,KAAA,uBAAY,GAAoB,EAAA;AAEtC,EAAM,MAAA,eAAA,GAAkB,CAAC,EACvB,KAAA,aAAA,CAAc,kBAAkB,EAAE,CAAA,EAAG,OAAO,KAAK,CAAA;AAEnD,EAAM,MAAA,YAAA,GAAe,CAAC,MAAA,EAAgB,KAAiC,KAAA;AACrE,IAAI,IAAA;AACF,MAAA,MAAM,eAAe,QAAS,CAAA,OAAA,CAC3B,IAAK,CAAA,CAAC,MAAM,CAAE,CAAA,IAAA,KAAS,MAAM,CAAA,CAC7B,QAAS,KAAM,CAAA,IAAA,CAAK,CAAC,CAAM,KAAA,CAAA,CAAE,SAAS,KAAK,CAAA;AAE9C,MAAI,IAAA,YAAA,CAAa,KAAK,GAAQ,KAAA,OAAA;AAC5B,QAAO,OAAA,eAAA,CAAgB,YAAa,CAAA,IAAA,CAAK,KAAK,CAAA;AAEhD,MAAA,MAAM,EAAE,GAAA,EAAK,KAAM,EAAA,GAAI,aAAa,IAAK,CAAA,KAAA;AACzC,MAAM,MAAA,GAAA,GAAM,gBAAgB,KAAK,CAAA;AACjC,MAAM,MAAA,SAAA,GAAY,gBAAgB,GAAG,CAAA;AACrC,MAAA,OAAO,WAAY,CAAA,CAAC,GAAK,EAAA,SAAS,CAAC,CAAA;AAAA,aAC5B,CAAG,EAAA;AACV,MAAO,OAAA,IAAA;AAAA;AACT,GACF;AAEA,EAAM,MAAA,gBAAA,GAAmB,CAAC,GAAA,EAAa,MAAkC,KAAA;AACvE,IAAI,IAAA;AACF,MAAA,MAAM,QAAQ,QAAS,CAAA,IAAA,CACpB,IAAK,CAAA,CAAC,MAAM,CAAE,CAAA,IAAA,KAAS,GAAG,CAAA,EACzB,QAAQ,IAAK,CAAA,CAAC,CAAM,KAAA,CAAA,CAAE,SAAS,MAAM,CAAA;AACzC,MAAI,IAAA,CAAC,OAAa,MAAA,IAAA;AAElB,MAAA,MAAM,gBAAmB,GAAA,iBAAA;AAAA,QACvB,MAAM,MAAO,CAAA,GAAA,CAAI,CAAC,CAAA,KAAM,EAAE,IAAI;AAAA,OAChC;AACA,MAAA,MAAM,iBAAoB,GAAA,WAAA;AAAA,QACxB,KAAA,CAAM,OAAO,GAAI,CAAA,CAAC,MAAM,eAAgB,CAAA,CAAA,CAAE,IAAI,CAAC;AAAA,OACjD;AACA,MAAM,MAAA,cAAA,GAAiB,eAAgB,CAAA,KAAA,CAAM,MAAM,CAAA;AAEnD,MAAA,OAAO,WAAY,CAAA,CAAC,gBAAkB,EAAA,iBAAA,EAAmB,cAAc,CAAC,CAAA;AAAA,aACjE,CAAG,EAAA;AACV,MAAO,OAAA,IAAA;AAAA;AACT,GACF;AAEA,EAAM,MAAA,cAAA,GAAiB,CACrB,KACW,KAAA;AACX,IAAA,IAAI,MAAM,IAAS,KAAA,MAAA,SAAe,WAAY,CAAA,CAAC,EAAE,CAAC,CAAA;AAElD,IAAI,IAAA,KAAA,CAAM,SAAS,OAAS,EAAA;AAC1B,MAAA,MAAM,MAAS,GAAA,MAAA,CAAO,MAAO,CAAA,KAAA,CAAM,KAAK,CAAE,CAAA,GAAA;AAAA,QAAI,CAAC,KAAA,KAC7C,eAAgB,CAAA,KAAA,CAAM,EAAE;AAAA,OAC1B;AAEA,MAAA,OAAO,YAAY,CAAC,QAAA,CAAS,KAAO,EAAA,GAAG,MAAM,CAAC,CAAA;AAAA;AAGhD,IAAI,IAAA,KAAA,CAAM,SAAS,OAAS,EAAA;AAC1B,MAAA,OAAO,WAAY,CAAA;AAAA,QACjB,QAAS,CAAA,MAAA;AAAA,QACT,eAAA,CAAgB,KAAM,CAAA,KAAA,CAAM,EAAE,CAAA;AAAA,QAC9B,MAAA,CAAO,MAAM,GAAG;AAAA,OACjB,CAAA;AAAA;AAIH,IAAO,OAAA,iBAAA;AAAA,MAAkB,QAAS,CAAA,MAAA;AAAA,MAAQ,KAAM,CAAA,KAAA;AAAA,MAAO,CAAC,KAAA,KACtD,eAAgB,CAAA,KAAA,CAAM,EAAE;AAAA,KAC1B;AAAA,GACF;AAEA,EAAM,MAAA,eAAA,GAAkB,CAAC,KAA6B,KAAA;AACpD,IAAO,OAAA,iBAAA;AAAA,MAAkB,QAAS,CAAA,KAAA;AAAA,MAAO,KAAM,CAAA,KAAA;AAAA,MAAO,CAAC,KAAA,KACrD,eAAgB,CAAA,KAAA,CAAM,EAAE;AAAA,KAC1B;AAAA,GACF;AAEA,EAAA,MAAM,cAAiB,GAAA;AAAA,IACrB,MAAQ,EAAA,EAAA;AAAA,IACR,MAAQ,EAAA,EAAA;AAAA,IACR,KAAO,EAAA;AAAA,GACT;AACA,EAAA,MAAM,YACJ,GAAA,CAAC,WACD,KAAA,CAAC,QAAgB,IAAgC,KAAA;AAC/C,IAAI,IAAA;AACF,MAAM,MAAA,WAAA,GAAc,SAAS,OAAQ,CAAA,IAAA,CAAK,CAAC,CAAM,KAAA,CAAA,CAAE,SAAS,MAAM,CAAA;AAClE,MAAA,MAAM,UAAa,GAAA,iBAAA;AAAA,QACjB,YAAY,WAAW;AAAA,OACzB;AACA,MAAA,eAAA,CAAgB,WAAW,EAAE,CAAA;AAE7B,MAAI,IAAA,UAAA,CAAW,IAAS,KAAA,MAAA,EAAc,MAAA,IAAA;AACtC,MAAM,MAAA,KAAA,GAAQ,UAAW,CAAA,KAAA,CAAM,IAAI,CAAA;AACnC,MAAM,MAAA,aAAA,GACJ,KAAM,CAAA,IAAA,KAAS,aACX,GAAA,eAAA,CAAgB,MAAM,KAAM,CAAA,EAAE,CAC9B,GAAA,cAAA,CAAe,KAAK,CAAA;AAC1B,MAAA,OAAO,YAAY,CAAC,cAAA,CAAe,WAAW,CAAA,EAAG,aAAa,CAAC,CAAA;AAAA,aACxD,CAAG,EAAA;AACV,MAAO,OAAA,IAAA;AAAA;AACT,GACF;AAEF,EAAM,MAAA,aAAA,GAAgB,CACpB,MAAA,EACA,YACkB,KAAA;AAClB,IAAI,IAAA;AACF,MAAA,MAAM,eAAe,QAAS,CAAA,OAAA,CAC3B,IAAK,CAAA,CAAC,MAAM,CAAE,CAAA,IAAA,KAAS,MAAM,CAAA,CAC7B,UAAW,IAAK,CAAA,CAAC,CAAM,KAAA,CAAA,CAAE,SAAS,YAAY,CAAA;AAEjD,MAAO,OAAA,eAAA,CAAgB,aAAa,IAAI,CAAA;AAAA,aACjC,CAAG,EAAA;AACV,MAAO,OAAA,IAAA;AAAA;AACT,GACF;AAEA,EAAM,MAAA,gBAAA,GACJ,CACE,EAAA,KAEF,CAAI,GAAA,IAAA,KACF,EAAG,CAAA,GAAG,IAAI,CAAA,EAAG,QAAS,CAAA,EAAE,CAAK,IAAA,IAAA;AAEjC,EAAO,OAAA;AAAA,IACL,eAAA,EAAiB,iBAAiB,eAAe,CAAA;AAAA,IACjD,gBAAA,EAAkB,iBAAiB,gBAAgB,CAAA;AAAA,IACnD,YAAA,EAAc,iBAAiB,YAAY,CAAA;AAAA,IAC3C,SAAW,EAAA,gBAAA,CAAiB,YAAa,CAAA,OAAO,CAAC,CAAA;AAAA,IACjD,UAAY,EAAA,gBAAA,CAAiB,YAAa,CAAA,QAAQ,CAAC,CAAA;AAAA,IACnD,UAAY,EAAA,gBAAA,CAAiB,YAAa,CAAA,QAAQ,CAAC,CAAA;AAAA,IACnD,aAAA,EAAe,iBAAiB,aAAa,CAAA;AAAA,IAC7C,cAAA,EAAgB,iBAAiB,cAAc,CAAA;AAAA,IAC/C,eAAA,EAAiB,iBAAiB,eAAe,CAAA;AAAA,IACjD,wBAA0B,EAAA,MACxB,KAAM,CAAA,IAAA,CAAK,MAAM,MAAO,EAAC,CAAE,CAAA,GAAA,CAAI,CAAC,CAAA,KAAM,CAAE,CAAA,QAAA,CAAS,EAAE,CAAC;AAAA,GACxD;AACF;;;;;;;;"}