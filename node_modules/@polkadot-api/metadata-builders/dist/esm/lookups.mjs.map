{"version":3,"file":"lookups.mjs","sources":["../../src/lookups.ts"],"sourcesContent":["import type {\n  StringRecord,\n  V14,\n  V14Lookup,\n  V15,\n} from \"@polkadot-api/substrate-bindings\"\n\nexport type SignedPrimitive = \"i8\" | \"i16\" | \"i32\" | \"i64\" | \"i128\" | \"i256\"\nexport type UnsignedPrimitive = \"u8\" | \"u16\" | \"u32\" | \"u64\" | \"u128\" | \"u256\"\nexport type MetadataPrimitives =\n  | \"bool\"\n  | \"char\"\n  | \"str\"\n  | SignedPrimitive\n  | UnsignedPrimitive\n\nexport type PrimitiveVar = {\n  type: \"primitive\"\n  value: MetadataPrimitives\n}\n\nexport type VoidVar = { type: \"void\" }\nexport type CompactVar = {\n  type: \"compact\"\n  isBig: boolean\n  size: UnsignedPrimitive\n}\nexport type BitSequenceVar = { type: \"bitSequence\" }\nexport type AccountId32 = { type: \"AccountId32\" }\nexport type AccountId20 = { type: \"AccountId20\" }\nexport type TerminalVar =\n  | PrimitiveVar\n  | VoidVar\n  | CompactVar\n  | BitSequenceVar\n  | AccountId32\n  | AccountId20\n\n/* Array-like vars:\n * - TupleVar: Mixed types, fixed length\n * - Sequence: One type, arbitrary length\n * - Array: One type, fixed length\n */\nexport type TupleVar = {\n  type: \"tuple\"\n  value: LookupEntry[]\n  innerDocs: Array<string[]>\n}\nexport type StructVar = {\n  type: \"struct\"\n  value: StringRecord<LookupEntry>\n  innerDocs: StringRecord<string[]>\n}\nexport type EnumVar = {\n  type: \"enum\"\n  value: StringRecord<\n    (\n      | { type: \"lookupEntry\"; value: LookupEntry }\n      | VoidVar\n      | TupleVar\n      | StructVar\n      | ArrayVar\n    ) & { idx: number }\n  >\n  innerDocs: StringRecord<string[]>\n  byteLength?: number\n}\nexport type OptionVar = {\n  type: \"option\"\n  value: LookupEntry\n}\nexport type ResultVar = {\n  type: \"result\"\n  value: { ok: LookupEntry; ko: LookupEntry }\n}\nexport type SequenceVar = {\n  type: \"sequence\"\n  value: LookupEntry\n}\nexport type ArrayVar = {\n  type: \"array\"\n  value: LookupEntry\n  len: number\n}\n\nexport type ComposedVar =\n  | TupleVar\n  | StructVar\n  | SequenceVar\n  | ArrayVar\n  | OptionVar\n  | ResultVar\n  | EnumVar\n\nexport type Var = TerminalVar | ComposedVar\n\nexport type LookupEntry = {\n  id: number\n} & Var\n\nconst isBytes = (value: LookupEntry, nBytes: number) =>\n  value.type === \"array\" &&\n  value.len === nBytes &&\n  value.value.type === \"primitive\" &&\n  value.value.value === \"u8\"\n\nconst _void: VoidVar = { type: \"void\" }\n\nexport interface MetadataLookup {\n  (id: number): LookupEntry\n  metadata: V14 | V15\n  call: number | null\n}\n\nconst _denormalizeLookup = (\n  lookupData: V14Lookup,\n  customMap: (value: V14Lookup[number]) => Var | null = () => null,\n): ((id: number) => LookupEntry) => {\n  const lookups = new Map<number, LookupEntry>()\n  const from = new Set<number>()\n\n  const withCache = (\n    fn: (id: number) => Var,\n  ): ((id: number) => LookupEntry) => {\n    return (id) => {\n      let entry = lookups.get(id)\n\n      if (entry) return entry\n\n      if (from.has(id)) {\n        const entry = {\n          id,\n        } as LookupEntry\n\n        lookups.set(id, entry)\n        return entry\n      }\n\n      from.add(id)\n      const value = fn(id)\n      entry = lookups.get(id)\n\n      if (entry) {\n        Object.assign(entry, value)\n      } else {\n        entry = {\n          id,\n          ...value,\n        }\n        lookups.set(id, entry!)\n      }\n      from.delete(id)\n      return entry\n    }\n  }\n\n  let isAccountId32SearchOn = true\n  let isAccountId20SearchOn = true\n  const getLookupEntryDef = withCache((id): Var => {\n    const custom = customMap(lookupData[id])\n    if (custom) return custom\n\n    const { def, path, params } = lookupData[id]\n\n    if (def.tag === \"composite\") {\n      if (def.value.length === 0) return _void\n\n      // used to be a \"pointer\"\n      if (def.value.length === 1) {\n        const inner = getLookupEntryDef(def.value[0].type as number)\n\n        if (\n          isAccountId32SearchOn &&\n          path.at(-1) === \"AccountId32\" &&\n          isBytes(inner, 32)\n        ) {\n          isAccountId32SearchOn = false\n          return { type: \"AccountId32\" }\n        }\n\n        if (\n          isAccountId20SearchOn &&\n          path.at(-1) === \"AccountId20\" &&\n          isBytes(inner, 20)\n        ) {\n          isAccountId20SearchOn = false\n          return { type: \"AccountId20\" }\n        }\n\n        return inner\n      }\n\n      return getComplexVar(def.value)\n    }\n\n    if (def.tag === \"variant\") {\n      if (\n        path.length === 1 &&\n        path[0] === \"Option\" &&\n        params.length === 1 &&\n        params[0].name === \"T\"\n      ) {\n        const value = getLookupEntryDef(params[0].type!)\n        return value.type === \"void\"\n          ? // Option<void> would return a Codec<undefined> which makes no sense\n            // Therefore, we better treat it as a bool\n            { type: \"primitive\", value: \"bool\" }\n          : {\n              type: \"option\",\n              value,\n            }\n      }\n\n      if (\n        path.length === 1 &&\n        path[0] === \"Result\" &&\n        params.length === 2 &&\n        params[0].name === \"T\" &&\n        params[1].name === \"E\"\n      ) {\n        return {\n          type: \"result\",\n          value: {\n            ok: getLookupEntryDef(params[0].type as number),\n            ko: getLookupEntryDef(params[1].type as number),\n          },\n        }\n      }\n      if (def.value.length === 0) return _void\n\n      const enumValue: StringRecord<EnumVar[\"value\"][keyof EnumVar[\"value\"]]> =\n        {}\n      const enumDocs: StringRecord<string[]> = {}\n\n      def.value.forEach((x) => {\n        const key = x.name\n        enumDocs[key] = x.docs\n\n        if (x.fields.length === 0) {\n          enumValue[key] = { ..._void, idx: x.index }\n          return\n        }\n\n        if (x.fields.length === 1 && !x.fields[0].name) {\n          enumValue[key] = {\n            type: \"lookupEntry\",\n            value: getLookupEntryDef(x.fields[0].type),\n            idx: x.index,\n          }\n          return\n        }\n\n        enumValue[key] = { ...getComplexVar(x.fields), idx: x.index }\n      })\n\n      return {\n        type: \"enum\",\n        value: enumValue,\n        innerDocs: enumDocs,\n      }\n    }\n\n    if (def.tag === \"sequence\")\n      return {\n        type: \"sequence\",\n        value: getLookupEntryDef(def.value as number),\n      }\n\n    if (def.tag === \"array\") {\n      const { len } = def.value\n      const value = getLookupEntryDef(def.value.type)\n\n      return !len || value.type === \"void\"\n        ? _void\n        : len > 1\n          ? {\n              type: \"array\",\n              value,\n              len: def.value.len,\n            }\n          : value\n    }\n\n    if (def.tag === \"tuple\") {\n      if (def.value.length === 0) return _void\n\n      return def.value.length > 1\n        ? getArrayOrTuple(\n            def.value.map((x) => getLookupEntryDef(x as number)),\n            def.value.map((x) => lookupData[x].docs),\n          )\n        : getLookupEntryDef(def.value[0] as number) // use to be a \"pointer\"\n    }\n\n    if (def.tag === \"primitive\") {\n      return {\n        type: \"primitive\",\n        value: def.value.tag,\n      }\n    }\n\n    if (def.tag === \"compact\") {\n      const translated = getLookupEntryDef(def.value) as PrimitiveVar | VoidVar\n      if (translated.type === \"void\") return _void\n\n      const isBig = Number(translated.value.slice(1)) > 32\n\n      return {\n        type: \"compact\",\n        isBig,\n        size: translated.value as UnsignedPrimitive,\n      }\n    }\n\n    // bitSequence\n    return {\n      type: def.tag,\n    }\n  })\n\n  const getComplexVar = (\n    input: Array<{ type: number; name?: string; docs: string[] }>,\n  ): TupleVar | StructVar | ArrayVar | VoidVar => {\n    let allKey = true\n\n    const values: Record<string | number, LookupEntry> = {}\n    const innerDocs: Record<string | number, string[]> = {}\n\n    input.forEach((x, idx) => {\n      allKey = allKey && !!x.name\n      const key = x.name || idx\n      const value = getLookupEntryDef(x.type as number)\n      if (value.type !== \"void\") {\n        values[key] = value\n        innerDocs[key] = x.docs\n      }\n    })\n    return allKey\n      ? {\n          type: \"struct\",\n          value: values as StringRecord<LookupEntry>,\n          innerDocs: innerDocs as StringRecord<string[]>,\n        }\n      : getArrayOrTuple(Object.values(values), Object.values(innerDocs))\n  }\n\n  const getArrayOrTuple = (\n    values: Array<LookupEntry>,\n    innerDocs: Array<string[]>,\n  ): TupleVar | ArrayVar | VoidVar => {\n    if (\n      values.every((v) => v.id === values[0].id) &&\n      innerDocs.every((doc) => !doc.length)\n    ) {\n      const [value] = values\n      return value.type === \"void\"\n        ? _void\n        : {\n            type: \"array\",\n            value: values[0],\n            len: values.length,\n          }\n    }\n    return {\n      type: \"tuple\",\n      value: values,\n      innerDocs: innerDocs,\n    }\n  }\n\n  return getLookupEntryDef\n}\n\nexport const denormalizeLookup = (lookupData: V14Lookup) =>\n  _denormalizeLookup(lookupData)\n\nexport const getLookupFn = (metadata: V14 | V15): MetadataLookup => {\n  const getLookupEntryDef = _denormalizeLookup(metadata.lookup, ({ def }) => {\n    if (def.tag === \"composite\") {\n      const moduleErrorLength = getModuleErrorLength(def)\n      if (moduleErrorLength) {\n        return {\n          type: \"enum\",\n          innerDocs: {},\n          value: Object.fromEntries(\n            metadata.pallets.map((p) => [\n              p.name,\n              p.errors == null\n                ? { ..._void, idx: p.index }\n                : {\n                    type: \"lookupEntry\" as const,\n                    value: getLookupEntryDef(p.errors),\n                    idx: p.index,\n                  },\n            ]),\n          ) as StringRecord<\n            (\n              | VoidVar\n              | {\n                  type: \"lookupEntry\"\n                  value: LookupEntry\n                }\n            ) & { idx: number }\n          >,\n          byteLength: moduleErrorLength,\n        }\n      }\n    }\n    return null\n  })\n\n  function getModuleErrorLength(def: {\n    tag: \"composite\"\n    value: {\n      name: string | undefined\n      type: number\n      typeName: string | undefined\n      docs: string[]\n    }[]\n  }) {\n    const preChecks =\n      def.value.length === 2 &&\n      def.value[0].name === \"index\" &&\n      def.value[1].name === \"error\"\n    if (!preChecks) return null\n\n    const index = getLookupEntryDef(def.value[0].type)\n    const error = getLookupEntryDef(def.value[1].type)\n\n    return index.type === \"primitive\" &&\n      index.value === \"u8\" &&\n      error.type === \"array\" &&\n      error.value.type === \"primitive\" &&\n      error.value.value === \"u8\"\n      ? 1 + error.len\n      : null\n  }\n\n  const getCall = () => {\n    if (\"outerEnums\" in metadata) {\n      return metadata.outerEnums.call\n    }\n\n    const extrinsic = metadata.lookup[metadata.extrinsic?.type]\n    const call = extrinsic?.params.find((p) => p.name === \"Call\")\n\n    return call?.type ?? null\n  }\n\n  return Object.assign(getLookupEntryDef, { metadata, call: getCall() })\n}\n"],"names":["entry"],"mappings":"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"}