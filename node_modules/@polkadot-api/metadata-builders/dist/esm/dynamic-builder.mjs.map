{"version":3,"file":"dynamic-builder.mjs","sources":["../../src/dynamic-builder.ts"],"sourcesContent":["import type { Codec, StringRecord } from \"@polkadot-api/substrate-bindings\"\nimport * as scale from \"@polkadot-api/substrate-bindings\"\nimport { mapObject } from \"@polkadot-api/utils\"\nimport type { EnumVar, MetadataLookup } from \"./lookups\"\nimport { getLookupCodecBuilder } from \"./lookup-codec-builder\"\n\nexport const getDynamicBuilder = (getLookupEntryDef: MetadataLookup) => {\n  const { metadata } = getLookupEntryDef\n  let buildDefinition = getLookupCodecBuilder(getLookupEntryDef)\n\n  const prefix = metadata.pallets\n    .find((x) => x.name === \"System\")\n    ?.constants.find((x) => x.name === \"SS58Prefix\")\n\n  let ss58Prefix: number | undefined\n  if (prefix) {\n    try {\n      const prefixVal = buildDefinition(prefix.type).dec(prefix.value)\n      if (typeof prefixVal === \"number\") {\n        ss58Prefix = prefixVal\n        buildDefinition = getLookupCodecBuilder(\n          getLookupEntryDef,\n          scale.AccountId(prefixVal),\n        )\n      }\n    } catch (_) {}\n  }\n\n  const storagePallets = new Map<string, ReturnType<typeof scale.Storage>>()\n\n  const buildStorage = (pallet: string, entry: string) => {\n    let storagePallet = storagePallets.get(pallet)\n    if (!storagePallet)\n      storagePallets.set(pallet, (storagePallet = scale.Storage(pallet)))\n\n    const storageEntry = metadata.pallets\n      .find((x) => x.name === pallet)!\n      .storage!.items.find((s) => s.name === entry)!\n\n    const storageWithFallback = (\n      len: number,\n      value: Codec<any>,\n      ...args: Parameters<ReturnType<typeof scale.Storage>>\n    ) => {\n      const keys = storagePallet!(...args)\n      return {\n        keys,\n        value,\n        len,\n        fallback:\n          storageEntry.modifier === 1\n            ? value.dec(storageEntry.fallback)\n            : undefined,\n      }\n    }\n\n    if (storageEntry.type.tag === \"plain\")\n      return storageWithFallback(\n        0,\n        buildDefinition(storageEntry.type.value),\n        entry,\n      )\n\n    const { key, value, hashers } = storageEntry.type.value\n    const val = buildDefinition(value)\n    const hashes = hashers.map((x) => scale[x.tag])\n\n    const hashArgs: scale.EncoderWithHash<unknown>[] = (() => {\n      if (hashes.length === 1) {\n        return [[buildDefinition(key), hashes[0]]]\n      }\n\n      const keyDef = getLookupEntryDef(key)\n\n      switch (keyDef.type) {\n        case \"array\":\n          return hashes.map((hash) => [buildDefinition(keyDef.value.id), hash])\n        case \"tuple\":\n          return keyDef.value.map((x, idx) => [\n            buildDefinition(x.id),\n            hashes[idx],\n          ])\n        default:\n          throw new Error(\"Invalid key type\")\n      }\n    })()\n\n    return storageWithFallback(hashes.length, val, entry, ...hashArgs)\n  }\n\n  const buildEnumEntry = (\n    entry: EnumVar[\"value\"][keyof EnumVar[\"value\"]],\n  ): Codec<any> => {\n    switch (entry.type) {\n      case \"void\":\n        return scale._void\n      case \"lookupEntry\":\n        return buildDefinition(entry.value.id)\n      case \"tuple\":\n        return scale.Tuple(\n          ...Object.values(entry.value).map((l) => buildDefinition(l.id)),\n        )\n      case \"struct\":\n        return scale.Struct(\n          mapObject(entry.value, (x) => buildDefinition(x.id)) as StringRecord<\n            Codec<any>\n          >,\n        )\n      case \"array\":\n        return scale.Vector(buildDefinition(entry.value.id), entry.len)\n    }\n  }\n\n  const buildConstant = (pallet: string, constantName: string) => {\n    const storageEntry = metadata.pallets\n      .find((x) => x.name === pallet)!\n      .constants!.find((s) => s.name === constantName)!\n\n    return buildDefinition(storageEntry.type as number)\n  }\n\n  const buildVariant =\n    (type: \"errors\" | \"events\" | \"calls\") =>\n    (\n      pallet: string,\n      name: string,\n    ): {\n      codec: Codec<any>\n      location: [number, number]\n    } => {\n      const palletEntry = metadata.pallets.find((x) => x.name === pallet)!\n      const lookup = getLookupEntryDef(palletEntry[type]!)\n      if (lookup.type !== \"enum\") throw null\n      const entry = lookup.value[name]\n\n      return {\n        location: [palletEntry.index, entry.idx],\n        codec: buildEnumEntry(lookup.value[name]),\n      }\n    }\n\n  const buildRuntimeCall = (api: string, method: string) => {\n    const entry = metadata.apis\n      .find((x) => x.name === api)\n      ?.methods.find((x) => x.name === method)\n    if (!entry) throw null\n\n    return {\n      args: scale.Tuple(...entry.inputs.map((x) => buildDefinition(x.type))),\n      value: buildDefinition(entry.output),\n    }\n  }\n\n  return {\n    buildDefinition,\n    buildStorage,\n    buildEvent: buildVariant(\"events\"),\n    buildError: buildVariant(\"errors\"),\n    buildRuntimeCall,\n    buildCall: buildVariant(\"calls\"),\n    buildConstant,\n    ss58Prefix,\n  }\n}\n"],"names":["value"],"mappings":"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"}