{"version":3,"file":"lookup-graph.mjs","sources":["../../src/lookup-graph.ts"],"sourcesContent":["import { LookupEntry } from \"./lookups\"\n\nexport type LookupGraph = Map<\n  number,\n  { entry: LookupEntry; backRefs: Set<number>; refs: Set<number> }\n>\n\nexport function buildLookupGraph(\n  lookupFn: (id: number) => LookupEntry,\n  lookupLength: number,\n): LookupGraph {\n  const result: LookupGraph = new Map()\n  const visited = new Set<number>()\n\n  const addEdge = (from: number, to: number) => {\n    if (!result.has(from))\n      result.set(from, {\n        entry: lookupFn(from),\n        backRefs: new Set(),\n        refs: new Set(),\n      })\n    if (!result.has(to))\n      result.set(to, {\n        entry: lookupFn(to),\n        backRefs: new Set(),\n        refs: new Set(),\n      })\n    result.get(from)!.refs.add(to)\n    result.get(to)!.backRefs.add(from)\n  }\n\n  for (let i = 0; i < lookupLength; i++) {\n    const entry = lookupFn(i)\n    if (i !== entry.id) {\n      // Lookup solved a pointer, but we still need to add that node into our\n      // graph in case someone access it from there.\n      addEdge(i, entry.id)\n    }\n    if (visited.has(entry.id)) continue\n    visited.add(entry.id)\n\n    switch (entry.type) {\n      case \"array\":\n      case \"option\":\n      case \"sequence\":\n        addEdge(entry.id, entry.value.id)\n        break\n      case \"enum\":\n        Object.values(entry.value).forEach((enumEntry) => {\n          switch (enumEntry.type) {\n            case \"array\":\n            case \"lookupEntry\":\n              addEdge(entry.id, enumEntry.value.id)\n              break\n            case \"struct\":\n            case \"tuple\":\n              Object.values(enumEntry.value).forEach((v) =>\n                addEdge(entry.id, v.id),\n              )\n              break\n          }\n        })\n        break\n      case \"result\":\n        addEdge(entry.id, entry.value.ok.id)\n        addEdge(entry.id, entry.value.ko.id)\n        break\n      case \"struct\":\n      case \"tuple\":\n        Object.values(entry.value).forEach((v) => addEdge(entry.id, v.id))\n        break\n    }\n\n    // It could be that this node is not being referenced by any other type\n    // nor it references anything. We still have to add it into the graph.\n    if (!result.has(entry.id)) {\n      result.set(entry.id, {\n        backRefs: new Set(),\n        refs: new Set(),\n        entry,\n      })\n    }\n  }\n\n  return result\n}\n\nconst subgraphCache = new WeakMap<LookupGraph, Map<number, LookupGraph>>()\nfunction _getSubgraph(\n  id: number,\n  graph: LookupGraph,\n  result: LookupGraph,\n  cache: Map<number, LookupGraph>,\n) {\n  if (result.has(id)) return\n  const node = graph.get(id)!\n  result.set(id, node)\n  cache.set(id, result)\n\n  node.refs.forEach((ref) => _getSubgraph(ref, graph, result, cache))\n  node.backRefs.forEach((ref) => _getSubgraph(ref, graph, result, cache))\n}\n\nexport function getSubgraph(id: number, graph: LookupGraph) {\n  if (!subgraphCache.has(graph)) {\n    subgraphCache.set(graph, new Map())\n  }\n  const cache = subgraphCache.get(graph)!\n  if (cache.has(id)) return cache.get(id)!\n\n  const result: LookupGraph = new Map()\n  _getSubgraph(id, graph, result, cache)\n  return result\n}\n\nexport function getStronglyConnectedComponents(graph: LookupGraph) {\n  // Tarjan's strongly connected components\n  const tarjanState = new Map<\n    number,\n    {\n      index: number\n      lowLink: number\n      onStack: boolean\n    }\n  >()\n  let index = 0\n  const stack: number[] = []\n  const result: Array<Set<number>> = []\n\n  function strongConnect(v: number): void {\n    const state = {\n      index: index,\n      lowLink: index,\n      onStack: true,\n    }\n    tarjanState.set(v, state)\n    index++\n    stack.push(v)\n\n    const edges = graph.get(v)!.refs\n    for (let w of edges) {\n      const edgeState = tarjanState.get(w)\n      if (!edgeState) {\n        strongConnect(w)\n        state.lowLink = Math.min(state.lowLink, tarjanState.get(w)!.lowLink)\n      } else if (edgeState.onStack) {\n        state.lowLink = Math.min(state.lowLink, edgeState.index)\n      }\n    }\n\n    if (state.lowLink === state.index) {\n      const component = new Set<number>()\n\n      let poppedNode = -1\n      do {\n        poppedNode = stack.pop()!\n        tarjanState.get(poppedNode)!.onStack = false\n        component.add(poppedNode)\n      } while (poppedNode !== v)\n\n      result.push(component)\n    }\n  }\n\n  for (const node of graph.keys()) {\n    if (!tarjanState.has(node)) {\n      strongConnect(node)\n    }\n  }\n\n  return result\n}\n\nexport function mergeSCCsWithCommonNodes(\n  stronglyConnectedComponents: Array<Set<number>>,\n) {\n  /**\n   * For Nodes that are shared between two sets of SCCs, we need to calculate\n   * the checksum for the both of them, which wouldn't work (it would give\n   * different checksums).\n   * So we merge the SCCs that are using shared nodes into one group.\n   */\n  const scc = stronglyConnectedComponents\n  const ungroupedCycles = new Set(scc.map((_, i) => i))\n  const edges = new Map(scc.map((_, i) => [i, new Set<number>()]))\n  scc.forEach((cycle, i) => {\n    scc.slice(i + 1).forEach((otherCycle, _j) => {\n      const j = _j + i + 1\n      const combined = new Set([...cycle, ...otherCycle])\n      if (combined.size !== cycle.size + otherCycle.size) {\n        edges.get(i)!.add(j)\n        edges.get(j)!.add(i)\n      }\n    })\n  })\n  const groups: Array<Set<number>> = []\n\n  while (ungroupedCycles.size) {\n    const group = new Set<number>()\n    const toVisit = [ungroupedCycles.values().next().value!]\n    while (toVisit.length) {\n      const idx = toVisit.pop()!\n      if (!ungroupedCycles.has(idx)) continue\n      ungroupedCycles.delete(idx)\n\n      const cycle = scc[idx]\n      cycle.forEach((v) => group.add(Number(v)))\n      edges.get(idx)!.forEach((n) => toVisit.push(n))\n    }\n    groups.push(group)\n  }\n\n  return groups\n}\n"],"names":[],"mappings":"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"}