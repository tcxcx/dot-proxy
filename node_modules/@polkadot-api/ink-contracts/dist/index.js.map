{"version":3,"file":"index.js","sources":["../src/dynamic-builders.ts","../src/metadata-pjs-types.ts","../src/get-lookup.ts","../src/ink-client.ts"],"sourcesContent":["import { getLookupCodecBuilder } from \"@polkadot-api/metadata-builders\"\nimport { Binary, Variant } from \"@polkadot-api/substrate-bindings\"\nimport {\n  _void,\n  Bytes,\n  Codec,\n  CodecType,\n  createCodec,\n  enhanceCodec,\n  StringRecord,\n  Struct,\n  Tuple,\n} from \"@polkadot-api/substrate-bindings\"\nimport { InkMetadataLookup } from \"./get-lookup\"\nimport {\n  EventParamSpec,\n  EventSpecV5,\n  MessageParamSpec,\n  TypeSpec,\n} from \"./metadata-types\"\n\nexport const getInkDynamicBuilder = (metadataLookup: InkMetadataLookup) => {\n  const { metadata } = metadataLookup\n\n  const buildDefinition = getLookupCodecBuilder(metadataLookup)\n\n  const buildStorage = (name = \"\") => {\n    const storageEntry = metadataLookup.storage[name]\n    if (!storageEntry)\n      throw new Error(`Storage entry ${name ? name : \"{root}\"} not found`)\n\n    const keyCodec =\n      storageEntry.key == null ? _void : buildDefinition(storageEntry.key)\n    return {\n      key: prependBytes(keyCodec, storageEntry.keyPrefix),\n      value: buildDefinition(storageEntry.typeId),\n    }\n  }\n\n  const buildCallable = (callable: {\n    selector: string\n    args: Array<MessageParamSpec>\n    returnType: TypeSpec\n  }) => {\n    const argsCodec = Struct(\n      Object.fromEntries(\n        callable.args.map((param) => [\n          param.label,\n          buildDefinition(param.type.type),\n        ]),\n      ) as StringRecord<Codec<any>>,\n    )\n\n    return {\n      call: prependBytes(argsCodec, callable.selector),\n      value: buildDefinition(callable.returnType.type),\n    }\n  }\n\n  const buildConstructor = (label: string) => {\n    const constr = metadata.spec.constructors.find((c) => c.label === label)\n    if (!constr) {\n      throw new Error(`Constructor ${label} not found`)\n    }\n\n    return buildCallable(constr)\n  }\n\n  const buildMessage = (label: string) => {\n    const message = metadata.spec.messages.find((c) => c.label === label)\n    if (!message) {\n      throw new Error(`Message ${label} not found`)\n    }\n\n    return buildCallable(message)\n  }\n\n  const buildEventCodec = (event: { args: EventParamSpec[] }) =>\n    Struct(\n      Object.fromEntries(\n        event.args.map((param) => [\n          param.label,\n          buildDefinition(param.type.type),\n        ]),\n      ) as StringRecord<Codec<any>>,\n    )\n\n  const buildEvent = (signatureTopic: string | undefined) => {\n    const events = metadata.spec.events as EventSpecV5[]\n\n    const withType = <T>(codec: Codec<T>, type: string) =>\n      enhanceCodec<T, { type: string; value: T }>(\n        codec,\n        (evt) => evt.value,\n        (value) => ({ type, value }),\n      )\n\n    if (signatureTopic) {\n      const event = events.find((evt) => evt.signature_topic === signatureTopic)\n      return event ? withType(buildEventCodec(event), event.label) : null\n    }\n\n    const candidates = events.filter(\n      (evt) => evt.signature_topic === signatureTopic,\n    )\n    return candidates.length\n      ? first(candidates.map((c) => withType(buildEventCodec(c), c.label)))\n      : null\n  }\n\n  const buildEvents = () =>\n    Variant(\n      Object.fromEntries(\n        metadata.spec.events.map((evt) => [evt.label, buildEventCodec(evt)]),\n      ) as StringRecord<Codec<any>>,\n    )\n\n  return {\n    buildConstructor,\n    buildMessage,\n    buildStorage,\n    buildEvents,\n    buildEvent,\n  }\n}\n\nexport type InkDynamicBuilder = ReturnType<typeof getInkDynamicBuilder>\n\nconst prependBytes = <T>(codec: Codec<T>, hex: string) => {\n  const bytes = Binary.fromHex(hex).asBytes()\n  const wrappedCodec = Tuple(Bytes(bytes.length), codec)\n  return enhanceCodec(\n    wrappedCodec,\n    (value: CodecType<typeof codec>): CodecType<typeof wrappedCodec> => [\n      bytes,\n      value,\n    ],\n    ([, value]) => value,\n  )\n}\n\nconst first = <T>(codecs: Codec<T>[]) =>\n  createCodec<T>(\n    (x) => {\n      for (const codec of codecs) {\n        try {\n          codec.enc(x)\n        } catch (_) {}\n      }\n      throw new Error(\"Unable to encode\")\n    },\n    (x) => {\n      for (const codec of codecs) {\n        try {\n          codec.dec(x)\n        } catch (_) {}\n      }\n      throw new Error(\"Unable to decode\")\n    },\n  )\n","import {\n  _void,\n  Codec,\n  CodecType,\n  compactNumber,\n  enhanceCodec,\n  Option,\n  ScaleEnum,\n  str,\n  StringRecord,\n  Struct,\n  u32,\n  u8,\n  Vector,\n} from \"@polkadot-api/substrate-bindings\"\n\ntype PjsVariant<O extends StringRecord<Codec<any>>> = {\n  [K in keyof O]: {\n    [KK in K]: CodecType<O[K]>\n  }\n}[keyof O]\nconst Variant = <O extends StringRecord<Codec<any>>>(inner: O) =>\n  enhanceCodec(\n    ScaleEnum(inner),\n    (value: PjsVariant<O>) => {\n      if (typeof value === \"string\") {\n        return {\n          tag: value,\n          value: undefined,\n        } as any\n      }\n      const [tag, val] = Object.entries(value)[0]\n\n      return {\n        tag: tag as keyof O,\n        value: val,\n      }\n    },\n    (value) => {\n      return {\n        [value.tag]: value.value,\n      } as PjsVariant<O>\n    },\n  )\n\n// Seems like pjs can omit empty vectors\nconst PjsVector = <T>(inner: Codec<T>, size?: number) =>\n  enhanceCodec(\n    Vector(inner, size),\n    (value: T[] | undefined) => value ?? [],\n    (v) => v,\n  )\n\nconst oStr = Option(str)\nconst docs = PjsVector(str)\n\nconst primitive = Variant({\n  bool: _void,\n  char: _void,\n  str: _void,\n  u8: _void,\n  u16: _void,\n  u32: _void,\n  u64: _void,\n  u128: _void,\n  u256: _void,\n  i8: _void,\n  i16: _void,\n  i32: _void,\n  i64: _void,\n  i128: _void,\n  i256: _void,\n})\n\nconst fields = PjsVector(\n  Struct({\n    name: oStr,\n    type: compactNumber,\n    typeName: oStr,\n    docs,\n  }),\n)\n\nconst arr = Struct({\n  len: u32,\n  type: compactNumber,\n})\n\nconst bitSequence = Struct({\n  bitStoreType: compactNumber,\n  bitOrderType: compactNumber,\n})\n\nconst variants = PjsVector(\n  Struct({\n    name: str,\n    fields,\n    index: u8,\n    docs,\n  }),\n)\n\nconst def = Variant({\n  composite: Struct({\n    fields,\n  }),\n  variant: Struct({\n    variants,\n  }),\n  sequence: Struct({\n    type: compactNumber,\n  }),\n  array: arr,\n  tuple: Vector(compactNumber),\n  primitive,\n  compact: compactNumber,\n  bitSequence,\n})\n\nconst param = Struct({\n  name: str,\n  type: Option(compactNumber),\n})\nconst params = PjsVector(param)\n\nconst metadataEntry = Struct({\n  id: compactNumber,\n  path: docs,\n  params,\n  def,\n  docs,\n})\n\nconst entry = enhanceCodec(\n  metadataEntry,\n  (value: {\n    id: number\n    type: {\n      def: CodecType<typeof def>\n      path: CodecType<typeof docs>\n      params?: Array<{ name: string; type: number | undefined }>\n    }\n  }) => ({\n    id: value.id,\n    path: value.type.path,\n    params: value.type.params ?? [],\n    def: value.type.def,\n    docs: [],\n  }),\n  (value) => ({\n    id: value.id,\n    type: {\n      def: value.def,\n      path: value.path,\n      params: value.params,\n    },\n  }),\n)\n\nexport const pjsTypes = PjsVector(entry)\nexport type PjsTypes = CodecType<typeof pjsTypes>\n","import { denormalizeLookup, LookupEntry } from \"@polkadot-api/metadata-builders\"\nimport { Binary, V14Lookup, v14Lookup } from \"@polkadot-api/substrate-bindings\"\nimport { InkMetadata, Layout } from \"./metadata-types\"\nimport { pjsTypes } from \"./metadata-pjs-types\"\n\nexport interface InkMetadataLookup {\n  (id: number): LookupEntry\n  metadata: InkMetadata\n  storage: StorageLayout\n}\n\nexport interface StorageEntryPoint {\n  keyPrefix: string\n  key: number | null\n  typeId: number\n}\n\nexport type StorageLayout = Record<string, StorageEntryPoint>\n\nexport const getInkLookup = (metadata: InkMetadata): InkMetadataLookup => {\n  // We can reuse dynamic-builder's lookup if we encode and re-decode the type\n  // into V14Lookup, because both v14 metadata lookup and ink types use scale-info\n  const encoded = pjsTypes.enc(metadata.types)\n  const decoded = v14Lookup.dec(encoded)\n\n  // Signal the lookup the AccountId type\n  const accountTypeId = metadata.spec.environment.accountId.type\n  const accountIdEntry = decoded.find((e) => e.id === accountTypeId)\n  if (accountIdEntry) {\n    accountIdEntry.path = [\"AccountId32\"]\n  }\n\n  const storage = getStorageLayout(metadata, decoded)\n  const getLookupEntryDef = denormalizeLookup(decoded)\n\n  return Object.assign(getLookupEntryDef, {\n    metadata,\n    lookup: decoded,\n    storage,\n  })\n}\n\nfunction getStorageLayout(metadata: InkMetadata, lookup: V14Lookup) {\n  const result: StorageLayout = {}\n\n  const readLayout = (node: Layout, path: string[] = []): number | null => {\n    function addType(def: V14Lookup[number][\"def\"]) {\n      const id = lookup.length\n      lookup[id] = {\n        id,\n        docs: [],\n        def,\n        params: [],\n        path: [],\n      }\n      return id\n    }\n\n    if (\"root\" in node) {\n      // On version 4-, the keys in the storage were in big-endian.\n      // For version 5+, the keys in storage are in scale, which is little-endian.\n      // https://use.ink/faq/migrating-from-ink-4-to-5#metadata-storage-keys-encoding-change\n      // https://github.com/use-ink/ink/pull/2048\n      const keyPrefix =\n        Number(metadata.version) === 4\n          ? Binary.fromBytes(\n              Binary.fromHex(node.root.root_key).asBytes().reverse(),\n            ).asHex()\n          : node.root.root_key\n\n      const typeId = readLayout(node.root.layout, path)!\n      if (node.root.ty != null) {\n        function resolveType(id: number, path: string[]) {\n          const type = metadata.types[id].type\n\n          // A vector internally uses a Mapping, but we have to get it\n          const fields =\n            \"composite\" in type.def\n              ? new Map(\n                  (type.def.composite.fields ?? []).map((v) => [\n                    v.name,\n                    v.type,\n                  ]),\n                )\n              : null\n          const params = new Map(\n            (type.params ?? []).map((v) => [v.name, v.type]),\n          )\n\n          if (\n            params.size === 2 &&\n            params.has(\"V\") &&\n            fields &&\n            fields.size === 2 &&\n            fields.has(\"len\") &&\n            fields.has(\"elements\")\n          ) {\n            // Vectors have length and elements as different entry points\n            resolveType(fields.get(\"len\")!, [...path, \"len\"])\n            resolveType(fields.get(\"elements\")!, path)\n            return\n          } else if (params.size === 3 && params.has(\"K\") && params.has(\"V\")) {\n            // Mapping\n            result[path.join(\".\")] = {\n              keyPrefix,\n              key: params.get(\"K\")!,\n              typeId: params.get(\"V\")!,\n            }\n          } else if (params.size === 2 && params.has(\"V\")) {\n            // Lazy\n            result[path.join(\".\")] = {\n              keyPrefix,\n              key: null,\n              typeId: params.get(\"V\")!,\n            }\n          }\n        }\n        resolveType(node.root.ty, path)\n      }\n\n      if (!result[path.join(\".\")]) {\n        result[path.join(\".\")] = {\n          keyPrefix,\n          key: null,\n          typeId,\n        }\n      }\n\n      // Anyone addressing this node will encounter an empty type\n      return addType({\n        tag: \"composite\",\n        value: [],\n      })\n    }\n    if (\"leaf\" in node) {\n      return node.leaf.ty\n    }\n    if (\"hash\" in node) {\n      throw new Error(\"HashLayout not implemented\")\n    }\n    if (\"array\" in node) {\n      const inner = readLayout(node.array.layout, path)\n\n      return inner == null\n        ? null\n        : addType({\n            tag: \"array\",\n            value: {\n              len: node.array.len,\n              type: inner,\n            },\n          })\n    }\n    if (\"struct\" in node) {\n      const inner = node.struct.fields\n        .map((field) => ({\n          name: field.name,\n          type: readLayout(field.layout, [...path, field.name])!,\n          typeName: undefined,\n          docs: [],\n        }))\n        .filter((field) => field.type != null)\n\n      return addType({\n        tag: \"composite\",\n        value: inner,\n      })\n    }\n\n    const inner = Object.values(node.enum.variants).map((variant, index) => ({\n      name: variant.name,\n      fields: variant.fields\n        .map((field) => ({\n          name: field.name,\n          type: readLayout(field.layout, [...path, variant.name, field.name])!,\n          typeName: undefined,\n          docs: [],\n        }))\n        .filter((v) => v.type !== null),\n      index,\n      docs: [],\n    }))\n\n    return addType({\n      tag: \"variant\",\n      value: inner,\n    })\n  }\n  readLayout(metadata.storage)\n\n  return result\n}\n","import { Binary } from \"@polkadot-api/substrate-bindings\"\nimport { getInkDynamicBuilder, InkDynamicBuilder } from \"./dynamic-builders\"\nimport { getInkLookup, InkMetadataLookup } from \"./get-lookup\"\nimport {\n  Event,\n  InkCallableDescriptor,\n  InkDescriptors,\n  InkStorageDescriptor,\n} from \"./ink-descriptors\"\nimport { EventSpecV5 } from \"./metadata-types\"\n\nexport type InkCallableInterface<T extends InkCallableDescriptor> = <\n  L extends string & keyof T,\n>(\n  label: L,\n) => {\n  encode: {} extends T[L][\"message\"]\n    ? (value?: T[L][\"message\"]) => Binary\n    : (value: T[L][\"message\"]) => Binary\n  decode: (value: { data: Binary }) => T[L][\"response\"]\n}\n\nexport type InkStorageInterface<S extends InkStorageDescriptor> =\n  (\"\" extends keyof S\n    ? () => {\n        encode: S[\"\"][\"key\"] extends undefined\n          ? (key?: undefined) => Binary\n          : (key: S[\"\"][\"key\"]) => Binary\n        decode: (data: Binary) => S[\"\"][\"value\"]\n      }\n    : unknown) &\n    (<L extends string & keyof S>(\n      label: L,\n    ) => {\n      encode: S[L][\"key\"] extends undefined\n        ? (key?: undefined) => Binary\n        : (key: S[L][\"key\"]) => Binary\n      decode: (data: Binary) => S[L][\"value\"]\n    })\n\nexport type GenericEvent =\n  | {\n      type: \"Contracts\"\n      value:\n        | {\n            type: \"ContractEmitted\"\n            value: {\n              contract: string\n              data: Binary\n            }\n          }\n        | { type: string; value: unknown }\n    }\n  | { type: string; value: unknown }\nexport interface InkEventInterface<E> {\n  decode: (value: { data: Binary }, signatureTopic?: string) => E\n  filter: (\n    address: string,\n    events?: Array<\n      | { event: GenericEvent; topics: Binary[] }\n      | (GenericEvent & { topics: Binary[] })\n    >,\n  ) => E[]\n}\n\nexport interface InkClient<\n  D extends InkDescriptors<\n    InkStorageDescriptor,\n    InkCallableDescriptor,\n    InkCallableDescriptor,\n    Event\n  >,\n> {\n  constructor: InkCallableInterface<D[\"__types\"][\"constructors\"]>\n  message: InkCallableInterface<D[\"__types\"][\"messages\"]>\n  storage: InkStorageInterface<D[\"__types\"][\"storage\"]>\n  event: InkEventInterface<D[\"__types\"][\"event\"]>\n}\n\nexport const getInkClient = <\n  D extends InkDescriptors<\n    InkStorageDescriptor,\n    InkCallableDescriptor,\n    InkCallableDescriptor,\n    Event\n  >,\n>(\n  inkContract: D,\n): InkClient<D> => {\n  const lookup = getInkLookup(inkContract.metadata)\n  const builder = getInkDynamicBuilder(lookup)\n\n  return {\n    constructor: buildCallable(builder.buildConstructor),\n    message: buildCallable(builder.buildMessage),\n    storage: buildStorage(builder.buildStorage),\n    event:\n      Number(lookup.metadata.version) === 4\n        ? buildEventV4(builder.buildEvents)\n        : buildEventV5(lookup, builder.buildEvent),\n  }\n}\n\nconst buildCallable =\n  <T extends InkCallableDescriptor>(\n    builder:\n      | InkDynamicBuilder[\"buildConstructor\"]\n      | InkDynamicBuilder[\"buildMessage\"],\n  ): InkCallableInterface<T> =>\n  <L extends string & keyof T>(label: L) => {\n    const codecs = builder(label)\n\n    return {\n      encode: (value?: T[L][\"message\"]) =>\n        Binary.fromBytes(codecs.call.enc(value || {})),\n      decode: (response) => codecs.value.dec(response.data.asBytes()),\n    }\n  }\n\nconst buildStorage =\n  <S extends InkStorageDescriptor>(\n    builder: InkDynamicBuilder[\"buildStorage\"],\n  ): InkStorageInterface<S> =>\n  <L extends string & keyof S>(label?: L) => {\n    const codecs = builder(label)\n\n    return {\n      encode: (key?: S[L][\"key\"]) =>\n        Binary.fromBytes(codecs.key.enc(key as any)),\n      decode: (response: Binary) => codecs.value.dec(response.asBytes()),\n    }\n  }\n\nconst buildEventV4 = <E extends Event>(\n  eventsDecoder: InkDynamicBuilder[\"buildEvents\"],\n): InkEventInterface<E> => {\n  const decode: InkEventInterface<E>[\"decode\"] = (value) => {\n    return eventsDecoder().dec(value.data.asBytes()) as E\n  }\n  const filter: InkEventInterface<E>[\"filter\"] = (address, events = []) => {\n    const contractEvents = events\n      .map((v) => (\"event\" in v ? v.event : v))\n      .filter(\n        (v: any) =>\n          v.type === \"Contracts\" &&\n          v.value.type === \"ContractEmitted\" &&\n          v.value.value.contract === address,\n      )\n    return contractEvents.map((v: any) => {\n      try {\n        return decode(v.value.value)\n      } catch (ex) {\n        console.error(\n          `Contract ${address} emitted an incompatible event`,\n          v.value.value,\n        )\n        throw ex\n      }\n    })\n  }\n  return { decode, filter }\n}\n\nconst buildEventV5 = <E extends Event>(\n  lookup: InkMetadataLookup,\n  eventDecoder: InkDynamicBuilder[\"buildEvent\"],\n): InkEventInterface<E> => {\n  const metadataEventTopics = new Set(\n    lookup.metadata.spec.events\n      .map((evt) => (evt as EventSpecV5).signature_topic)\n      .filter((v) => v != null),\n  )\n  const hasAnonymousEvents = lookup.metadata.spec.events.some(\n    (evt) => (evt as EventSpecV5).signature_topic == null,\n  )\n\n  const decode: InkEventInterface<E>[\"decode\"] = (value, signatureTopic) => {\n    if (signatureTopic != null) {\n      if (!metadataEventTopics.has(signatureTopic)) {\n        throw new Error(`Event with signature topic ${value} not found`)\n      }\n      return eventDecoder(signatureTopic)!.dec(value.data.asBytes()) as E\n    }\n    if (!hasAnonymousEvents) {\n      throw new Error(\"Event signature topic required\")\n    }\n    return eventDecoder(undefined)!.dec(value.data.asBytes()) as E\n  }\n  const filter: InkEventInterface<E>[\"filter\"] = (address, events = []) => {\n    const contractEvents = events\n      .map((v) => (\"event\" in v ? v : { event: v, topics: v.topics }))\n      .filter(\n        (v) =>\n          v.event.type === \"Contracts\" &&\n          (v.event.value as any).type === \"ContractEmitted\" &&\n          (v.event.value as any).value.contract === address,\n      )\n\n    return contractEvents\n      .map((v) => {\n        const eventTopics = v.topics.map((evt) => evt.asHex())\n        const suitableTopic = eventTopics.find((topic) =>\n          metadataEventTopics.has(topic),\n        )\n        try {\n          return decode((v.event.value as any).value, suitableTopic)\n        } catch (ex) {\n          console.error(`Contract ${address} emitted an incompatible event`, {\n            event: (v.event.value as any).value.data.asHex(),\n            eventTopics,\n            metadataEventTopics: [...metadataEventTopics],\n            hasAnonymousEvents,\n          })\n          return null\n        }\n      })\n      .filter((v) => v !== null)\n  }\n\n  return {\n    decode,\n    filter,\n  }\n}\n"],"names":["getLookupCodecBuilder","_void","Struct","enhanceCodec","Variant","Binary","Tuple","Bytes","createCodec","ScaleEnum","Vector","Option","str","compactNumber","u32","u8","v14Lookup","denormalizeLookup","resolveType","path","inner"],"mappings":";;;;;AAqBa,MAAA,oBAAA,GAAuB,CAAC,cAAsC,KAAA;AACzE,EAAM,MAAA,EAAE,UAAa,GAAA,cAAA;AAErB,EAAM,MAAA,eAAA,GAAkBA,uCAAsB,cAAc,CAAA;AAE5D,EAAM,MAAA,YAAA,GAAe,CAAC,IAAA,GAAO,EAAO,KAAA;AAClC,IAAM,MAAA,YAAA,GAAe,cAAe,CAAA,OAAA,CAAQ,IAAI,CAAA;AAChD,IAAA,IAAI,CAAC,YAAA;AACH,MAAA,MAAM,IAAI,KAAM,CAAA,CAAA,cAAA,EAAiB,IAAO,GAAA,IAAA,GAAO,QAAQ,CAAY,UAAA,CAAA,CAAA;AAErE,IAAA,MAAM,WACJ,YAAa,CAAA,GAAA,IAAO,OAAOC,uBAAQ,GAAA,eAAA,CAAgB,aAAa,GAAG,CAAA;AACrE,IAAO,OAAA;AAAA,MACL,GAAK,EAAA,YAAA,CAAa,QAAU,EAAA,YAAA,CAAa,SAAS,CAAA;AAAA,MAClD,KAAA,EAAO,eAAgB,CAAA,YAAA,CAAa,MAAM;AAAA,KAC5C;AAAA,GACF;AAEA,EAAM,MAAA,aAAA,GAAgB,CAAC,QAIjB,KAAA;AACJ,IAAA,MAAM,SAAY,GAAAC,wBAAA;AAAA,MAChB,MAAO,CAAA,WAAA;AAAA,QACL,QAAS,CAAA,IAAA,CAAK,GAAI,CAAA,CAAC,KAAU,KAAA;AAAA,UAC3B,KAAM,CAAA,KAAA;AAAA,UACN,eAAA,CAAgB,KAAM,CAAA,IAAA,CAAK,IAAI;AAAA,SAChC;AAAA;AACH,KACF;AAEA,IAAO,OAAA;AAAA,MACL,IAAM,EAAA,YAAA,CAAa,SAAW,EAAA,QAAA,CAAS,QAAQ,CAAA;AAAA,MAC/C,KAAO,EAAA,eAAA,CAAgB,QAAS,CAAA,UAAA,CAAW,IAAI;AAAA,KACjD;AAAA,GACF;AAEA,EAAM,MAAA,gBAAA,GAAmB,CAAC,KAAkB,KAAA;AAC1C,IAAM,MAAA,MAAA,GAAS,SAAS,IAAK,CAAA,YAAA,CAAa,KAAK,CAAC,CAAA,KAAM,CAAE,CAAA,KAAA,KAAU,KAAK,CAAA;AACvE,IAAA,IAAI,CAAC,MAAQ,EAAA;AACX,MAAA,MAAM,IAAI,KAAA,CAAM,CAAe,YAAA,EAAA,KAAK,CAAY,UAAA,CAAA,CAAA;AAAA;AAGlD,IAAA,OAAO,cAAc,MAAM,CAAA;AAAA,GAC7B;AAEA,EAAM,MAAA,YAAA,GAAe,CAAC,KAAkB,KAAA;AACtC,IAAM,MAAA,OAAA,GAAU,SAAS,IAAK,CAAA,QAAA,CAAS,KAAK,CAAC,CAAA,KAAM,CAAE,CAAA,KAAA,KAAU,KAAK,CAAA;AACpE,IAAA,IAAI,CAAC,OAAS,EAAA;AACZ,MAAA,MAAM,IAAI,KAAA,CAAM,CAAW,QAAA,EAAA,KAAK,CAAY,UAAA,CAAA,CAAA;AAAA;AAG9C,IAAA,OAAO,cAAc,OAAO,CAAA;AAAA,GAC9B;AAEA,EAAM,MAAA,eAAA,GAAkB,CAAC,KACvB,KAAAA,wBAAA;AAAA,IACE,MAAO,CAAA,WAAA;AAAA,MACL,KAAM,CAAA,IAAA,CAAK,GAAI,CAAA,CAAC,KAAU,KAAA;AAAA,QACxB,KAAM,CAAA,KAAA;AAAA,QACN,eAAA,CAAgB,KAAM,CAAA,IAAA,CAAK,IAAI;AAAA,OAChC;AAAA;AACH,GACF;AAEF,EAAM,MAAA,UAAA,GAAa,CAAC,cAAuC,KAAA;AACzD,IAAM,MAAA,MAAA,GAAS,SAAS,IAAK,CAAA,MAAA;AAE7B,IAAM,MAAA,QAAA,GAAW,CAAI,KAAA,EAAiB,IACpC,KAAAC,8BAAA;AAAA,MACE,KAAA;AAAA,MACA,CAAC,QAAQ,GAAI,CAAA,KAAA;AAAA,MACb,CAAC,KAAA,MAAW,EAAE,IAAA,EAAM,KAAM,EAAA;AAAA,KAC5B;AAEF,IAAA,IAAI,cAAgB,EAAA;AAClB,MAAA,MAAM,QAAQ,MAAO,CAAA,IAAA,CAAK,CAAC,GAAQ,KAAA,GAAA,CAAI,oBAAoB,cAAc,CAAA;AACzE,MAAA,OAAO,QAAQ,QAAS,CAAA,eAAA,CAAgB,KAAK,CAAG,EAAA,KAAA,CAAM,KAAK,CAAI,GAAA,IAAA;AAAA;AAGjE,IAAA,MAAM,aAAa,MAAO,CAAA,MAAA;AAAA,MACxB,CAAC,GAAQ,KAAA,GAAA,CAAI,eAAoB,KAAA;AAAA,KACnC;AACA,IAAA,OAAO,UAAW,CAAA,MAAA,GACd,KAAM,CAAA,UAAA,CAAW,IAAI,CAAC,CAAA,KAAM,QAAS,CAAA,eAAA,CAAgB,CAAC,CAAG,EAAA,CAAA,CAAE,KAAK,CAAC,CAAC,CAClE,GAAA,IAAA;AAAA,GACN;AAEA,EAAA,MAAM,cAAc,MAClBC,yBAAA;AAAA,IACE,MAAO,CAAA,WAAA;AAAA,MACL,QAAS,CAAA,IAAA,CAAK,MAAO,CAAA,GAAA,CAAI,CAAC,GAAA,KAAQ,CAAC,GAAA,CAAI,KAAO,EAAA,eAAA,CAAgB,GAAG,CAAC,CAAC;AAAA;AACrE,GACF;AAEF,EAAO,OAAA;AAAA,IACL,gBAAA;AAAA,IACA,YAAA;AAAA,IACA,YAAA;AAAA,IACA,WAAA;AAAA,IACA;AAAA,GACF;AACF;AAIA,MAAM,YAAA,GAAe,CAAI,KAAA,EAAiB,GAAgB,KAAA;AACxD,EAAA,MAAM,KAAQ,GAAAC,wBAAA,CAAO,OAAQ,CAAA,GAAG,EAAE,OAAQ,EAAA;AAC1C,EAAA,MAAM,eAAeC,uBAAM,CAAAC,uBAAA,CAAM,KAAM,CAAA,MAAM,GAAG,KAAK,CAAA;AACrD,EAAO,OAAAJ,8BAAA;AAAA,IACL,YAAA;AAAA,IACA,CAAC,KAAmE,KAAA;AAAA,MAClE,KAAA;AAAA,MACA;AAAA,KACF;AAAA,IACA,CAAC,GAAG,KAAK,CAAM,KAAA;AAAA,GACjB;AACF,CAAA;AAEA,MAAM,KAAA,GAAQ,CAAI,MAChB,KAAAK,6BAAA;AAAA,EACE,CAAC,CAAM,KAAA;AACL,IAAA,KAAA,MAAW,SAAS,MAAQ,EAAA;AAC1B,MAAI,IAAA;AACF,QAAA,KAAA,CAAM,IAAI,CAAC,CAAA;AAAA,eACJ,CAAG,EAAA;AAAA;AAAC;AAEf,IAAM,MAAA,IAAI,MAAM,kBAAkB,CAAA;AAAA,GACpC;AAAA,EACA,CAAC,CAAM,KAAA;AACL,IAAA,KAAA,MAAW,SAAS,MAAQ,EAAA;AAC1B,MAAI,IAAA;AACF,QAAA,KAAA,CAAM,IAAI,CAAC,CAAA;AAAA,eACJ,CAAG,EAAA;AAAA;AAAC;AAEf,IAAM,MAAA,IAAI,MAAM,kBAAkB,CAAA;AAAA;AAEtC,CAAA;;AC1IF,MAAM,OAAA,GAAU,CAAqC,KACnD,KAAAL,8BAAA;AAAA,EACEM,4BAAU,KAAK,CAAA;AAAA,EACf,CAAC,KAAyB,KAAA;AACxB,IAAI,IAAA,OAAO,UAAU,QAAU,EAAA;AAC7B,MAAO,OAAA;AAAA,QACL,GAAK,EAAA,KAAA;AAAA,QACL,KAAO,EAAA;AAAA,OACT;AAAA;AAEF,IAAM,MAAA,CAAC,KAAK,GAAG,CAAA,GAAI,OAAO,OAAQ,CAAA,KAAK,EAAE,CAAC,CAAA;AAE1C,IAAO,OAAA;AAAA,MACL,GAAA;AAAA,MACA,KAAO,EAAA;AAAA,KACT;AAAA,GACF;AAAA,EACA,CAAC,KAAU,KAAA;AACT,IAAO,OAAA;AAAA,MACL,CAAC,KAAA,CAAM,GAAG,GAAG,KAAM,CAAA;AAAA,KACrB;AAAA;AAEJ,CAAA;AAGF,MAAM,SAAA,GAAY,CAAI,KAAA,EAAiB,IACrC,KAAAN,8BAAA;AAAA,EACEO,wBAAA,CAAO,OAAO,IAAI,CAAA;AAAA,EAClB,CAAC,KAA2B,KAAA,KAAA,IAAS,EAAC;AAAA,EACtC,CAAC,CAAM,KAAA;AACT,CAAA;AAEF,MAAM,IAAA,GAAOC,yBAAOC,qBAAG,CAAA;AACvB,MAAM,IAAA,GAAO,UAAUA,qBAAG,CAAA;AAE1B,MAAM,YAAY,OAAQ,CAAA;AAAA,EACxB,IAAM,EAAAX,uBAAA;AAAA,EACN,IAAM,EAAAA,uBAAA;AAAA,EACN,GAAK,EAAAA,uBAAA;AAAA,EACL,EAAI,EAAAA,uBAAA;AAAA,EACJ,GAAK,EAAAA,uBAAA;AAAA,EACL,GAAK,EAAAA,uBAAA;AAAA,EACL,GAAK,EAAAA,uBAAA;AAAA,EACL,IAAM,EAAAA,uBAAA;AAAA,EACN,IAAM,EAAAA,uBAAA;AAAA,EACN,EAAI,EAAAA,uBAAA;AAAA,EACJ,GAAK,EAAAA,uBAAA;AAAA,EACL,GAAK,EAAAA,uBAAA;AAAA,EACL,GAAK,EAAAA,uBAAA;AAAA,EACL,IAAM,EAAAA,uBAAA;AAAA,EACN,IAAM,EAAAA;AACR,CAAC,CAAA;AAED,MAAM,MAAS,GAAA,SAAA;AAAA,EACbC,wBAAO,CAAA;AAAA,IACL,IAAM,EAAA,IAAA;AAAA,IACN,IAAM,EAAAW,+BAAA;AAAA,IACN,QAAU,EAAA,IAAA;AAAA,IACV;AAAA,GACD;AACH,CAAA;AAEA,MAAM,MAAMX,wBAAO,CAAA;AAAA,EACjB,GAAK,EAAAY,qBAAA;AAAA,EACL,IAAM,EAAAD;AACR,CAAC,CAAA;AAED,MAAM,cAAcX,wBAAO,CAAA;AAAA,EACzB,YAAc,EAAAW,+BAAA;AAAA,EACd,YAAc,EAAAA;AAChB,CAAC,CAAA;AAED,MAAM,QAAW,GAAA,SAAA;AAAA,EACfX,wBAAO,CAAA;AAAA,IACL,IAAM,EAAAU,qBAAA;AAAA,IACN,MAAA;AAAA,IACA,KAAO,EAAAG,oBAAA;AAAA,IACP;AAAA,GACD;AACH,CAAA;AAEA,MAAM,MAAM,OAAQ,CAAA;AAAA,EAClB,WAAWb,wBAAO,CAAA;AAAA,IAChB;AAAA,GACD,CAAA;AAAA,EACD,SAASA,wBAAO,CAAA;AAAA,IACd;AAAA,GACD,CAAA;AAAA,EACD,UAAUA,wBAAO,CAAA;AAAA,IACf,IAAM,EAAAW;AAAA,GACP,CAAA;AAAA,EACD,KAAO,EAAA,GAAA;AAAA,EACP,KAAA,EAAOH,yBAAOG,+BAAa,CAAA;AAAA,EAC3B,SAAA;AAAA,EACA,OAAS,EAAAA,+BAAA;AAAA,EACT;AACF,CAAC,CAAA;AAED,MAAM,QAAQX,wBAAO,CAAA;AAAA,EACnB,IAAM,EAAAU,qBAAA;AAAA,EACN,IAAA,EAAMD,yBAAOE,+BAAa;AAC5B,CAAC,CAAA;AACD,MAAM,MAAA,GAAS,UAAU,KAAK,CAAA;AAE9B,MAAM,gBAAgBX,wBAAO,CAAA;AAAA,EAC3B,EAAI,EAAAW,+BAAA;AAAA,EACJ,IAAM,EAAA,IAAA;AAAA,EACN,MAAA;AAAA,EACA,GAAA;AAAA,EACA;AACF,CAAC,CAAA;AAED,MAAM,KAAQ,GAAAV,8BAAA;AAAA,EACZ,aAAA;AAAA,EACA,CAAC,KAOM,MAAA;AAAA,IACL,IAAI,KAAM,CAAA,EAAA;AAAA,IACV,IAAA,EAAM,MAAM,IAAK,CAAA,IAAA;AAAA,IACjB,MAAQ,EAAA,KAAA,CAAM,IAAK,CAAA,MAAA,IAAU,EAAC;AAAA,IAC9B,GAAA,EAAK,MAAM,IAAK,CAAA,GAAA;AAAA,IAChB,MAAM;AAAC,GACT,CAAA;AAAA,EACA,CAAC,KAAW,MAAA;AAAA,IACV,IAAI,KAAM,CAAA,EAAA;AAAA,IACV,IAAM,EAAA;AAAA,MACJ,KAAK,KAAM,CAAA,GAAA;AAAA,MACX,MAAM,KAAM,CAAA,IAAA;AAAA,MACZ,QAAQ,KAAM,CAAA;AAAA;AAChB,GACF;AACF,CAAA;AAEa,MAAA,QAAA,GAAW,UAAU,KAAK,CAAA;;AC5I1B,MAAA,YAAA,GAAe,CAAC,QAA6C,KAAA;AAGxE,EAAA,MAAM,OAAU,GAAA,QAAA,CAAS,GAAI,CAAA,QAAA,CAAS,KAAK,CAAA;AAC3C,EAAM,MAAA,OAAA,GAAUa,2BAAU,CAAA,GAAA,CAAI,OAAO,CAAA;AAGrC,EAAA,MAAM,aAAgB,GAAA,QAAA,CAAS,IAAK,CAAA,WAAA,CAAY,SAAU,CAAA,IAAA;AAC1D,EAAA,MAAM,iBAAiB,OAAQ,CAAA,IAAA,CAAK,CAAC,CAAM,KAAA,CAAA,CAAE,OAAO,aAAa,CAAA;AACjE,EAAA,IAAI,cAAgB,EAAA;AAClB,IAAe,cAAA,CAAA,IAAA,GAAO,CAAC,aAAa,CAAA;AAAA;AAGtC,EAAM,MAAA,OAAA,GAAU,gBAAiB,CAAA,QAAA,EAAU,OAAO,CAAA;AAClD,EAAM,MAAA,iBAAA,GAAoBC,mCAAkB,OAAO,CAAA;AAEnD,EAAO,OAAA,MAAA,CAAO,OAAO,iBAAmB,EAAA;AAAA,IACtC,QAAA;AAAA,IACA,MAAQ,EAAA,OAAA;AAAA,IACR;AAAA,GACD,CAAA;AACH;AAEA,SAAS,gBAAA,CAAiB,UAAuB,MAAmB,EAAA;AAClE,EAAA,MAAM,SAAwB,EAAC;AAE/B,EAAA,MAAM,UAAa,GAAA,CAAC,IAAc,EAAA,IAAA,GAAiB,EAAsB,KAAA;AACvE,IAAA,SAAS,QAAQ,GAA+B,EAAA;AAC9C,MAAA,MAAM,KAAK,MAAO,CAAA,MAAA;AAClB,MAAA,MAAA,CAAO,EAAE,CAAI,GAAA;AAAA,QACX,EAAA;AAAA,QACA,MAAM,EAAC;AAAA,QACP,GAAA;AAAA,QACA,QAAQ,EAAC;AAAA,QACT,MAAM;AAAC,OACT;AACA,MAAO,OAAA,EAAA;AAAA;AAGT,IAAA,IAAI,UAAU,IAAM,EAAA;AAKlB,MAAA,MAAM,YACJ,MAAO,CAAA,QAAA,CAAS,OAAO,CAAA,KAAM,IACzBZ,wBAAO,CAAA,SAAA;AAAA,QACLA,wBAAA,CAAO,QAAQ,IAAK,CAAA,IAAA,CAAK,QAAQ,CAAE,CAAA,OAAA,GAAU,OAAQ;AAAA,OACrD,CAAA,KAAA,EACF,GAAA,IAAA,CAAK,IAAK,CAAA,QAAA;AAEhB,MAAA,MAAM,MAAS,GAAA,UAAA,CAAW,IAAK,CAAA,IAAA,CAAK,QAAQ,IAAI,CAAA;AAChD,MAAI,IAAA,IAAA,CAAK,IAAK,CAAA,EAAA,IAAM,IAAM,EAAA;AACxB,QAASa,IAAAA,YAAAA,GAAT,SAAqB,EAAA,EAAYC,KAAgB,EAAA;AAC/C,UAAA,MAAM,IAAO,GAAA,QAAA,CAAS,KAAM,CAAA,EAAE,CAAE,CAAA,IAAA;AAGhC,UAAA,MAAM,MACJ,GAAA,WAAA,IAAe,IAAK,CAAA,GAAA,GAChB,IAAI,GAAA;AAAA,YACD,CAAA,IAAA,CAAK,IAAI,SAAU,CAAA,MAAA,IAAU,EAAI,EAAA,GAAA,CAAI,CAAC,CAAM,KAAA;AAAA,cAC3C,CAAE,CAAA,IAAA;AAAA,cACF,CAAE,CAAA;AAAA,aACH;AAAA,WAEH,GAAA,IAAA;AACN,UAAA,MAAM,SAAS,IAAI,GAAA;AAAA,YAAA,CAChB,IAAK,CAAA,MAAA,IAAU,EAAC,EAAG,GAAI,CAAA,CAAC,CAAM,KAAA,CAAC,CAAE,CAAA,IAAA,EAAM,CAAE,CAAA,IAAI,CAAC;AAAA,WACjD;AAEA,UAAA,IACE,OAAO,IAAS,KAAA,CAAA,IAChB,OAAO,GAAI,CAAA,GAAG,KACd,MACA,IAAA,MAAA,CAAO,IAAS,KAAA,CAAA,IAChB,OAAO,GAAI,CAAA,KAAK,KAChB,MAAO,CAAA,GAAA,CAAI,UAAU,CACrB,EAAA;AAEA,YAAAD,YAAAA,CAAY,OAAO,GAAI,CAAA,KAAK,GAAI,CAAC,GAAGC,KAAM,EAAA,KAAK,CAAC,CAAA;AAChD,YAAAD,YAAY,CAAA,MAAA,CAAO,GAAI,CAAA,UAAU,GAAIC,KAAI,CAAA;AACzC,YAAA;AAAA,WACF,MAAA,IAAW,MAAO,CAAA,IAAA,KAAS,CAAK,IAAA,MAAA,CAAO,GAAI,CAAA,GAAG,CAAK,IAAA,MAAA,CAAO,GAAI,CAAA,GAAG,CAAG,EAAA;AAElE,YAAA,MAAA,CAAOA,KAAK,CAAA,IAAA,CAAK,GAAG,CAAC,CAAI,GAAA;AAAA,cACvB,SAAA;AAAA,cACA,GAAA,EAAK,MAAO,CAAA,GAAA,CAAI,GAAG,CAAA;AAAA,cACnB,MAAA,EAAQ,MAAO,CAAA,GAAA,CAAI,GAAG;AAAA,aACxB;AAAA,qBACS,MAAO,CAAA,IAAA,KAAS,KAAK,MAAO,CAAA,GAAA,CAAI,GAAG,CAAG,EAAA;AAE/C,YAAA,MAAA,CAAOA,KAAK,CAAA,IAAA,CAAK,GAAG,CAAC,CAAI,GAAA;AAAA,cACvB,SAAA;AAAA,cACA,GAAK,EAAA,IAAA;AAAA,cACL,MAAA,EAAQ,MAAO,CAAA,GAAA,CAAI,GAAG;AAAA,aACxB;AAAA;AACF,SACF;AACA,QAAAD,YAAY,CAAA,IAAA,CAAK,IAAK,CAAA,EAAA,EAAI,IAAI,CAAA;AAAA;AAGhC,MAAA,IAAI,CAAC,MAAO,CAAA,IAAA,CAAK,IAAK,CAAA,GAAG,CAAC,CAAG,EAAA;AAC3B,QAAA,MAAA,CAAO,IAAK,CAAA,IAAA,CAAK,GAAG,CAAC,CAAI,GAAA;AAAA,UACvB,SAAA;AAAA,UACA,GAAK,EAAA,IAAA;AAAA,UACL;AAAA,SACF;AAAA;AAIF,MAAA,OAAO,OAAQ,CAAA;AAAA,QACb,GAAK,EAAA,WAAA;AAAA,QACL,OAAO;AAAC,OACT,CAAA;AAAA;AAEH,IAAA,IAAI,UAAU,IAAM,EAAA;AAClB,MAAA,OAAO,KAAK,IAAK,CAAA,EAAA;AAAA;AAEnB,IAAA,IAAI,UAAU,IAAM,EAAA;AAClB,MAAM,MAAA,IAAI,MAAM,4BAA4B,CAAA;AAAA;AAE9C,IAAA,IAAI,WAAW,IAAM,EAAA;AACnB,MAAA,MAAME,MAAQ,GAAA,UAAA,CAAW,IAAK,CAAA,KAAA,CAAM,QAAQ,IAAI,CAAA;AAEhD,MAAOA,OAAAA,MAAAA,IAAS,IACZ,GAAA,IAAA,GACA,OAAQ,CAAA;AAAA,QACN,GAAK,EAAA,OAAA;AAAA,QACL,KAAO,EAAA;AAAA,UACL,GAAA,EAAK,KAAK,KAAM,CAAA,GAAA;AAAA,UAChB,IAAMA,EAAAA;AAAA;AACR,OACD,CAAA;AAAA;AAEP,IAAA,IAAI,YAAY,IAAM,EAAA;AACpB,MAAA,MAAMA,SAAQ,IAAK,CAAA,MAAA,CAAO,MACvB,CAAA,GAAA,CAAI,CAAC,KAAW,MAAA;AAAA,QACf,MAAM,KAAM,CAAA,IAAA;AAAA,QACZ,IAAA,EAAM,WAAW,KAAM,CAAA,MAAA,EAAQ,CAAC,GAAG,IAAA,EAAM,KAAM,CAAA,IAAI,CAAC,CAAA;AAAA,QACpD,QAAU,EAAA,MAAA;AAAA,QACV,MAAM;AAAC,QACP,CACD,CAAA,MAAA,CAAO,CAAC,KAAU,KAAA,KAAA,CAAM,QAAQ,IAAI,CAAA;AAEvC,MAAA,OAAO,OAAQ,CAAA;AAAA,QACb,GAAK,EAAA,WAAA;AAAA,QACL,KAAOA,EAAAA;AAAA,OACR,CAAA;AAAA;AAGH,IAAM,MAAA,KAAA,GAAQ,MAAO,CAAA,MAAA,CAAO,IAAK,CAAA,IAAA,CAAK,QAAQ,CAAE,CAAA,GAAA,CAAI,CAAC,OAAA,EAAS,KAAW,MAAA;AAAA,MACvE,MAAM,OAAQ,CAAA,IAAA;AAAA,MACd,MAAQ,EAAA,OAAA,CAAQ,MACb,CAAA,GAAA,CAAI,CAAC,KAAW,MAAA;AAAA,QACf,MAAM,KAAM,CAAA,IAAA;AAAA,QACZ,IAAA,EAAM,UAAW,CAAA,KAAA,CAAM,MAAQ,EAAA,CAAC,GAAG,IAAA,EAAM,OAAQ,CAAA,IAAA,EAAM,KAAM,CAAA,IAAI,CAAC,CAAA;AAAA,QAClE,QAAU,EAAA,MAAA;AAAA,QACV,MAAM;AAAC,QACP,CACD,CAAA,MAAA,CAAO,CAAC,CAAM,KAAA,CAAA,CAAE,SAAS,IAAI,CAAA;AAAA,MAChC,KAAA;AAAA,MACA,MAAM;AAAC,KACP,CAAA,CAAA;AAEF,IAAA,OAAO,OAAQ,CAAA;AAAA,MACb,GAAK,EAAA,SAAA;AAAA,MACL,KAAO,EAAA;AAAA,KACR,CAAA;AAAA,GACH;AACA,EAAA,UAAA,CAAW,SAAS,OAAO,CAAA;AAE3B,EAAO,OAAA,MAAA;AACT;;AChHa,MAAA,YAAA,GAAe,CAQ1B,WACiB,KAAA;AACjB,EAAM,MAAA,MAAA,GAAS,YAAa,CAAA,WAAA,CAAY,QAAQ,CAAA;AAChD,EAAM,MAAA,OAAA,GAAU,qBAAqB,MAAM,CAAA;AAE3C,EAAO,OAAA;AAAA,IACL,WAAA,EAAa,aAAc,CAAA,OAAA,CAAQ,gBAAgB,CAAA;AAAA,IACnD,OAAA,EAAS,aAAc,CAAA,OAAA,CAAQ,YAAY,CAAA;AAAA,IAC3C,OAAA,EAAS,YAAa,CAAA,OAAA,CAAQ,YAAY,CAAA;AAAA,IAC1C,KACE,EAAA,MAAA,CAAO,MAAO,CAAA,QAAA,CAAS,OAAO,CAAM,KAAA,CAAA,GAChC,YAAa,CAAA,OAAA,CAAQ,WAAW,CAAA,GAChC,YAAa,CAAA,MAAA,EAAQ,QAAQ,UAAU;AAAA,GAC/C;AACF;AAEA,MAAM,aACJ,GAAA,CACE,OAIF,KAAA,CAA6B,KAAa,KAAA;AACxC,EAAM,MAAA,MAAA,GAAS,QAAQ,KAAK,CAAA;AAE5B,EAAO,OAAA;AAAA,IACL,MAAA,EAAQ,CAAC,KAAA,KACPf,wBAAO,CAAA,SAAA,CAAU,MAAO,CAAA,IAAA,CAAK,GAAI,CAAA,KAAA,IAAS,EAAE,CAAC,CAAA;AAAA,IAC/C,MAAA,EAAQ,CAAC,QAAa,KAAA,MAAA,CAAO,MAAM,GAAI,CAAA,QAAA,CAAS,IAAK,CAAA,OAAA,EAAS;AAAA,GAChE;AACF,CAAA;AAEF,MAAM,YACJ,GAAA,CACE,OAEF,KAAA,CAA6B,KAAc,KAAA;AACzC,EAAM,MAAA,MAAA,GAAS,QAAQ,KAAK,CAAA;AAE5B,EAAO,OAAA;AAAA,IACL,MAAA,EAAQ,CAAC,GACP,KAAAA,wBAAA,CAAO,UAAU,MAAO,CAAA,GAAA,CAAI,GAAI,CAAA,GAAU,CAAC,CAAA;AAAA,IAC7C,MAAA,EAAQ,CAAC,QAAqB,KAAA,MAAA,CAAO,MAAM,GAAI,CAAA,QAAA,CAAS,SAAS;AAAA,GACnE;AACF,CAAA;AAEF,MAAM,YAAA,GAAe,CACnB,aACyB,KAAA;AACzB,EAAM,MAAA,MAAA,GAAyC,CAAC,KAAU,KAAA;AACxD,IAAA,OAAO,eAAgB,CAAA,GAAA,CAAI,KAAM,CAAA,IAAA,CAAK,SAAS,CAAA;AAAA,GACjD;AACA,EAAA,MAAM,MAAyC,GAAA,CAAC,OAAS,EAAA,MAAA,GAAS,EAAO,KAAA;AACvE,IAAM,MAAA,cAAA,GAAiB,MACpB,CAAA,GAAA,CAAI,CAAC,CAAA,KAAO,WAAW,CAAI,GAAA,CAAA,CAAE,KAAQ,GAAA,CAAE,CACvC,CAAA,MAAA;AAAA,MACC,CAAC,CAAA,KACC,CAAE,CAAA,IAAA,KAAS,WACX,IAAA,CAAA,CAAE,KAAM,CAAA,IAAA,KAAS,iBACjB,IAAA,CAAA,CAAE,KAAM,CAAA,KAAA,CAAM,QAAa,KAAA;AAAA,KAC/B;AACF,IAAO,OAAA,cAAA,CAAe,GAAI,CAAA,CAAC,CAAW,KAAA;AACpC,MAAI,IAAA;AACF,QAAO,OAAA,MAAA,CAAO,CAAE,CAAA,KAAA,CAAM,KAAK,CAAA;AAAA,eACpB,EAAI,EAAA;AACX,QAAQ,OAAA,CAAA,KAAA;AAAA,UACN,YAAY,OAAO,CAAA,8BAAA,CAAA;AAAA,UACnB,EAAE,KAAM,CAAA;AAAA,SACV;AACA,QAAM,MAAA,EAAA;AAAA;AACR,KACD,CAAA;AAAA,GACH;AACA,EAAO,OAAA,EAAE,QAAQ,MAAO,EAAA;AAC1B,CAAA;AAEA,MAAM,YAAA,GAAe,CACnB,MAAA,EACA,YACyB,KAAA;AACzB,EAAA,MAAM,sBAAsB,IAAI,GAAA;AAAA,IAC9B,MAAO,CAAA,QAAA,CAAS,IAAK,CAAA,MAAA,CAClB,IAAI,CAAC,GAAA,KAAS,GAAoB,CAAA,eAAe,CACjD,CAAA,MAAA,CAAO,CAAC,CAAA,KAAM,KAAK,IAAI;AAAA,GAC5B;AACA,EAAA,MAAM,kBAAqB,GAAA,MAAA,CAAO,QAAS,CAAA,IAAA,CAAK,MAAO,CAAA,IAAA;AAAA,IACrD,CAAC,GAAS,KAAA,GAAA,CAAoB,eAAmB,IAAA;AAAA,GACnD;AAEA,EAAM,MAAA,MAAA,GAAyC,CAAC,KAAA,EAAO,cAAmB,KAAA;AACxE,IAAA,IAAI,kBAAkB,IAAM,EAAA;AAC1B,MAAA,IAAI,CAAC,mBAAA,CAAoB,GAAI,CAAA,cAAc,CAAG,EAAA;AAC5C,QAAA,MAAM,IAAI,KAAA,CAAM,CAA8B,2BAAA,EAAA,KAAK,CAAY,UAAA,CAAA,CAAA;AAAA;AAEjE,MAAA,OAAO,aAAa,cAAc,CAAA,CAAG,IAAI,KAAM,CAAA,IAAA,CAAK,SAAS,CAAA;AAAA;AAE/D,IAAA,IAAI,CAAC,kBAAoB,EAAA;AACvB,MAAM,MAAA,IAAI,MAAM,gCAAgC,CAAA;AAAA;AAElD,IAAA,OAAO,aAAa,MAAS,CAAA,CAAG,IAAI,KAAM,CAAA,IAAA,CAAK,SAAS,CAAA;AAAA,GAC1D;AACA,EAAA,MAAM,MAAyC,GAAA,CAAC,OAAS,EAAA,MAAA,GAAS,EAAO,KAAA;AACvE,IAAA,MAAM,cAAiB,GAAA,MAAA,CACpB,GAAI,CAAA,CAAC,MAAO,OAAW,IAAA,CAAA,GAAI,CAAI,GAAA,EAAE,OAAO,CAAG,EAAA,MAAA,EAAQ,CAAE,CAAA,MAAA,EAAS,CAC9D,CAAA,MAAA;AAAA,MACC,CAAC,CAAA,KACC,CAAE,CAAA,KAAA,CAAM,SAAS,WAChB,IAAA,CAAA,CAAE,KAAM,CAAA,KAAA,CAAc,SAAS,iBAC/B,IAAA,CAAA,CAAE,KAAM,CAAA,KAAA,CAAc,MAAM,QAAa,KAAA;AAAA,KAC9C;AAEF,IAAO,OAAA,cAAA,CACJ,GAAI,CAAA,CAAC,CAAM,KAAA;AACV,MAAM,MAAA,WAAA,GAAc,EAAE,MAAO,CAAA,GAAA,CAAI,CAAC,GAAQ,KAAA,GAAA,CAAI,OAAO,CAAA;AACrD,MAAA,MAAM,gBAAgB,WAAY,CAAA,IAAA;AAAA,QAAK,CAAC,KAAA,KACtC,mBAAoB,CAAA,GAAA,CAAI,KAAK;AAAA,OAC/B;AACA,MAAI,IAAA;AACF,QAAA,OAAO,MAAQ,CAAA,CAAA,CAAE,KAAM,CAAA,KAAA,CAAc,OAAO,aAAa,CAAA;AAAA,eAClD,EAAI,EAAA;AACX,QAAQ,OAAA,CAAA,KAAA,CAAM,CAAY,SAAA,EAAA,OAAO,CAAkC,8BAAA,CAAA,EAAA;AAAA,UACjE,OAAQ,CAAE,CAAA,KAAA,CAAM,KAAc,CAAA,KAAA,CAAM,KAAK,KAAM,EAAA;AAAA,UAC/C,WAAA;AAAA,UACA,mBAAA,EAAqB,CAAC,GAAG,mBAAmB,CAAA;AAAA,UAC5C;AAAA,SACD,CAAA;AACD,QAAO,OAAA,IAAA;AAAA;AACT,KACD,CACA,CAAA,MAAA,CAAO,CAAC,CAAA,KAAM,MAAM,IAAI,CAAA;AAAA,GAC7B;AAEA,EAAO,OAAA;AAAA,IACL,MAAA;AAAA,IACA;AAAA,GACF;AACF,CAAA;;;;;;"}