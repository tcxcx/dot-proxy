'use strict';

var metadataBuilders = require('@polkadot-api/metadata-builders');
var substrateBindings = require('@polkadot-api/substrate-bindings');

const getInkDynamicBuilder = (metadataLookup) => {
  const { metadata } = metadataLookup;
  const buildDefinition = metadataBuilders.getLookupCodecBuilder(metadataLookup);
  const buildStorage = (name = "") => {
    const storageEntry = metadataLookup.storage[name];
    if (!storageEntry)
      throw new Error(`Storage entry ${name ? name : "{root}"} not found`);
    const keyCodec = storageEntry.key == null ? substrateBindings._void : buildDefinition(storageEntry.key);
    return {
      key: prependBytes(keyCodec, storageEntry.keyPrefix),
      value: buildDefinition(storageEntry.typeId)
    };
  };
  const buildCallable = (callable) => {
    const argsCodec = substrateBindings.Struct(
      Object.fromEntries(
        callable.args.map((param) => [
          param.label,
          buildDefinition(param.type.type)
        ])
      )
    );
    return {
      call: prependBytes(argsCodec, callable.selector),
      value: buildDefinition(callable.returnType.type)
    };
  };
  const buildConstructor = (label) => {
    const constr = metadata.spec.constructors.find((c) => c.label === label);
    if (!constr) {
      throw new Error(`Constructor ${label} not found`);
    }
    return buildCallable(constr);
  };
  const buildMessage = (label) => {
    const message = metadata.spec.messages.find((c) => c.label === label);
    if (!message) {
      throw new Error(`Message ${label} not found`);
    }
    return buildCallable(message);
  };
  const buildEventCodec = (event) => substrateBindings.Struct(
    Object.fromEntries(
      event.args.map((param) => [
        param.label,
        buildDefinition(param.type.type)
      ])
    )
  );
  const buildEvent = (signatureTopic) => {
    const events = metadata.spec.events;
    const withType = (codec, type) => substrateBindings.enhanceCodec(
      codec,
      (evt) => evt.value,
      (value) => ({ type, value })
    );
    if (signatureTopic) {
      const event = events.find((evt) => evt.signature_topic === signatureTopic);
      return event ? withType(buildEventCodec(event), event.label) : null;
    }
    const candidates = events.filter(
      (evt) => evt.signature_topic === signatureTopic
    );
    return candidates.length ? first(candidates.map((c) => withType(buildEventCodec(c), c.label))) : null;
  };
  const buildEvents = () => substrateBindings.Variant(
    Object.fromEntries(
      metadata.spec.events.map((evt) => [evt.label, buildEventCodec(evt)])
    )
  );
  return {
    buildConstructor,
    buildMessage,
    buildStorage,
    buildEvents,
    buildEvent
  };
};
const prependBytes = (codec, hex) => {
  const bytes = substrateBindings.Binary.fromHex(hex).asBytes();
  const wrappedCodec = substrateBindings.Tuple(substrateBindings.Bytes(bytes.length), codec);
  return substrateBindings.enhanceCodec(
    wrappedCodec,
    (value) => [
      bytes,
      value
    ],
    ([, value]) => value
  );
};
const first = (codecs) => substrateBindings.createCodec(
  (x) => {
    for (const codec of codecs) {
      try {
        codec.enc(x);
      } catch (_) {
      }
    }
    throw new Error("Unable to encode");
  },
  (x) => {
    for (const codec of codecs) {
      try {
        codec.dec(x);
      } catch (_) {
      }
    }
    throw new Error("Unable to decode");
  }
);

const Variant = (inner) => substrateBindings.enhanceCodec(
  substrateBindings.ScaleEnum(inner),
  (value) => {
    if (typeof value === "string") {
      return {
        tag: value,
        value: void 0
      };
    }
    const [tag, val] = Object.entries(value)[0];
    return {
      tag,
      value: val
    };
  },
  (value) => {
    return {
      [value.tag]: value.value
    };
  }
);
const PjsVector = (inner, size) => substrateBindings.enhanceCodec(
  substrateBindings.Vector(inner, size),
  (value) => value ?? [],
  (v) => v
);
const oStr = substrateBindings.Option(substrateBindings.str);
const docs = PjsVector(substrateBindings.str);
const primitive = Variant({
  bool: substrateBindings._void,
  char: substrateBindings._void,
  str: substrateBindings._void,
  u8: substrateBindings._void,
  u16: substrateBindings._void,
  u32: substrateBindings._void,
  u64: substrateBindings._void,
  u128: substrateBindings._void,
  u256: substrateBindings._void,
  i8: substrateBindings._void,
  i16: substrateBindings._void,
  i32: substrateBindings._void,
  i64: substrateBindings._void,
  i128: substrateBindings._void,
  i256: substrateBindings._void
});
const fields = PjsVector(
  substrateBindings.Struct({
    name: oStr,
    type: substrateBindings.compactNumber,
    typeName: oStr,
    docs
  })
);
const arr = substrateBindings.Struct({
  len: substrateBindings.u32,
  type: substrateBindings.compactNumber
});
const bitSequence = substrateBindings.Struct({
  bitStoreType: substrateBindings.compactNumber,
  bitOrderType: substrateBindings.compactNumber
});
const variants = PjsVector(
  substrateBindings.Struct({
    name: substrateBindings.str,
    fields,
    index: substrateBindings.u8,
    docs
  })
);
const def = Variant({
  composite: substrateBindings.Struct({
    fields
  }),
  variant: substrateBindings.Struct({
    variants
  }),
  sequence: substrateBindings.Struct({
    type: substrateBindings.compactNumber
  }),
  array: arr,
  tuple: substrateBindings.Vector(substrateBindings.compactNumber),
  primitive,
  compact: substrateBindings.compactNumber,
  bitSequence
});
const param = substrateBindings.Struct({
  name: substrateBindings.str,
  type: substrateBindings.Option(substrateBindings.compactNumber)
});
const params = PjsVector(param);
const metadataEntry = substrateBindings.Struct({
  id: substrateBindings.compactNumber,
  path: docs,
  params,
  def,
  docs
});
const entry = substrateBindings.enhanceCodec(
  metadataEntry,
  (value) => ({
    id: value.id,
    path: value.type.path,
    params: value.type.params ?? [],
    def: value.type.def,
    docs: []
  }),
  (value) => ({
    id: value.id,
    type: {
      def: value.def,
      path: value.path,
      params: value.params
    }
  })
);
const pjsTypes = PjsVector(entry);

const getInkLookup = (metadata) => {
  const encoded = pjsTypes.enc(metadata.types);
  const decoded = substrateBindings.v14Lookup.dec(encoded);
  const accountTypeId = metadata.spec.environment.accountId.type;
  const accountIdEntry = decoded.find((e) => e.id === accountTypeId);
  if (accountIdEntry) {
    accountIdEntry.path = ["AccountId32"];
  }
  const storage = getStorageLayout(metadata, decoded);
  const getLookupEntryDef = metadataBuilders.denormalizeLookup(decoded);
  return Object.assign(getLookupEntryDef, {
    metadata,
    lookup: decoded,
    storage
  });
};
function getStorageLayout(metadata, lookup) {
  const result = {};
  const readLayout = (node, path = []) => {
    function addType(def) {
      const id = lookup.length;
      lookup[id] = {
        id,
        docs: [],
        def,
        params: [],
        path: []
      };
      return id;
    }
    if ("root" in node) {
      const keyPrefix = Number(metadata.version) === 4 ? substrateBindings.Binary.fromBytes(
        substrateBindings.Binary.fromHex(node.root.root_key).asBytes().reverse()
      ).asHex() : node.root.root_key;
      const typeId = readLayout(node.root.layout, path);
      if (node.root.ty != null) {
        let resolveType2 = function(id, path2) {
          const type = metadata.types[id].type;
          const fields = "composite" in type.def ? new Map(
            (type.def.composite.fields ?? []).map((v) => [
              v.name,
              v.type
            ])
          ) : null;
          const params = new Map(
            (type.params ?? []).map((v) => [v.name, v.type])
          );
          if (params.size === 2 && params.has("V") && fields && fields.size === 2 && fields.has("len") && fields.has("elements")) {
            resolveType2(fields.get("len"), [...path2, "len"]);
            resolveType2(fields.get("elements"), path2);
            return;
          } else if (params.size === 3 && params.has("K") && params.has("V")) {
            result[path2.join(".")] = {
              keyPrefix,
              key: params.get("K"),
              typeId: params.get("V")
            };
          } else if (params.size === 2 && params.has("V")) {
            result[path2.join(".")] = {
              keyPrefix,
              key: null,
              typeId: params.get("V")
            };
          }
        };
        resolveType2(node.root.ty, path);
      }
      if (!result[path.join(".")]) {
        result[path.join(".")] = {
          keyPrefix,
          key: null,
          typeId
        };
      }
      return addType({
        tag: "composite",
        value: []
      });
    }
    if ("leaf" in node) {
      return node.leaf.ty;
    }
    if ("hash" in node) {
      throw new Error("HashLayout not implemented");
    }
    if ("array" in node) {
      const inner2 = readLayout(node.array.layout, path);
      return inner2 == null ? null : addType({
        tag: "array",
        value: {
          len: node.array.len,
          type: inner2
        }
      });
    }
    if ("struct" in node) {
      const inner2 = node.struct.fields.map((field) => ({
        name: field.name,
        type: readLayout(field.layout, [...path, field.name]),
        typeName: void 0,
        docs: []
      })).filter((field) => field.type != null);
      return addType({
        tag: "composite",
        value: inner2
      });
    }
    const inner = Object.values(node.enum.variants).map((variant, index) => ({
      name: variant.name,
      fields: variant.fields.map((field) => ({
        name: field.name,
        type: readLayout(field.layout, [...path, variant.name, field.name]),
        typeName: void 0,
        docs: []
      })).filter((v) => v.type !== null),
      index,
      docs: []
    }));
    return addType({
      tag: "variant",
      value: inner
    });
  };
  readLayout(metadata.storage);
  return result;
}

const getInkClient = (inkContract) => {
  const lookup = getInkLookup(inkContract.metadata);
  const builder = getInkDynamicBuilder(lookup);
  return {
    constructor: buildCallable(builder.buildConstructor),
    message: buildCallable(builder.buildMessage),
    storage: buildStorage(builder.buildStorage),
    event: Number(lookup.metadata.version) === 4 ? buildEventV4(builder.buildEvents) : buildEventV5(lookup, builder.buildEvent)
  };
};
const buildCallable = (builder) => (label) => {
  const codecs = builder(label);
  return {
    encode: (value) => substrateBindings.Binary.fromBytes(codecs.call.enc(value || {})),
    decode: (response) => codecs.value.dec(response.data.asBytes())
  };
};
const buildStorage = (builder) => (label) => {
  const codecs = builder(label);
  return {
    encode: (key) => substrateBindings.Binary.fromBytes(codecs.key.enc(key)),
    decode: (response) => codecs.value.dec(response.asBytes())
  };
};
const buildEventV4 = (eventsDecoder) => {
  const decode = (value) => {
    return eventsDecoder().dec(value.data.asBytes());
  };
  const filter = (address, events = []) => {
    const contractEvents = events.map((v) => "event" in v ? v.event : v).filter(
      (v) => v.type === "Contracts" && v.value.type === "ContractEmitted" && v.value.value.contract === address
    );
    return contractEvents.map((v) => {
      try {
        return decode(v.value.value);
      } catch (ex) {
        console.error(
          `Contract ${address} emitted an incompatible event`,
          v.value.value
        );
        throw ex;
      }
    });
  };
  return { decode, filter };
};
const buildEventV5 = (lookup, eventDecoder) => {
  const metadataEventTopics = new Set(
    lookup.metadata.spec.events.map((evt) => evt.signature_topic).filter((v) => v != null)
  );
  const hasAnonymousEvents = lookup.metadata.spec.events.some(
    (evt) => evt.signature_topic == null
  );
  const decode = (value, signatureTopic) => {
    if (signatureTopic != null) {
      if (!metadataEventTopics.has(signatureTopic)) {
        throw new Error(`Event with signature topic ${value} not found`);
      }
      return eventDecoder(signatureTopic).dec(value.data.asBytes());
    }
    if (!hasAnonymousEvents) {
      throw new Error("Event signature topic required");
    }
    return eventDecoder(void 0).dec(value.data.asBytes());
  };
  const filter = (address, events = []) => {
    const contractEvents = events.map((v) => "event" in v ? v : { event: v, topics: v.topics }).filter(
      (v) => v.event.type === "Contracts" && v.event.value.type === "ContractEmitted" && v.event.value.value.contract === address
    );
    return contractEvents.map((v) => {
      const eventTopics = v.topics.map((evt) => evt.asHex());
      const suitableTopic = eventTopics.find(
        (topic) => metadataEventTopics.has(topic)
      );
      try {
        return decode(v.event.value.value, suitableTopic);
      } catch (ex) {
        console.error(`Contract ${address} emitted an incompatible event`, {
          event: v.event.value.value.data.asHex(),
          eventTopics,
          metadataEventTopics: [...metadataEventTopics],
          hasAnonymousEvents
        });
        return null;
      }
    }).filter((v) => v !== null);
  };
  return {
    decode,
    filter
  };
};

exports.getInkClient = getInkClient;
exports.getInkDynamicBuilder = getInkDynamicBuilder;
exports.getInkLookup = getInkLookup;
//# sourceMappingURL=index.js.map
