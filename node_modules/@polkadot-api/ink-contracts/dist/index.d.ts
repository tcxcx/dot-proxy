import { CodecType, Codec, StringRecord, HexString, Binary } from '@polkadot-api/substrate-bindings';
import { LookupEntry } from '@polkadot-api/metadata-builders';

type PjsVariant<O extends StringRecord<Codec<any>>> = {
    [K in keyof O]: {
        [KK in K]: CodecType<O[K]>;
    };
}[keyof O];
declare const pjsTypes: Codec<{
    id: number;
    type: {
        def: PjsVariant<{
            composite: Codec<{
                fields: {
                    name: string | undefined;
                    type: number;
                    typeName: string | undefined;
                    docs: string[];
                }[];
            }>;
            variant: Codec<{
                variants: {
                    name: string;
                    fields: {
                        name: string | undefined;
                        type: number;
                        typeName: string | undefined;
                        docs: string[];
                    }[];
                    index: number;
                    docs: string[];
                }[];
            }>;
            sequence: Codec<{
                type: number;
            }>;
            array: Codec<{
                len: number;
                type: number;
            }>;
            tuple: Codec<number[]>;
            primitive: Codec<PjsVariant<{
                bool: Codec<undefined>;
                char: Codec<undefined>;
                str: Codec<undefined>;
                u8: Codec<undefined>;
                u16: Codec<undefined>;
                u32: Codec<undefined>;
                u64: Codec<undefined>;
                u128: Codec<undefined>;
                u256: Codec<undefined>;
                i8: Codec<undefined>;
                i16: Codec<undefined>;
                i32: Codec<undefined>;
                i64: Codec<undefined>;
                i128: Codec<undefined>;
                i256: Codec<undefined>;
            }>>;
            compact: Codec<number>;
            bitSequence: Codec<{
                bitStoreType: number;
                bitOrderType: number;
            }>;
        }>;
        path: string[];
        params: {
            name: string;
            type: number | undefined;
        }[];
    };
}[]>;
type PjsTypes = CodecType<typeof pjsTypes>;

interface InkMetadataV4 {
    source: InkSource;
    spec: InkSpecV4;
    storage: RootLayout;
    types: PjsTypes;
    version: "4";
    user?: Record<string, unknown>;
}
interface InkSpecV4 {
    constructors: ConstructorSpec[];
    messages: MessageSpec[];
    environment: EnvironmentSpecV4;
    events: EventSpecV4[];
    docs: string[];
    lang_error: TypeSpec;
}
interface InkMetadataV5 {
    source: InkSource;
    spec: InkSpecV5;
    storage: RootLayout;
    types: PjsTypes;
    version: 5;
}
type InkMetadata = InkMetadataV4 | InkMetadataV5;
interface InkSource {
    hash: HexString;
    language: string;
    compiler: string;
    wasm?: HexString;
    build_info?: Record<string, unknown>;
}
interface InkContractInfo {
    name: string;
    version: string;
    authors: string[];
    description?: string;
    repository?: string;
    homepage?: string;
    license?: string;
}
interface InkSpecV5 {
    constructors: ConstructorSpec[];
    messages: MessageSpec[];
    environment: EnvironmentSpecV5;
    events: EventSpecV5[];
    lang_error: TypeSpec;
}
interface ConstructorSpec {
    label: string;
    selector: string;
    payable: boolean;
    default: boolean;
    args: Array<MessageParamSpec>;
    returnType: TypeSpec;
    docs: string[];
}
interface MessageSpec {
    label: string;
    selector: string;
    mutates: boolean;
    payable: boolean;
    args: Array<MessageParamSpec>;
    returnType: TypeSpec;
    docs: string[];
    default: boolean;
}
interface EnvironmentSpecV4 {
    accountId: TypeSpec;
    balance: TypeSpec;
    timestamp: TypeSpec;
    blockNumber: TypeSpec;
    chainExtension: TypeSpec;
    maxEventTopics: number;
}
interface EnvironmentSpecV5 extends EnvironmentSpecV4 {
    staticBufferSize: number;
}
interface MessageParamSpec {
    label: string;
    type: TypeSpec;
}
interface EventSpecV4 {
    label: string;
    args: EventParamSpec[];
    docs: string[];
}
interface EventSpecV5 extends EventSpecV4 {
    modulePath: string;
    signature_topic?: string;
}
interface EventParamSpec {
    label: string;
    indexed: number;
    type: TypeSpec;
    docs: string[];
}
interface TypeSpec {
    type: number;
    displayName: string[];
}
type Layout = LeafLayout | RootLayout | HashLayout | ArrayLayout | StructLayout | EnumLayout;
interface LeafLayout {
    leaf: {
        key: string;
        ty: number;
    };
}
interface RootLayout {
    root: {
        root_key: string;
        layout: Layout;
        ty?: number;
    };
}
interface HashLayout {
    hash: {
        offset: string;
        strategy: {
            hasher: "Blake2x256" | "Sha2x256" | "Keccak256";
            prefix: string;
            postfix: string;
        };
        layout: Layout;
    };
}
interface ArrayLayout {
    array: {
        offset: string;
        len: number;
        layout: Layout;
    };
}
interface StructLayout {
    struct: {
        name: string;
        fields: Array<FieldLayout>;
    };
}
interface EnumLayout {
    enum: {
        name: string;
        dispatchKey: string;
        variants: Record<number, {
            name: string;
            fields: Array<FieldLayout>;
        }>;
    };
}
interface FieldLayout {
    name: string;
    layout: Layout;
}

interface InkMetadataLookup {
    (id: number): LookupEntry;
    metadata: InkMetadata;
    storage: StorageLayout;
}
interface StorageEntryPoint {
    keyPrefix: string;
    key: number | null;
    typeId: number;
}
type StorageLayout = Record<string, StorageEntryPoint>;
declare const getInkLookup: (metadata: InkMetadata) => InkMetadataLookup;

declare const getInkDynamicBuilder: (metadataLookup: InkMetadataLookup) => {
    buildConstructor: (label: string) => {
        call: Codec<{
            [x: symbol]: never;
            [x: number]: never;
            [x: string]: any;
        }>;
        value: Codec<any>;
    };
    buildMessage: (label: string) => {
        call: Codec<{
            [x: symbol]: never;
            [x: number]: never;
            [x: string]: any;
        }>;
        value: Codec<any>;
    };
    buildStorage: (name?: string) => {
        key: Codec<undefined>;
        value: Codec<any>;
    };
    buildEvents: () => Codec<{
        type: string;
        value: any;
    }>;
    buildEvent: (signatureTopic: string | undefined) => Codec<{
        type: string;
        value: {
            [x: symbol]: never;
            [x: number]: never;
            [x: string]: any;
        };
    }> | null;
};
type InkDynamicBuilder = ReturnType<typeof getInkDynamicBuilder>;

type Event = {
    type: string;
    value: unknown;
};
interface InkDescriptors<S extends InkStorageDescriptor, M extends InkCallableDescriptor, C extends InkCallableDescriptor, E extends Event> {
    metadata: InkMetadata;
    __types: {
        storage: S;
        messages: M;
        constructors: C;
        event: E;
    };
}
type InkCallableDescriptor = Record<string, {
    message: StringRecord<unknown>;
    response: StringRecord<unknown>;
}>;
type InkStorageDescriptor = Record<string, {
    key: unknown;
    value: unknown;
}>;

type InkCallableInterface<T extends InkCallableDescriptor> = <L extends string & keyof T>(label: L) => {
    encode: {} extends T[L]["message"] ? (value?: T[L]["message"]) => Binary : (value: T[L]["message"]) => Binary;
    decode: (value: {
        data: Binary;
    }) => T[L]["response"];
};
type InkStorageInterface<S extends InkStorageDescriptor> = ("" extends keyof S ? () => {
    encode: S[""]["key"] extends undefined ? (key?: undefined) => Binary : (key: S[""]["key"]) => Binary;
    decode: (data: Binary) => S[""]["value"];
} : unknown) & (<L extends string & keyof S>(label: L) => {
    encode: S[L]["key"] extends undefined ? (key?: undefined) => Binary : (key: S[L]["key"]) => Binary;
    decode: (data: Binary) => S[L]["value"];
});
type GenericEvent = {
    type: "Contracts";
    value: {
        type: "ContractEmitted";
        value: {
            contract: string;
            data: Binary;
        };
    } | {
        type: string;
        value: unknown;
    };
} | {
    type: string;
    value: unknown;
};
interface InkEventInterface<E> {
    decode: (value: {
        data: Binary;
    }, signatureTopic?: string) => E;
    filter: (address: string, events?: Array<{
        event: GenericEvent;
        topics: Binary[];
    } | (GenericEvent & {
        topics: Binary[];
    })>) => E[];
}
interface InkClient<D extends InkDescriptors<InkStorageDescriptor, InkCallableDescriptor, InkCallableDescriptor, Event>> {
    constructor: InkCallableInterface<D["__types"]["constructors"]>;
    message: InkCallableInterface<D["__types"]["messages"]>;
    storage: InkStorageInterface<D["__types"]["storage"]>;
    event: InkEventInterface<D["__types"]["event"]>;
}
declare const getInkClient: <D extends InkDescriptors<InkStorageDescriptor, InkCallableDescriptor, InkCallableDescriptor, Event>>(inkContract: D) => InkClient<D>;

export { type ArrayLayout, type EnumLayout, type Event, type EventParamSpec, type EventSpecV5, type FieldLayout, type GenericEvent, type HashLayout, type InkCallableDescriptor, type InkCallableInterface, type InkClient, type InkContractInfo, type InkDescriptors, type InkDynamicBuilder, type InkEventInterface, type InkMetadata, type InkMetadataLookup, type InkSource, type InkStorageDescriptor, type InkStorageInterface, type Layout, type LeafLayout, type MessageParamSpec, type RootLayout, type StorageEntryPoint, type StorageLayout, type StructLayout, type TypeSpec, getInkClient, getInkDynamicBuilder, getInkLookup };
