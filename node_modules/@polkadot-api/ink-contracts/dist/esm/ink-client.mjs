import { Binary } from '@polkadot-api/substrate-bindings';
import { getInkDynamicBuilder } from './dynamic-builders.mjs';
import { getInkLookup } from './get-lookup.mjs';

const getInkClient = (inkContract) => {
  const lookup = getInkLookup(inkContract.metadata);
  const builder = getInkDynamicBuilder(lookup);
  return {
    constructor: buildCallable(builder.buildConstructor),
    message: buildCallable(builder.buildMessage),
    storage: buildStorage(builder.buildStorage),
    event: Number(lookup.metadata.version) === 4 ? buildEventV4(builder.buildEvents) : buildEventV5(lookup, builder.buildEvent)
  };
};
const buildCallable = (builder) => (label) => {
  const codecs = builder(label);
  return {
    encode: (value) => Binary.fromBytes(codecs.call.enc(value || {})),
    decode: (response) => codecs.value.dec(response.data.asBytes())
  };
};
const buildStorage = (builder) => (label) => {
  const codecs = builder(label);
  return {
    encode: (key) => Binary.fromBytes(codecs.key.enc(key)),
    decode: (response) => codecs.value.dec(response.asBytes())
  };
};
const buildEventV4 = (eventsDecoder) => {
  const decode = (value) => {
    return eventsDecoder().dec(value.data.asBytes());
  };
  const filter = (address, events = []) => {
    const contractEvents = events.map((v) => "event" in v ? v.event : v).filter(
      (v) => v.type === "Contracts" && v.value.type === "ContractEmitted" && v.value.value.contract === address
    );
    return contractEvents.map((v) => {
      try {
        return decode(v.value.value);
      } catch (ex) {
        console.error(
          `Contract ${address} emitted an incompatible event`,
          v.value.value
        );
        throw ex;
      }
    });
  };
  return { decode, filter };
};
const buildEventV5 = (lookup, eventDecoder) => {
  const metadataEventTopics = new Set(
    lookup.metadata.spec.events.map((evt) => evt.signature_topic).filter((v) => v != null)
  );
  const hasAnonymousEvents = lookup.metadata.spec.events.some(
    (evt) => evt.signature_topic == null
  );
  const decode = (value, signatureTopic) => {
    if (signatureTopic != null) {
      if (!metadataEventTopics.has(signatureTopic)) {
        throw new Error(`Event with signature topic ${value} not found`);
      }
      return eventDecoder(signatureTopic).dec(value.data.asBytes());
    }
    if (!hasAnonymousEvents) {
      throw new Error("Event signature topic required");
    }
    return eventDecoder(void 0).dec(value.data.asBytes());
  };
  const filter = (address, events = []) => {
    const contractEvents = events.map((v) => "event" in v ? v : { event: v, topics: v.topics }).filter(
      (v) => v.event.type === "Contracts" && v.event.value.type === "ContractEmitted" && v.event.value.value.contract === address
    );
    return contractEvents.map((v) => {
      const eventTopics = v.topics.map((evt) => evt.asHex());
      const suitableTopic = eventTopics.find(
        (topic) => metadataEventTopics.has(topic)
      );
      try {
        return decode(v.event.value.value, suitableTopic);
      } catch (ex) {
        console.error(`Contract ${address} emitted an incompatible event`, {
          event: v.event.value.value.data.asHex(),
          eventTopics,
          metadataEventTopics: [...metadataEventTopics],
          hasAnonymousEvents
        });
        return null;
      }
    }).filter((v) => v !== null);
  };
  return {
    decode,
    filter
  };
};

export { getInkClient };
//# sourceMappingURL=ink-client.mjs.map
