import { getLookupCodecBuilder } from '@polkadot-api/metadata-builders';
import { Variant, _void, enhanceCodec, Struct, createCodec, Binary, Tuple, Bytes } from '@polkadot-api/substrate-bindings';

const getInkDynamicBuilder = (metadataLookup) => {
  const { metadata } = metadataLookup;
  const buildDefinition = getLookupCodecBuilder(metadataLookup);
  const buildStorage = (name = "") => {
    const storageEntry = metadataLookup.storage[name];
    if (!storageEntry)
      throw new Error(`Storage entry ${name ? name : "{root}"} not found`);
    const keyCodec = storageEntry.key == null ? _void : buildDefinition(storageEntry.key);
    return {
      key: prependBytes(keyCodec, storageEntry.keyPrefix),
      value: buildDefinition(storageEntry.typeId)
    };
  };
  const buildCallable = (callable) => {
    const argsCodec = Struct(
      Object.fromEntries(
        callable.args.map((param) => [
          param.label,
          buildDefinition(param.type.type)
        ])
      )
    );
    return {
      call: prependBytes(argsCodec, callable.selector),
      value: buildDefinition(callable.returnType.type)
    };
  };
  const buildConstructor = (label) => {
    const constr = metadata.spec.constructors.find((c) => c.label === label);
    if (!constr) {
      throw new Error(`Constructor ${label} not found`);
    }
    return buildCallable(constr);
  };
  const buildMessage = (label) => {
    const message = metadata.spec.messages.find((c) => c.label === label);
    if (!message) {
      throw new Error(`Message ${label} not found`);
    }
    return buildCallable(message);
  };
  const buildEventCodec = (event) => Struct(
    Object.fromEntries(
      event.args.map((param) => [
        param.label,
        buildDefinition(param.type.type)
      ])
    )
  );
  const buildEvent = (signatureTopic) => {
    const events = metadata.spec.events;
    const withType = (codec, type) => enhanceCodec(
      codec,
      (evt) => evt.value,
      (value) => ({ type, value })
    );
    if (signatureTopic) {
      const event = events.find((evt) => evt.signature_topic === signatureTopic);
      return event ? withType(buildEventCodec(event), event.label) : null;
    }
    const candidates = events.filter(
      (evt) => evt.signature_topic === signatureTopic
    );
    return candidates.length ? first(candidates.map((c) => withType(buildEventCodec(c), c.label))) : null;
  };
  const buildEvents = () => Variant(
    Object.fromEntries(
      metadata.spec.events.map((evt) => [evt.label, buildEventCodec(evt)])
    )
  );
  return {
    buildConstructor,
    buildMessage,
    buildStorage,
    buildEvents,
    buildEvent
  };
};
const prependBytes = (codec, hex) => {
  const bytes = Binary.fromHex(hex).asBytes();
  const wrappedCodec = Tuple(Bytes(bytes.length), codec);
  return enhanceCodec(
    wrappedCodec,
    (value) => [
      bytes,
      value
    ],
    ([, value]) => value
  );
};
const first = (codecs) => createCodec(
  (x) => {
    for (const codec of codecs) {
      try {
        codec.enc(x);
      } catch (_) {
      }
    }
    throw new Error("Unable to encode");
  },
  (x) => {
    for (const codec of codecs) {
      try {
        codec.dec(x);
      } catch (_) {
      }
    }
    throw new Error("Unable to decode");
  }
);

export { getInkDynamicBuilder };
//# sourceMappingURL=dynamic-builders.mjs.map
