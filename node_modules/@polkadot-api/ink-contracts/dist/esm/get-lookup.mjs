import { denormalizeLookup } from '@polkadot-api/metadata-builders';
import { v14Lookup, Binary } from '@polkadot-api/substrate-bindings';
import { pjsTypes } from './metadata-pjs-types.mjs';

const getInkLookup = (metadata) => {
  const encoded = pjsTypes.enc(metadata.types);
  const decoded = v14Lookup.dec(encoded);
  const accountTypeId = metadata.spec.environment.accountId.type;
  const accountIdEntry = decoded.find((e) => e.id === accountTypeId);
  if (accountIdEntry) {
    accountIdEntry.path = ["AccountId32"];
  }
  const storage = getStorageLayout(metadata, decoded);
  const getLookupEntryDef = denormalizeLookup(decoded);
  return Object.assign(getLookupEntryDef, {
    metadata,
    lookup: decoded,
    storage
  });
};
function getStorageLayout(metadata, lookup) {
  const result = {};
  const readLayout = (node, path = []) => {
    function addType(def) {
      const id = lookup.length;
      lookup[id] = {
        id,
        docs: [],
        def,
        params: [],
        path: []
      };
      return id;
    }
    if ("root" in node) {
      const keyPrefix = Number(metadata.version) === 4 ? Binary.fromBytes(
        Binary.fromHex(node.root.root_key).asBytes().reverse()
      ).asHex() : node.root.root_key;
      const typeId = readLayout(node.root.layout, path);
      if (node.root.ty != null) {
        let resolveType2 = function(id, path2) {
          const type = metadata.types[id].type;
          const fields = "composite" in type.def ? new Map(
            (type.def.composite.fields ?? []).map((v) => [
              v.name,
              v.type
            ])
          ) : null;
          const params = new Map(
            (type.params ?? []).map((v) => [v.name, v.type])
          );
          if (params.size === 2 && params.has("V") && fields && fields.size === 2 && fields.has("len") && fields.has("elements")) {
            resolveType2(fields.get("len"), [...path2, "len"]);
            resolveType2(fields.get("elements"), path2);
            return;
          } else if (params.size === 3 && params.has("K") && params.has("V")) {
            result[path2.join(".")] = {
              keyPrefix,
              key: params.get("K"),
              typeId: params.get("V")
            };
          } else if (params.size === 2 && params.has("V")) {
            result[path2.join(".")] = {
              keyPrefix,
              key: null,
              typeId: params.get("V")
            };
          }
        };
        resolveType2(node.root.ty, path);
      }
      if (!result[path.join(".")]) {
        result[path.join(".")] = {
          keyPrefix,
          key: null,
          typeId
        };
      }
      return addType({
        tag: "composite",
        value: []
      });
    }
    if ("leaf" in node) {
      return node.leaf.ty;
    }
    if ("hash" in node) {
      throw new Error("HashLayout not implemented");
    }
    if ("array" in node) {
      const inner2 = readLayout(node.array.layout, path);
      return inner2 == null ? null : addType({
        tag: "array",
        value: {
          len: node.array.len,
          type: inner2
        }
      });
    }
    if ("struct" in node) {
      const inner2 = node.struct.fields.map((field) => ({
        name: field.name,
        type: readLayout(field.layout, [...path, field.name]),
        typeName: void 0,
        docs: []
      })).filter((field) => field.type != null);
      return addType({
        tag: "composite",
        value: inner2
      });
    }
    const inner = Object.values(node.enum.variants).map((variant, index) => ({
      name: variant.name,
      fields: variant.fields.map((field) => ({
        name: field.name,
        type: readLayout(field.layout, [...path, variant.name, field.name]),
        typeName: void 0,
        docs: []
      })).filter((v) => v.type !== null),
      index,
      docs: []
    }));
    return addType({
      tag: "variant",
      value: inner
    });
  };
  readLayout(metadata.storage);
  return result;
}

export { getInkLookup };
//# sourceMappingURL=get-lookup.mjs.map
