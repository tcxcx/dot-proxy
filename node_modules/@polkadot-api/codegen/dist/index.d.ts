import { MetadataLookup, getChecksumBuilder } from '@polkadot-api/metadata-builders';
import { V15, V14, HexString } from '@polkadot-api/substrate-bindings';
import { TypedefNode, EntryPoint } from '@polkadot-api/metadata-compatibility';
import { InkMetadataLookup } from '@polkadot-api/ink-contracts';

interface CodegenOutput {
    code: string;
    imports: Record<string, Set<string>>;
}

type KnownTypes = Record<string, {
    name: string;
    priority: number;
}>;
type RepositoryEntry = string | {
    name: string;
    paths?: string[];
    type?: string;
    chains?: string;
    priority?: number;
};
declare const knownTypesRepository: Record<string, RepositoryEntry>;
declare const knownTypes: KnownTypes;

interface Variable {
    name: string;
    checksum: string;
    type: string;
}
interface CodeDeclarations {
    imports: Set<string>;
    variables: Map<string, Variable>;
    takenNames: Set<string>;
}
declare const defaultDeclarations: () => CodeDeclarations;
declare const getTypesBuilder: (declarations: CodeDeclarations, getLookupEntryDef: MetadataLookup, knownTypes: KnownTypes, checksumBuilder: ReturnType<typeof getChecksumBuilder>) => {
    buildTypeDefinition: (id: number) => string;
    buildDefinition: (id: number) => CodegenOutput;
    buildStorage: (pallet: string, entry: string) => {
        key: string;
        val: string;
        opaque: string;
    };
    buildEvent: (pallet: string, name: string) => string;
    buildError: (pallet: string, name: string) => string;
    buildCall: (pallet: string, name: string) => string;
    buildRuntimeCall: (api: string, method: string) => {
        args: string;
        value: string;
    };
    buildConstant: (pallet: string, constantName: string) => string;
    getTypeFileImports: () => string[];
    getClientFileImports: () => string[];
};
declare const getDocsTypesBuilder: (getLookupEntryDef: MetadataLookup, knownTypes: KnownTypes, checksumBuilder: ReturnType<typeof getChecksumBuilder>) => {
    buildStorage: (pallet: string, entry: string) => {
        opaque: string;
        args: string;
        payload: string;
    };
    buildRuntimeCall: (api: string, method: string) => {
        args: string;
        value: string;
    };
    buildEvent: (pallet: string, name: string) => string;
    buildError: (pallet: string, name: string) => string;
    buildCall: (pallet: string, name: string) => string;
    buildConstant: (pallet: string, constantName: string) => string;
    declarations: CodeDeclarations;
    recordTypeFileImports: () => string[];
    getClientFileImports: () => string[];
    getDescriptorsTypes: () => Variable[];
};

type ArraVal<T extends Array<any>> = T extends Array<infer V> ? V : unknown;
declare const getNewTypes: (lookup: MetadataLookup, knownTypes: KnownTypes, getTypeName: (data: ArraVal<V15["lookup"]>) => string | null) => {
    [k: string]: {
        name: string;
        checksum: string;
        type: string;
        path: string[];
    };
};

declare const customStringifyObject: (input: string | Record<string, any> | Array<any>) => string;
type DescriptorValues = Record<"storage" | "tx" | "events" | "constants" | "apis", Record<string, Record<string, number>>>;
declare function capitalize(value: string): string;
declare const generateDescriptors: (lookupFn: MetadataLookup, checksumToIdx: Map<string, number>, typesBuilder: ReturnType<typeof getTypesBuilder>, checksumBuilder: ReturnType<typeof getChecksumBuilder>, key: string, paths: {
    client: string;
    metadataTypes: string;
    types: string;
    descriptorValues: string;
}, genesis?: string) => {
    descriptorTypes: string;
    descriptorValues: DescriptorValues;
    exports: string[];
};
declare function getAssetId(lookup: MetadataLookup): number | undefined;
declare function getDispatchErrorId(lookup: MetadataLookup): number | undefined;

declare const generateMultipleDescriptors: (chains: Array<{
    key: string;
    metadata: V14 | V15;
    knownTypes: KnownTypes;
    genesis?: HexString;
}>, paths: {
    client: string;
    metadataTypes: string;
    types: string;
    descriptorValues: string;
}, options?: {
    whitelist?: string[];
}) => {
    descriptorsFileContent: string;
    metadataTypes: {
        typedefs: TypedefNode[];
        entryPoints: EntryPoint[];
        checksumToIdx: Map<string, number>;
    };
    descriptorTypesFiles: {
        content: string;
        exports: string[];
    }[];
    typesFileContent: string;
    publicTypes: string[];
};

type FileTree = {
    [key: string]: string | FileTree;
};
declare function generateDocsDescriptors(key: string, metadata: V14 | V15): Promise<FileTree>;

declare function generateInkTypes(lookup: InkMetadataLookup): string;

export { type CodeDeclarations, type DescriptorValues, type FileTree, type KnownTypes, type Variable, capitalize, customStringifyObject, defaultDeclarations, generateDescriptors, generateDocsDescriptors, generateInkTypes, generateMultipleDescriptors, getAssetId, getDispatchErrorId, getDocsTypesBuilder, getNewTypes, getTypesBuilder, knownTypes, knownTypesRepository };
