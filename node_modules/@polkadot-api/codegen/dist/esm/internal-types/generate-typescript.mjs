const nativeNodeCodegen = (node, next) => {
  if (node.type === "primitive") return onlyCode(node.value);
  if (node.type === "chainPrimitive")
    throw new Error("Can't generate chain primitive type " + node.value);
  if (node.type === "result" || node.type === "enum" || node.type === "fixedSizeBinary")
    throw new Error("Can't generate chain primitive type " + node.type);
  if (node.type === "array") {
    const { code, imports } = next(node.value.value);
    return { code: `Array<${code}>`, imports };
  }
  if (node.type === "struct") {
    return generateObjectCode(node.value, next);
  }
  if (node.type === "tuple") {
    const tupleResults = node.value.map(({ value }) => next(value));
    return {
      code: `[${tupleResults.map(({ code }) => code).join(", ")}]`,
      imports: mergeImports(tupleResults.map(({ imports }) => imports))
    };
  }
  if (node.type === "union") {
    if (node.value.length === 1) return next(node.value[0]);
    const partResults = node.value.map(next);
    return {
      code: partResults.map(({ code }) => `(${code})`).join(" | "),
      imports: mergeImports(partResults.map(({ imports }) => imports))
    };
  }
  const optionResult = next(node.value);
  return {
    code: `(${optionResult.code}) | undefined`,
    imports: optionResult.imports
  };
};
function generateTypescript(node, getNodeCode) {
  const next = (node2, level) => getNodeCode(node2, (v) => next(v, level + 1), level);
  return next(node, 0);
}
function processPapiPrimitives(node, getCode, isKnown) {
  const clientImport = (value) => ({ client: /* @__PURE__ */ new Set([value]) });
  if (node.type === "chainPrimitive") {
    return node.value === "BitSequence" ? onlyCode(`{bytes: Uint8Array, bitsLen: number}`) : {
      code: node.value,
      imports: {
        client: /* @__PURE__ */ new Set([node.value])
      }
    };
  }
  if (node.type === "result") {
    const okResult = getCode(node.value.ok);
    const koResult = getCode(node.value.ko);
    return {
      code: `ResultPayload<${okResult.code}, ${koResult.code}>`,
      imports: mergeImports([
        okResult.imports,
        koResult.imports,
        clientImport("ResultPayload")
      ])
    };
  }
  if (node.type === "enum") {
    const innerCode = generateObjectCode(node.value, getCode);
    if (!isKnown) {
      return {
        code: `AnonymousEnum<${innerCode.code}>`,
        imports: innerCode.imports
      };
    }
    return {
      code: `Enum<${innerCode.code}>`,
      imports: mergeImports([innerCode.imports, clientImport("Enum")])
    };
  }
  if (node.type === "fixedSizeBinary") {
    return {
      code: `FixedSizeBinary<${node.value}>`,
      imports: clientImport("FixedSizeBinary")
    };
  }
  if (node.type === "array" && node.value.len) {
    const { code, imports } = getCode(node.value.value);
    return {
      code: `FixedSizeArray<${node.value.len}, ${code}>`,
      imports: mergeImports([imports, clientImport("FixedSizeArray")])
    };
  }
  return null;
}
const generateObjectCode = (fields, next) => {
  const innerValues = fields.map((field) => ({
    ...field,
    result: field.value ? next(field.value) : null
  }));
  return {
    code: `{${innerValues.map(({ label, docs, value, result }) => {
      const docsPrefix = docs.length ? `
/**
${docs.map((doc) => ` *${doc}`).join("\n")}
 */
` : "";
      if (result === null)
        return docsPrefix + `${JSON.stringify(label)}: undefined`;
      const isOptional = value?.type === "option";
      const key = JSON.stringify(label) + (isOptional ? "?" : "");
      return docsPrefix + `${key}: ${result.code}`;
    }).join(", ")}}`,
    imports: mergeImports(innerValues.map((v) => v.result?.imports ?? {}))
  };
};
const mergeImports = (imports) => {
  if (!imports.length) return {};
  const result = { ...imports[0] };
  for (let i = 1; i < imports.length; i++) {
    Object.entries(imports[i]).forEach(
      ([type, value]) => result[type] = /* @__PURE__ */ new Set([...result[type] ?? [], ...value])
    );
  }
  return result;
};
const onlyCode = (code) => ({ code, imports: {} });

export { generateObjectCode, generateTypescript, mergeImports, nativeNodeCodegen, onlyCode, processPapiPrimitives };
//# sourceMappingURL=generate-typescript.mjs.map
