{"version":3,"file":"internal-types-builder.mjs","sources":["../../../src/internal-types/internal-types-builder.ts"],"sourcesContent":["import {\n  ArrayVar,\n  EnumVar,\n  LookupEntry,\n  MetadataPrimitives,\n  StructVar,\n  TupleVar,\n} from \"@polkadot-api/metadata-builders\"\nimport {\n  ArrayType,\n  EnumVariant,\n  FixedSizeBinary,\n  LookupTypeNode,\n  NativeType,\n  StructType,\n  TupleType,\n  TypeNode,\n} from \"./type-representation\"\nimport { withCache } from \"./with-cache\"\n\nexport const primitiveTypes: Record<\n  MetadataPrimitives | \"compactNumber\" | \"compactBn\",\n  NativeType\n> = {\n  bool: \"boolean\",\n  char: \"string\",\n  str: \"string\",\n  u8: \"number\",\n  u16: \"number\",\n  u32: \"number\",\n  u64: \"bigint\",\n  u128: \"bigint\",\n  u256: \"bigint\",\n  i8: \"number\",\n  i16: \"number\",\n  i32: \"number\",\n  i64: \"bigint\",\n  i128: \"bigint\",\n  i256: \"bigint\",\n  compactNumber: \"number\",\n  compactBn: \"bigint\",\n}\n\nconst buildType = withCache(\n  (\n    input: LookupEntry,\n    cache: Map<number, LookupTypeNode>,\n    stack: Set<number>,\n  ): LookupTypeNode => {\n    const buildNextType = (nextInput: LookupEntry) =>\n      buildType(nextInput, cache, stack)\n\n    const ltn = <T extends TypeNode[\"type\"]>(\n      type: T,\n      value: (TypeNode & { type: T })[\"value\"],\n    ): LookupTypeNode =>\n      ({\n        id: input.id,\n        type,\n        value,\n      }) as LookupTypeNode\n\n    if (input.type === \"primitive\")\n      return ltn(\"primitive\", primitiveTypes[input.value])\n    if (input.type === \"void\") return ltn(\"primitive\", \"undefined\")\n    if (input.type === \"AccountId20\") return ltn(\"chainPrimitive\", \"HexString\")\n    if (input.type === \"AccountId32\") return ltn(\"chainPrimitive\", \"SS58String\")\n    if (input.type === \"compact\") {\n      const value: TypeNode[] = []\n      value.push({\n        type: \"primitive\",\n        value: input.isBig ? \"bigint\" : \"number\",\n      })\n\n      return ltn(\"union\", value)\n    }\n    if (input.type === \"bitSequence\")\n      return ltn(\"chainPrimitive\", \"BitSequence\")\n\n    if (\n      input.type === \"sequence\" &&\n      input.value.type === \"primitive\" &&\n      input.value.value === \"u8\"\n    )\n      return ltn(\"chainPrimitive\", \"Binary\")\n\n    const buildArray = (array: ArrayVar): ArrayType | FixedSizeBinary => {\n      const { value, len } = array\n      if (value.type === \"primitive\" && value.value === \"u8\") {\n        return { type: \"fixedSizeBinary\", value: len }\n      }\n      return {\n        type: \"array\",\n        value: { value: buildNextType(value), len },\n        original: array,\n      }\n    }\n    const buildTuple = (tuple: TupleVar): TupleType => {\n      const { value, innerDocs } = tuple\n\n      return {\n        type: \"tuple\",\n        value: value.map((v, i) => ({\n          value: buildNextType(v),\n          docs: innerDocs[i] ?? [],\n        })),\n        original: tuple,\n      }\n    }\n    const buildStruct = (struct: StructVar): StructType => {\n      const { value, innerDocs } = struct\n      return {\n        type: \"struct\",\n        value: Object.entries(value).map(([label, value]) => ({\n          label,\n          docs: innerDocs[label] ?? [],\n          value: buildNextType(value),\n        })),\n        original: struct,\n      }\n    }\n\n    if (input.type === \"array\") return { id: input.id, ...buildArray(input) }\n    if (input.type === \"sequence\")\n      return ltn(\"array\", { value: buildNextType(input.value) })\n    if (input.type === \"tuple\") return { id: input.id, ...buildTuple(input) }\n    if (input.type === \"struct\") return { id: input.id, ...buildStruct(input) }\n\n    if (input.type === \"option\")\n      return ltn(\"option\", buildNextType(input.value))\n\n    if (input.type === \"result\")\n      return ltn(\"result\", {\n        ok: buildNextType(input.value.ok),\n        ko: buildNextType(input.value.ko),\n      })\n\n    // it has to be an enum by now\n    const buildInnerType = (\n      value: EnumVar[\"value\"][string],\n    ):\n      | LookupTypeNode\n      | TupleType\n      | StructType\n      | ArrayType\n      | FixedSizeBinary\n      | undefined => {\n      switch (value.type) {\n        case \"lookupEntry\":\n          return buildNextType(value.value)\n        case \"void\":\n          return undefined\n        case \"array\":\n          return buildArray(value)\n        case \"struct\":\n          return buildStruct(value)\n        case \"tuple\":\n          return buildTuple(value)\n      }\n    }\n\n    const variants = Object.entries(input.value).map(\n      ([label, value]): EnumVariant => ({\n        docs: input.innerDocs[label] ?? [],\n        label: label,\n        value: buildInnerType(value),\n      }),\n    )\n    return ltn(\"enum\", variants)\n  },\n  (_, circular) => ({\n    id: circular.id,\n    optional: circular.type === \"option\",\n    type: \"primitive\" as const,\n    value: \"undefined\" as const,\n  }),\n  (result, tmp) => Object.assign(tmp, result),\n)\n\nexport const getInternalTypesBuilder = (\n  lookup: (id: number) => LookupEntry,\n) => {\n  const cache = new Map<number, LookupTypeNode>()\n\n  return (id: number): LookupTypeNode => buildType(lookup(id), cache, new Set())\n}\n"],"names":["value"],"mappings":"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"}