import { withCache } from './with-cache.mjs';

const primitiveTypes = {
  bool: "boolean",
  char: "string",
  str: "string",
  u8: "number",
  u16: "number",
  u32: "number",
  u64: "bigint",
  u128: "bigint",
  u256: "bigint",
  i8: "number",
  i16: "number",
  i32: "number",
  i64: "bigint",
  i128: "bigint",
  i256: "bigint",
  compactNumber: "number",
  compactBn: "bigint"
};
const buildType = withCache(
  (input, cache, stack) => {
    const buildNextType = (nextInput) => buildType(nextInput, cache, stack);
    const ltn = (type, value) => ({
      id: input.id,
      type,
      value
    });
    if (input.type === "primitive")
      return ltn("primitive", primitiveTypes[input.value]);
    if (input.type === "void") return ltn("primitive", "undefined");
    if (input.type === "AccountId20") return ltn("chainPrimitive", "HexString");
    if (input.type === "AccountId32") return ltn("chainPrimitive", "SS58String");
    if (input.type === "compact") {
      const value = [];
      value.push({
        type: "primitive",
        value: input.isBig ? "bigint" : "number"
      });
      return ltn("union", value);
    }
    if (input.type === "bitSequence")
      return ltn("chainPrimitive", "BitSequence");
    if (input.type === "sequence" && input.value.type === "primitive" && input.value.value === "u8")
      return ltn("chainPrimitive", "Binary");
    const buildArray = (array) => {
      const { value, len } = array;
      if (value.type === "primitive" && value.value === "u8") {
        return { type: "fixedSizeBinary", value: len };
      }
      return {
        type: "array",
        value: { value: buildNextType(value), len },
        original: array
      };
    };
    const buildTuple = (tuple) => {
      const { value, innerDocs } = tuple;
      return {
        type: "tuple",
        value: value.map((v, i) => ({
          value: buildNextType(v),
          docs: innerDocs[i] ?? []
        })),
        original: tuple
      };
    };
    const buildStruct = (struct) => {
      const { value, innerDocs } = struct;
      return {
        type: "struct",
        value: Object.entries(value).map(([label, value2]) => ({
          label,
          docs: innerDocs[label] ?? [],
          value: buildNextType(value2)
        })),
        original: struct
      };
    };
    if (input.type === "array") return { id: input.id, ...buildArray(input) };
    if (input.type === "sequence")
      return ltn("array", { value: buildNextType(input.value) });
    if (input.type === "tuple") return { id: input.id, ...buildTuple(input) };
    if (input.type === "struct") return { id: input.id, ...buildStruct(input) };
    if (input.type === "option")
      return ltn("option", buildNextType(input.value));
    if (input.type === "result")
      return ltn("result", {
        ok: buildNextType(input.value.ok),
        ko: buildNextType(input.value.ko)
      });
    const buildInnerType = (value) => {
      switch (value.type) {
        case "lookupEntry":
          return buildNextType(value.value);
        case "void":
          return void 0;
        case "array":
          return buildArray(value);
        case "struct":
          return buildStruct(value);
        case "tuple":
          return buildTuple(value);
      }
    };
    const variants = Object.entries(input.value).map(
      ([label, value]) => ({
        docs: input.innerDocs[label] ?? [],
        label,
        value: buildInnerType(value)
      })
    );
    return ltn("enum", variants);
  },
  (_, circular) => ({
    id: circular.id,
    optional: circular.type === "option",
    type: "primitive",
    value: "undefined"
  }),
  (result, tmp) => Object.assign(tmp, result)
);
const getInternalTypesBuilder = (lookup) => {
  const cache = /* @__PURE__ */ new Map();
  return (id) => buildType(lookup(id), cache, /* @__PURE__ */ new Set());
};

export { getInternalTypesBuilder, primitiveTypes };
//# sourceMappingURL=internal-types-builder.mjs.map
