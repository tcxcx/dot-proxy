{"version":3,"file":"reused-nodes.mjs","sources":["../../../src/internal-types/reused-nodes.ts"],"sourcesContent":["import { isPrimitive, LookupTypeNode, TypeNode } from \"./type-representation\"\n\n/**\n * Given a list of starting points, returns those nodes that are being shared by\n * multiple paths.\n *\n * This can be used to avoid generating intermediate types which are being used\n * from just one single point.\n *\n * `exclude` is a set of ids to stop exploring. E.g. known types.\n * It might be a good idea to also have the excluded types as part of the entry\n * points.\n *\n * It might return types in the `start` or `exclude` set if those are being\n * referenced from more than one path.\n */\nexport function getReusedNodes(\n  start: (TypeNode | LookupTypeNode)[],\n  exclude: Set<number>,\n) {\n  const reused = new Set<number>()\n  const visited = new Set<number>()\n  let heads = [...start]\n\n  while (heads.length) {\n    const head = heads.pop()!\n    if (\"id\" in head) {\n      if (visited.has(head.id)) {\n        reused.add(head.id)\n        continue\n      }\n      visited.add(head.id)\n      if (exclude.has(head.id)) {\n        continue\n      }\n    }\n\n    heads = [...heads, ...getEdges(head)]\n  }\n\n  return reused\n}\n\nconst unique = <T>(arr: T[]) => [...new Set(arr)]\n\nfunction getEdges(node: TypeNode): LookupTypeNode[] {\n  const lookupEdge = (node: TypeNode | LookupTypeNode): LookupTypeNode[] =>\n    \"id\" in node ? [node] : getEdges(node)\n\n  if (isPrimitive(node)) return []\n\n  switch (node.type) {\n    case \"array\":\n      return lookupEdge(node.value.value)\n    case \"enum\":\n      // enum entries can be undefined => []\n      // enum entries can be lookupEntries => [lookupEntry]\n      // enum entries can be inline array/structs/etc => getEdges(_)\n      return unique(\n        node.value.flatMap((v) => (v.value ? lookupEdge(v.value) : [])),\n      )\n    case \"option\":\n      return lookupEdge(node.value)\n    case \"result\":\n      return [node.value.ok, node.value.ko]\n    case \"struct\":\n    case \"tuple\":\n      return unique(node.value.flatMap((v) => lookupEdge(v.value)))\n    case \"union\":\n      return unique(node.value.flatMap(lookupEdge))\n  }\n}\n"],"names":["node"],"mappings":";;AAgBgB,SAAA,cAAA,CACd,OACA,OACA,EAAA;AACA,EAAM,MAAA,MAAA,uBAAa,GAAY,EAAA;AAC/B,EAAM,MAAA,OAAA,uBAAc,GAAY,EAAA;AAChC,EAAI,IAAA,KAAA,GAAQ,CAAC,GAAG,KAAK,CAAA;AAErB,EAAA,OAAO,MAAM,MAAQ,EAAA;AACnB,IAAM,MAAA,IAAA,GAAO,MAAM,GAAI,EAAA;AACvB,IAAA,IAAI,QAAQ,IAAM,EAAA;AAChB,MAAA,IAAI,OAAQ,CAAA,GAAA,CAAI,IAAK,CAAA,EAAE,CAAG,EAAA;AACxB,QAAO,MAAA,CAAA,GAAA,CAAI,KAAK,EAAE,CAAA;AAClB,QAAA;AAAA;AAEF,MAAQ,OAAA,CAAA,GAAA,CAAI,KAAK,EAAE,CAAA;AACnB,MAAA,IAAI,OAAQ,CAAA,GAAA,CAAI,IAAK,CAAA,EAAE,CAAG,EAAA;AACxB,QAAA;AAAA;AACF;AAGF,IAAA,KAAA,GAAQ,CAAC,GAAG,KAAA,EAAO,GAAG,QAAA,CAAS,IAAI,CAAC,CAAA;AAAA;AAGtC,EAAO,OAAA,MAAA;AACT;AAEA,MAAM,MAAA,GAAS,CAAI,GAAa,KAAA,CAAC,GAAG,IAAI,GAAA,CAAI,GAAG,CAAC,CAAA;AAEhD,SAAS,SAAS,IAAkC,EAAA;AAClD,EAAM,MAAA,UAAA,GAAa,CAACA,KAClB,KAAA,IAAA,IAAQA,QAAO,CAACA,KAAI,CAAI,GAAA,QAAA,CAASA,KAAI,CAAA;AAEvC,EAAA,IAAI,WAAY,CAAA,IAAI,CAAG,EAAA,OAAO,EAAC;AAE/B,EAAA,QAAQ,KAAK,IAAM;AAAA,IACjB,KAAK,OAAA;AACH,MAAO,OAAA,UAAA,CAAW,IAAK,CAAA,KAAA,CAAM,KAAK,CAAA;AAAA,IACpC,KAAK,MAAA;AAIH,MAAO,OAAA,MAAA;AAAA,QACL,IAAK,CAAA,KAAA,CAAM,OAAQ,CAAA,CAAC,CAAO,KAAA,CAAA,CAAE,KAAQ,GAAA,UAAA,CAAW,CAAE,CAAA,KAAK,CAAI,GAAA,EAAG;AAAA,OAChE;AAAA,IACF,KAAK,QAAA;AACH,MAAO,OAAA,UAAA,CAAW,KAAK,KAAK,CAAA;AAAA,IAC9B,KAAK,QAAA;AACH,MAAA,OAAO,CAAC,IAAK,CAAA,KAAA,CAAM,EAAI,EAAA,IAAA,CAAK,MAAM,EAAE,CAAA;AAAA,IACtC,KAAK,QAAA;AAAA,IACL,KAAK,OAAA;AACH,MAAO,OAAA,MAAA,CAAO,IAAK,CAAA,KAAA,CAAM,OAAQ,CAAA,CAAC,MAAM,UAAW,CAAA,CAAA,CAAE,KAAK,CAAC,CAAC,CAAA;AAAA,IAC9D,KAAK,OAAA;AACH,MAAA,OAAO,MAAO,CAAA,IAAA,CAAK,KAAM,CAAA,OAAA,CAAQ,UAAU,CAAC,CAAA;AAAA;AAElD;;;;"}