import { isPrimitive } from './type-representation.mjs';

function getReusedNodes(start, exclude) {
  const reused = /* @__PURE__ */ new Set();
  const visited = /* @__PURE__ */ new Set();
  let heads = [...start];
  while (heads.length) {
    const head = heads.pop();
    if ("id" in head) {
      if (visited.has(head.id)) {
        reused.add(head.id);
        continue;
      }
      visited.add(head.id);
      if (exclude.has(head.id)) {
        continue;
      }
    }
    heads = [...heads, ...getEdges(head)];
  }
  return reused;
}
const unique = (arr) => [...new Set(arr)];
function getEdges(node) {
  const lookupEdge = (node2) => "id" in node2 ? [node2] : getEdges(node2);
  if (isPrimitive(node)) return [];
  switch (node.type) {
    case "array":
      return lookupEdge(node.value.value);
    case "enum":
      return unique(
        node.value.flatMap((v) => v.value ? lookupEdge(v.value) : [])
      );
    case "option":
      return lookupEdge(node.value);
    case "result":
      return [node.value.ok, node.value.ko];
    case "struct":
    case "tuple":
      return unique(node.value.flatMap((v) => lookupEdge(v.value)));
    case "union":
      return unique(node.value.flatMap(lookupEdge));
  }
}

export { getReusedNodes };
//# sourceMappingURL=reused-nodes.mjs.map
