{"version":3,"file":"generate-descriptors.mjs","sources":["../../src/generate-descriptors.ts"],"sourcesContent":["import {\n  getChecksumBuilder,\n  MetadataLookup,\n} from \"@polkadot-api/metadata-builders\"\nimport { filterObject, mapObject } from \"@polkadot-api/utils\"\nimport { anonymizeImports, anonymizeType } from \"./anonymize\"\nimport { getTypesBuilder } from \"./types-builder\"\n\nconst isDocs = (x: any) => {\n  if (typeof x !== \"object\") return false\n  const keys = new Set(Object.keys(x))\n  if (keys.size !== 2) return false\n  return keys.has(\"docs\") && keys.has(\"value\")\n}\n\nexport const customStringifyObject = (\n  input: string | Record<string, any> | Array<any>,\n): string => {\n  if (typeof input === \"string\" || typeof input === \"number\") return input\n\n  if (Array.isArray(input))\n    return `[${input.map(customStringifyObject).join(\", \")}]`\n\n  return `{${Object.entries(\n    mapObject(input, (x) => (isDocs(x) ? x : customStringifyObject(x))),\n  )\n    .map(([key, value]) => {\n      if (isDocs(value)) {\n        return `\\n\\n/**\\n${value.docs\n          .map((doc: string) => ` *${doc}`)\n          .join(\"\\n\")}\\n */\\n${key}: ${customStringifyObject(value.value)}`\n      }\n      return `${key}: ${value}`\n    })\n    .join(\",\\n\")}}`\n}\n\n// type -> pallet -> name\nexport type DescriptorValues = Record<\n  \"storage\" | \"tx\" | \"events\" | \"constants\" | \"apis\",\n  Record<string, Record<string, number>>\n>\n\nexport function capitalize(value: string) {\n  return value.slice(0, 1).toUpperCase() + value.slice(1)\n}\n\nexport const generateDescriptors = (\n  lookupFn: MetadataLookup,\n  checksumToIdx: Map<string, number>,\n  typesBuilder: ReturnType<typeof getTypesBuilder>,\n  checksumBuilder: ReturnType<typeof getChecksumBuilder>,\n  key: string,\n  paths: {\n    client: string\n    metadataTypes: string\n    types: string\n    descriptorValues: string\n  },\n  genesis?: string,\n) => {\n  const prefix = capitalize(key)\n  const { metadata } = lookupFn\n  const buildEnumObj = <T>(\n    val: number | undefined,\n    cb: (name: string, docs: string[]) => T,\n  ): Record<string, T> => {\n    if (val === undefined) return {}\n\n    const lookup = metadata.lookup[val]\n    if (lookup.def.tag !== \"variant\") throw null\n    return Object.fromEntries(\n      lookup.def.value.map((x) => {\n        return [x.name!, cb(x.name, x.docs)]\n      }),\n    )\n  }\n\n  const storage = Object.fromEntries(\n    metadata.pallets.map((pallet) => {\n      return [\n        pallet.name,\n        Object.fromEntries(\n          pallet.storage?.items.map(({ name, modifier, docs }) => {\n            const { key, val, opaque } = typesBuilder.buildStorage(\n              pallet.name,\n              name,\n            )\n            const checksum = checksumBuilder.buildStorage(pallet.name, name)!\n            const type = `StorageDescriptor<${key}, ${val}, ${!modifier}, ${opaque}>`\n            return [\n              name,\n              {\n                typeRef: checksumToIdx.get(checksum)!,\n                type,\n                name: `stg_${pallet.name}_${name}`,\n                docs,\n              },\n            ]\n          }) ?? [],\n        ),\n      ]\n    }),\n  )\n\n  const constants = Object.fromEntries(\n    metadata.pallets.map((pallet) => {\n      return [\n        pallet.name,\n        Object.fromEntries(\n          pallet.constants?.map(({ name, docs }) => {\n            const checksum = checksumBuilder.buildConstant(pallet.name, name)!\n            const type = `PlainDescriptor<${typesBuilder.buildConstant(\n              pallet.name,\n              name,\n            )}>`\n            return [\n              name,\n              {\n                typeRef: checksumToIdx.get(checksum)!,\n                type,\n                name: `const_${pallet.name}_${name}`,\n                docs,\n              },\n            ]\n          }) ?? [],\n        ),\n      ]\n    }),\n  )\n\n  const calls = Object.fromEntries(\n    metadata.pallets.map((pallet) => {\n      return [\n        pallet.name,\n        buildEnumObj(pallet.calls, (name, docs) => ({\n          typeRef: checksumToIdx.get(\n            checksumBuilder.buildCall(pallet.name, name)!,\n          )!,\n          type: `TxDescriptor<${typesBuilder.buildCall(pallet.name, name)}>`,\n          name: `call_${pallet.name}_${name}`,\n          docs,\n        })),\n      ]\n    }),\n  )\n\n  const events = Object.fromEntries(\n    metadata.pallets.map((pallet) => {\n      return [\n        pallet.name,\n        buildEnumObj(pallet.events, (name, docs) => ({\n          typeRef: checksumToIdx.get(\n            checksumBuilder.buildEvent(pallet.name, name)!,\n          )!,\n          type: `PlainDescriptor<${typesBuilder.buildEvent(\n            pallet.name,\n            name,\n          )}>`,\n          name: `evt_${pallet.name}_${name}`,\n          docs,\n        })),\n      ]\n    }),\n  )\n\n  const errors = Object.fromEntries(\n    metadata.pallets.map((pallet) => {\n      return [\n        pallet.name,\n        buildEnumObj(pallet.errors, (name, docs) => {\n          return {\n            typeRef: checksumToIdx.get(\n              checksumBuilder.buildError(pallet.name, name)!,\n            )!,\n            type: `PlainDescriptor<${typesBuilder.buildError(\n              pallet.name,\n              name,\n            )}>`,\n            name: `err_${pallet.name}_${name}`,\n            docs,\n          }\n        }),\n      ]\n    }),\n  )\n\n  const runtimeCalls = Object.fromEntries(\n    metadata.apis.map((api) => [\n      api.name,\n      {\n        docs: api.docs,\n        methods: Object.fromEntries(\n          api.methods.map((method) => {\n            const { args, value } = typesBuilder.buildRuntimeCall(\n              api.name,\n              method.name,\n            )\n            return [\n              method.name,\n              {\n                typeRef: checksumToIdx.get(\n                  checksumBuilder.buildRuntimeCall(api.name, method.name)!,\n                )!,\n                type: `RuntimeDescriptor<${args}, ${value}>`,\n                name: `runtime_${api.name}_${method.name}`,\n                docs: method.docs,\n              },\n            ]\n          }),\n        ),\n      },\n    ]),\n  )\n\n  const mapDescriptor = <T, R>(\n    descriptor: Record<string, Record<string, T>>,\n    mapFn: (value: T, pallet: string, name: string) => R,\n  ): Record<string, Record<string, R>> =>\n    filterObject(\n      mapObject(descriptor, (v, pallet) =>\n        mapObject(v, (value, name) => mapFn(value, pallet, name)),\n      ),\n      (v) => Object.keys(v).length > 0,\n    )\n\n  const extractValue = (input: { docs: string[]; type: string }) => ({\n    docs: input.docs,\n    value: input.type,\n  })\n\n  const iStorage = mapDescriptor(storage, extractValue)\n  const iCalls = mapDescriptor(calls, extractValue)\n  const iEvents = mapDescriptor(events, extractValue)\n  const iErrors = mapDescriptor(errors, extractValue)\n  const iConstants = mapDescriptor(constants, extractValue)\n\n  const descriptorValues: DescriptorValues = {\n    storage: {},\n    tx: {},\n    events: {},\n    constants: {},\n    apis: {},\n  }\n  const mapObjStr = mapObject as <I, O>(\n    input: Record<string, I>,\n    mapper: (i: I, k: string) => O,\n  ) => Record<string, O>\n  Object.keys(storage).forEach((pallet) => {\n    descriptorValues[\"storage\"][pallet] = mapObjStr(\n      storage[pallet],\n      (x, _: string) => x.typeRef,\n    )\n    descriptorValues[\"tx\"][pallet] = mapObjStr(calls[pallet], (x) => x.typeRef)\n    descriptorValues[\"events\"][pallet] = mapObjStr(\n      events[pallet],\n      (x) => x.typeRef,\n    )\n    descriptorValues[\"constants\"][pallet] = mapObjStr(\n      constants[pallet],\n      (x) => x.typeRef,\n    )\n  })\n\n  const iRuntimeCalls = mapObject(runtimeCalls, (api) => ({\n    docs: api.docs,\n    value: mapObject(api.methods, ({ docs, type: value }) => ({ docs, value })),\n  }))\n\n  if (lookupFn.call) {\n    // Generate the types to have it included in common types\n    typesBuilder.buildDefinition(lookupFn.call)\n  }\n\n  const callInterface = lookupFn.call\n    ? `I${checksumBuilder.buildDefinition(lookupFn.call)}`\n    : null\n\n  // & { value: {Â type: string }} to remove pallets without tx (otherwise it's not assignable to TxCallData)\n  const chainCallType = callInterface\n    ? `export type ${prefix}CallData = Anonymize<${callInterface}> & { value: { type: string } };`\n    : \"\"\n\n  descriptorValues[\"apis\"] = mapObject(runtimeCalls, (api) =>\n    mapObject(api.methods, (x) => x.typeRef),\n  )\n\n  const clientImports = [\n    ...new Set([\n      \"StorageDescriptor\",\n      \"PlainDescriptor\",\n      \"TxDescriptor\",\n      \"RuntimeDescriptor\",\n      \"Enum\",\n      \"_Enum\",\n      \"GetEnum\",\n      \"QueryFromPalletsDef\",\n      \"TxFromPalletsDef\",\n      \"EventsFromPalletsDef\",\n      \"ErrorsFromPalletsDef\",\n      \"ConstFromPalletsDef\",\n      ...typesBuilder.getClientFileImports(),\n      ...anonymizeImports,\n    ]),\n  ]\n\n  const assetId = getAssetId(lookupFn)\n  const assetType =\n    assetId == null ? \"void\" : typesBuilder.buildTypeDefinition(assetId)\n\n  const dispatchErrorId = getDispatchErrorId(lookupFn)\n  const dispatchErrorType =\n    dispatchErrorId == null\n      ? \"unknown\"\n      : typesBuilder.buildTypeDefinition(dispatchErrorId)\n\n  const commonTypeImports = typesBuilder.getTypeFileImports()\n\n  const exports = [\n    `default as ${key}`,\n    callInterface ? `${prefix}CallData` : null,\n  ].filter((v) => v !== null)\n\n  // Going through base64 conversion instead of using binary loader because of esbuild issue\n  // https://github.com/evanw/esbuild/issues/3894\n  const imports = `import {${clientImports.join(\", \")}} from \"${paths.client}\";\n  import {${commonTypeImports.join(\", \")}} from \"${paths.types}\";\n\n  const toBinary = (() => {\n    const table = new Uint8Array(128);\n    for (let i = 0; i < 64; i++) table[i < 26 ? i + 65 : i < 52 ? i + 71 : i < 62 ? i - 4 : i * 4 - 205] = i;\n    return (base64: string) => {\n      const n = base64.length,\n        bytes = new Uint8Array((n - Number(base64[n - 1] === '=') - Number(base64[n - 2] === '=')) * 3 / 4 | 0);\n      for (let i2 = 0, j = 0; i2 < n;) {\n        const c0 = table[base64.charCodeAt(i2++)], c1 = table[base64.charCodeAt(i2++)];\n        const c2 = table[base64.charCodeAt(i2++)], c3 = table[base64.charCodeAt(i2++)];\n        bytes[j++] = c0 << 2 | c1 >> 4;\n        bytes[j++] = c1 << 4 | c2 >> 2;\n        bytes[j++] = c2 << 6 | c3;\n      }\n      return bytes;\n    };\n  })();\n\n  const descriptorValues = import(\"${paths.descriptorValues}\").then(module => module[\"${prefix}\"]);\n  const metadataTypes = import(\"${paths.metadataTypes}\").then(\n    module => toBinary('default' in module ? module.default : module)\n  );\n  `\n\n  const descriptorTypes = `${imports}\n\n${anonymizeType}\n\ntype IStorage = ${customStringifyObject(iStorage)};\ntype ICalls = ${customStringifyObject(iCalls)};\ntype IEvent = ${customStringifyObject(iEvents)};\ntype IError = ${customStringifyObject(iErrors)};\ntype IConstants = ${customStringifyObject(iConstants)};\ntype IRuntimeCalls = ${customStringifyObject(iRuntimeCalls)};\ntype IAsset = PlainDescriptor<${assetType}>\nexport type ${prefix}DispatchError = ${dispatchErrorType}\nconst asset: IAsset = {} as IAsset\nconst getMetadata: () => Promise<Uint8Array> = () => import(\"./${key}_metadata\").then(\n  module => toBinary('default' in module ? module.default : module)\n)\nconst genesis: string | undefined = ${genesis ? `\"${genesis}\"` : undefined}\n\ntype PalletsTypedef = {\n  __storage: IStorage,\n  __tx: ICalls,\n  __event: IEvent,\n  __error: IError,\n  __const: IConstants\n}\n\ntype IDescriptors = {\n  descriptors: {\n    pallets: PalletsTypedef,\n    apis: IRuntimeCalls\n  } & Promise<any>,\n  metadataTypes: Promise<Uint8Array>\n  asset: IAsset\n  getMetadata: () => Promise<Uint8Array>\n  genesis: string | undefined\n};\nconst _allDescriptors = { descriptors: descriptorValues, metadataTypes, asset, getMetadata, genesis } as any as IDescriptors;\nexport default _allDescriptors;\n\nexport type ${prefix}Queries = QueryFromPalletsDef<PalletsTypedef>\nexport type ${prefix}Calls = TxFromPalletsDef<PalletsTypedef>\nexport type ${prefix}Events = EventsFromPalletsDef<PalletsTypedef>\nexport type ${prefix}Errors = ErrorsFromPalletsDef<PalletsTypedef>\nexport type ${prefix}Constants = ConstFromPalletsDef<PalletsTypedef>\n${chainCallType}\n\nexport type ${prefix}WhitelistEntry =\n  | PalletKey\n  | ApiKey<IRuntimeCalls>\n  | \\`query.\\${NestedKey<PalletsTypedef['__storage']>}\\`\n  | \\`tx.\\${NestedKey<PalletsTypedef['__tx']>}\\`\n  | \\`event.\\${NestedKey<PalletsTypedef['__event']>}\\`\n  | \\`error.\\${NestedKey<PalletsTypedef['__error']>}\\`\n  | \\`const.\\${NestedKey<PalletsTypedef['__const']>}\\`\n\ntype PalletKey = \\`*.\\${keyof (IStorage & ICalls & IEvent & IError & IConstants & IRuntimeCalls)}\\`\ntype NestedKey<D extends Record<string, Record<string, any>>> =\n  | \"*\"\n  | {\n      [P in keyof D & string]:\n        | \\`\\${P}.*\\`\n        | {\n            [N in keyof D[P] & string]: \\`\\${P}.\\${N}\\`\n          }[keyof D[P] & string]\n    }[keyof D & string]\n\ntype ApiKey<D extends Record<string, Record<string, any>>> =\n  | \"api.*\"\n  | {\n      [P in keyof D & string]:\n        | \\`api.\\${P}.*\\`\n        | {\n            [N in keyof D[P] & string]: \\`api.\\${P}.\\${N}\\`\n          }[keyof D[P] & string]\n    }[keyof D & string]\n`\n\n  return { descriptorTypes, descriptorValues, exports }\n}\n\nexport function getAssetId(lookup: MetadataLookup) {\n  const assetPayment = lookup.metadata.extrinsic.signedExtensions.find(\n    (x) => x.identifier === \"ChargeAssetTxPayment\",\n  )\n\n  if (assetPayment) {\n    const assetTxPayment = lookup(assetPayment.type)\n    if (assetTxPayment.type === \"struct\") {\n      const optionalAssetId = assetTxPayment.value.asset_id\n      if (optionalAssetId.type === \"option\") return optionalAssetId.value.id\n    }\n  }\n  return\n}\n\nexport function getDispatchErrorId(lookup: MetadataLookup) {\n  const systemPalletEventId = lookup.metadata.pallets.find(\n    (p) => p.name === \"System\",\n  )?.events\n  if (systemPalletEventId == null) return\n\n  const systemPalletEvent = lookup(systemPalletEventId)\n  if (systemPalletEvent.type !== \"enum\") return\n\n  const extrinsicFailed = systemPalletEvent.value.ExtrinsicFailed\n  if (extrinsicFailed?.type !== \"struct\") return\n\n  return extrinsicFailed.value.dispatch_error.id\n}\n"],"names":["key"],"mappings":"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"}