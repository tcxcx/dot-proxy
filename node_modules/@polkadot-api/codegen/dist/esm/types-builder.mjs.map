{"version":3,"file":"types-builder.mjs","sources":["../../src/types-builder.ts"],"sourcesContent":["import {\n  ArrayVar,\n  getChecksumBuilder,\n  MetadataLookup,\n  StructVar,\n  TupleVar,\n} from \"@polkadot-api/metadata-builders\"\nimport { getInternalTypesBuilder, isPrimitive } from \"./internal-types\"\nimport {\n  CodegenOutput,\n  generateTypescript,\n  mergeImports,\n  nativeNodeCodegen,\n  onlyCode,\n  processPapiPrimitives,\n} from \"./internal-types/generate-typescript\"\nimport type { KnownTypes } from \"./known-types\"\n\nexport interface Variable {\n  name: string\n\n  checksum: string\n  type: string\n}\n\nexport interface CodeDeclarations {\n  imports: Set<string>\n  // checksum -> Variable;\n  // in Mode.Anonymize contains normalized types for every checksum,\n  // in Mode.TerminateKnown contains expanded types, with duplication\n  variables: Map<string, Variable>\n  takenNames: Set<string>\n}\n\nexport const defaultDeclarations = (): CodeDeclarations => ({\n  imports: new Set(),\n  variables: new Map(),\n  takenNames: new Set(),\n})\n\nconst NEVER_STR = \"never\"\nconst opaqueHashers = new Set<string>([\n  \"Blake2128\",\n  \"Blake2256\",\n  \"Twox128\",\n  \"Twox256\",\n])\n\nexport const getTypesBuilder = (\n  declarations: CodeDeclarations,\n  getLookupEntryDef: MetadataLookup,\n  // checksum -> desired-name\n  knownTypes: KnownTypes,\n  checksumBuilder: ReturnType<typeof getChecksumBuilder>,\n) => {\n  const { metadata, call } = getLookupEntryDef\n  const callsChecksum = call ? checksumBuilder.buildDefinition(call) : null\n\n  const typeFileImports = new Set<string>()\n  const clientFileImports = new Set<string>()\n\n  const getChecksum = (id: number | StructVar | TupleVar | ArrayVar): string =>\n    typeof id === \"number\"\n      ? checksumBuilder.buildDefinition(id)!\n      : checksumBuilder.buildComposite(id)!\n\n  const internalBuilder = getInternalTypesBuilder(getLookupEntryDef)\n  const anonymize = (varName: string) => {\n    if (!varName.startsWith(\"I\")) return varName\n    const checksum = varName.slice(1)\n    return knownTypes[checksum] ? varName : `Anonymize<${varName}>`\n  }\n  const getName = (checksum: string) => {\n    if (!knownTypes[checksum]) return `I${checksum}`\n\n    const { name: originalName } = knownTypes[checksum]\n    let name = originalName\n    let i = 1\n    while (declarations.takenNames.has(name)) name = originalName + i++\n\n    declarations.takenNames.add(name)\n    return name\n  }\n\n  const buildDefinition = (id: number) => {\n    const node = internalBuilder(id)\n\n    return generateTypescript(node, (node, next, level) => {\n      // primitives are not assigned to intermediate types\n      if (node.type === \"primitive\") return nativeNodeCodegen(node, next)\n\n      const checksum =\n        \"id\" in node\n          ? getChecksum(node.id)\n          : // for types inlined in Enums, we might have an intermediate type\n            \"original\" in node\n            ? getChecksum(node.original)\n            : null\n\n      // We can't call this directly because we might have to prepare the\n      // `declarations.variables` if it turns out it's nested;\n      const getPapiPrimitive = (level: number) => {\n        const papiPrimitive = processPapiPrimitives(\n          node,\n          next,\n          !!checksum && !!knownTypes[checksum],\n        )\n        if (!papiPrimitive) return null\n        papiPrimitive.imports.client?.forEach((name) => {\n          if (level === 0) {\n            clientFileImports.add(name)\n          } else {\n            declarations.imports.add(name)\n          }\n        })\n        return onlyCode(papiPrimitive.code)\n      }\n\n      if (!checksum || isPrimitive(node) || node.type === \"union\") {\n        // It's not a lookup type nor an inlined Enum type\n        // Return the primitive type or the regular codegen.\n        // And if it's a chainPrimitive also return that primitive without creating\n        // and intermediate type.\n        return getPapiPrimitive(level) ?? nativeNodeCodegen(node, next)\n      }\n\n      if (level > 0 && checksum === callsChecksum) {\n        declarations.imports.add(\"TxCallData\")\n        return onlyCode(\"TxCallData\")\n      }\n\n      if (declarations.variables.has(checksum)) {\n        const entry = declarations.variables.get(checksum)!\n        if (level === 0) {\n          typeFileImports.add(entry.name)\n        }\n        return onlyCode(anonymize(entry.name))\n      }\n\n      const variable: Variable = {\n        checksum,\n        type: \"\",\n        name: getName(checksum),\n      }\n      if (level === 0) {\n        typeFileImports.add(variable.name)\n      }\n      declarations.variables.set(checksum, variable)\n      // We're wrapping the variable with another, so we increase a level.\n      variable.type = (\n        getPapiPrimitive(level + 1) ?? nativeNodeCodegen(node, next)\n      ).code\n\n      return onlyCode(anonymize(variable.name))\n    })\n  }\n\n  const buildTypeDefinition = (id: number) =>\n    anonymize(buildDefinition(id).code)\n\n  const buildStorage = (pallet: string, entry: string) => {\n    const storageEntry = metadata.pallets\n      .find((x) => x.name === pallet)!\n      .storage!.items.find((s) => s.name === entry)!\n\n    if (storageEntry.type.tag === \"plain\")\n      return {\n        key: \"[]\",\n        val: `${buildTypeDefinition(storageEntry.type.value)}`,\n        opaque: NEVER_STR,\n      }\n\n    const hashers = storageEntry.type.value.hashers\n    const opaque =\n      hashers\n        .map((x, idx) => (opaqueHashers.has(x.tag) ? `\"${idx}\"` : null))\n        .filter(Boolean)\n        .join(\" | \") || NEVER_STR\n\n    const { key, value } = storageEntry.type.value\n    const val = buildTypeDefinition(value)\n\n    const returnKey =\n      storageEntry.type.value.hashers.length === 1\n        ? `[Key: ${buildTypeDefinition(key)}]`\n        : buildTypeDefinition(key)\n\n    return { key: returnKey, val, opaque }\n  }\n\n  const buildRuntimeCall = (api: string, method: string) => {\n    const entry = metadata.apis\n      .find((x) => x.name === api)\n      ?.methods.find((x) => x.name === method)\n    if (!entry) throw null\n\n    const innerTuple = entry.inputs\n      .map(({ name, type }) => `${name}: ${buildTypeDefinition(type)}`)\n      .join(\", \")\n\n    return {\n      args: `[${innerTuple}]`,\n      value: buildTypeDefinition(entry.output),\n    }\n  }\n\n  const buildVariant =\n    (type: \"errors\" | \"events\" | \"calls\") => (pallet: string, name: string) => {\n      const lookupEntry = getLookupEntryDef(\n        metadata.pallets.find((x) => x.name === pallet)![type]! as number,\n      )\n      if (lookupEntry.type !== \"enum\") throw null\n\n      // if (getChecksum(lookupEntry.id) !== \"ajkhn97prklo5\") return \"\"\n\n      // Generate the type that has all the variants - This is so the consumer can import the type, even if it's not used directly by the descriptor file\n      buildDefinition(lookupEntry.id)\n\n      const innerLookup = lookupEntry.value[name]\n\n      if (innerLookup.type === \"lookupEntry\") {\n        return buildTypeDefinition(innerLookup.value.id)\n      } else if (innerLookup.type === \"void\") {\n        return \"undefined\"\n      } else {\n        const result = declarations.variables.get(\n          getChecksum(innerLookup),\n        )!.name\n        typeFileImports.add(result)\n\n        return `Anonymize<${result}>`\n      }\n    }\n\n  const buildConstant = (pallet: string, constantName: string) => {\n    // return \"\"\n    const storageEntry = metadata.pallets\n      .find((x) => x.name === pallet)!\n      .constants!.find((s) => s.name === constantName)!\n\n    return buildTypeDefinition(storageEntry.type)\n  }\n\n  return {\n    buildTypeDefinition,\n    buildDefinition,\n    buildStorage,\n    buildEvent: buildVariant(\"events\"),\n    buildError: buildVariant(\"errors\"),\n    buildCall: buildVariant(\"calls\"),\n    buildRuntimeCall,\n    buildConstant,\n    getTypeFileImports: () => Array.from(typeFileImports),\n    getClientFileImports: () => Array.from(clientFileImports),\n  }\n}\n\nexport const getDocsTypesBuilder = (\n  getLookupEntryDef: MetadataLookup,\n  knownTypes: KnownTypes,\n  checksumBuilder: ReturnType<typeof getChecksumBuilder>,\n) => {\n  const { metadata, call } = getLookupEntryDef\n  const callsChecksum = call ? checksumBuilder.buildDefinition(call) : null\n  const clientFileImports = new Set<string>()\n  const fileTypeEntries = new Set<number>()\n\n  // checksum -> types that are imported for it\n  const importsPerType = new Map<string, CodegenOutput[\"imports\"]>()\n\n  const declarations = defaultDeclarations()\n\n  const getChecksum = (id: number | StructVar | TupleVar | ArrayVar): string =>\n    typeof id === \"number\"\n      ? checksumBuilder.buildDefinition(id)!\n      : checksumBuilder.buildComposite(id)!\n\n  const internalBuilder = getInternalTypesBuilder(getLookupEntryDef)\n\n  const buildTypeDefinition = (id: number) => {\n    fileTypeEntries.add(id)\n    const node = internalBuilder(id)\n\n    const visited = new Set<string>()\n    const result = generateTypescript(node, (node, next): CodegenOutput => {\n      const checksum =\n        \"id\" in node\n          ? getChecksum(node.id)\n          : // for types inlined in Enums, we might have an intermediate type\n            \"original\" in node\n            ? getChecksum(node.original)\n            : null\n\n      const getPapiPrimitive = () => processPapiPrimitives(node, next, true)\n\n      if (!checksum) {\n        // It's not a lookup type nor an inlined Enum type\n        // Return the primitive type or the regular codegen.\n        return getPapiPrimitive() ?? nativeNodeCodegen(node, next)\n      }\n\n      if (node.type === \"primitive\") return nativeNodeCodegen(node, next)\n      if (checksum === callsChecksum) {\n        return {\n          code: \"TxCallData\",\n          imports: {\n            client: new Set([\"TxCallData\"]),\n          },\n        }\n      }\n\n      if (checksum in knownTypes) {\n        if (declarations.variables.has(checksum)) {\n          const entry = declarations.variables.get(checksum)!\n          return {\n            code: entry.name,\n            imports: {\n              types: new Set([entry.name]),\n            },\n          }\n        }\n\n        const variable: Variable = {\n          checksum,\n          type: \"\",\n          name: knownTypes[checksum].name,\n        }\n        declarations.variables.set(checksum, variable)\n        const generated = getPapiPrimitive() ?? nativeNodeCodegen(node, next)\n        variable.type = generated.code\n        importsPerType.set(\n          checksum,\n          mergeImports([\n            generated.imports,\n            {\n              types: new Set([variable.name]),\n            },\n          ]),\n        )\n\n        return {\n          code: variable.name,\n          imports: {\n            types: new Set([variable.name]),\n          },\n        }\n      }\n\n      if (declarations.variables.has(checksum)) {\n        const entry = declarations.variables.get(checksum)!\n        return {\n          code: entry.type,\n          imports: importsPerType.get(checksum) ?? {},\n        }\n      }\n\n      if (visited.has(checksum)) {\n        return {\n          code: \"__Circular\",\n          imports: {\n            types: new Set([\"__Circular\"]),\n          },\n        }\n      }\n      visited.add(checksum)\n\n      const result = getPapiPrimitive() ?? nativeNodeCodegen(node, next)\n      declarations.variables.set(checksum, {\n        checksum,\n        type: result.code,\n        name: \"I\" + checksum,\n      })\n      importsPerType.set(checksum, result.imports)\n      return result\n    })\n    return result.code\n  }\n\n  const buildStorage = (pallet: string, entry: string) => {\n    const storageEntry = metadata.pallets\n      .find((x) => x.name === pallet)!\n      .storage!.items.find((s) => s.name === entry)!\n\n    if (storageEntry.type.tag === \"plain\")\n      return {\n        opaque: NEVER_STR,\n        args: \"[]\",\n        payload: `${buildTypeDefinition(storageEntry.type.value)}`,\n      }\n\n    const { key, value } = storageEntry.type.value\n    const payload = buildTypeDefinition(value)\n\n    const hashers = storageEntry.type.value.hashers\n    const opaque =\n      hashers\n        .map((x, idx) => (opaqueHashers.has(x.tag) ? `\"${idx}\"` : null))\n        .filter(Boolean)\n        .join(\" | \") || NEVER_STR\n\n    const returnKey =\n      hashers.length === 1\n        ? `[Key: ${buildTypeDefinition(key)}]`\n        : buildTypeDefinition(key)\n\n    return { args: returnKey, payload, opaque }\n  }\n\n  const buildRuntimeCall = (api: string, method: string) => {\n    const entry = metadata.apis\n      .find((x) => x.name === api)\n      ?.methods.find((x) => x.name === method)\n    if (!entry) throw null\n\n    const innerTuple = entry.inputs\n      .map(({ name, type }) => `${name}: ${buildTypeDefinition(type)}`)\n      .join(\", \")\n\n    return {\n      args: `[${innerTuple}]`,\n      value: buildTypeDefinition(entry.output),\n    }\n  }\n\n  const buildVariant =\n    (type: \"errors\" | \"events\" | \"calls\") => (pallet: string, name: string) => {\n      const lookupEntry = getLookupEntryDef(\n        metadata.pallets.find((x) => x.name === pallet)![type]! as number,\n      )\n      if (lookupEntry.type !== \"enum\") throw null\n\n      const innerLookup = lookupEntry.value[name]\n\n      if (innerLookup.type === \"lookupEntry\") {\n        return buildTypeDefinition(innerLookup.value.id)\n      } else if (innerLookup.type === \"void\") {\n        return \"undefined\"\n      } else {\n        // building all variants, in order to populate declarations.variables\n        buildTypeDefinition(lookupEntry.id)\n        const innerChecksum = getChecksum(innerLookup)\n        const innerVariable = declarations.variables.get(innerChecksum)\n        if (!innerVariable) {\n          throw new Error(\n            `Unable to build ${type} variant for ${pallet}::${name}: ${innerChecksum} not populated`,\n          )\n        }\n\n        return innerVariable.type\n      }\n    }\n\n  const buildConstant = (pallet: string, constantName: string) => {\n    const storageEntry = metadata.pallets\n      .find((x) => x.name === pallet)!\n      .constants!.find((s) => s.name === constantName)!\n\n    return buildTypeDefinition(storageEntry.type)\n  }\n\n  const recordTypeFileImports = (): string[] => {\n    const allImports = new Set<string>()\n    for (const id of fileTypeEntries) {\n      const thisTypeImports = importsPerType.get(getChecksum(id))\n      if (!thisTypeImports?.types) continue\n\n      for (const singleType of thisTypeImports.types.values()) {\n        allImports.add(singleType)\n      }\n    }\n    fileTypeEntries.clear()\n    return Array.from(allImports)\n  }\n\n  const getDescriptorsTypes = (): Variable[] =>\n    [...declarations.variables.entries()]\n      .filter(([checksum]) => knownTypes[checksum])\n      .map(([_, variable]) => variable)\n\n  return {\n    buildStorage,\n    buildRuntimeCall,\n    buildEvent: buildVariant(\"events\"),\n    buildError: buildVariant(\"errors\"),\n    buildCall: buildVariant(\"calls\"),\n    buildConstant,\n    declarations,\n    recordTypeFileImports,\n    getClientFileImports: () => Array.from(clientFileImports),\n    getDescriptorsTypes,\n  }\n}\n"],"names":["node","level","result"],"mappings":"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"}