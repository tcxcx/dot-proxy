{"version":3,"file":"generate-multiple-descriptors.mjs","sources":["../../src/generate-multiple-descriptors.ts"],"sourcesContent":["import {\n  getChecksumBuilder,\n  getLookupFn,\n} from \"@polkadot-api/metadata-builders\"\nimport {\n  EntryPoint,\n  mapEntryPointReferences,\n  mapReferences,\n  TypedefNode,\n} from \"@polkadot-api/metadata-compatibility\"\nimport type { HexString, V14, V15 } from \"@polkadot-api/substrate-bindings\"\nimport { mapObject } from \"@polkadot-api/utils\"\nimport {\n  capitalize,\n  DescriptorValues,\n  generateDescriptors,\n} from \"./generate-descriptors\"\nimport { generateTypes } from \"./generate-types\"\nimport { getUsedTypes } from \"./get-used-types\"\nimport { knownTypes, type KnownTypes } from \"./known-types\"\nimport { defaultDeclarations, getTypesBuilder, Variable } from \"./types-builder\"\nimport { applyWhitelist } from \"./whitelist\"\n\nexport const generateMultipleDescriptors = (\n  chains: Array<{\n    key: string\n    metadata: V14 | V15\n    knownTypes: KnownTypes\n    genesis?: HexString\n  }>,\n  paths: {\n    client: string\n    metadataTypes: string\n    types: string\n    descriptorValues: string\n  },\n  options: {\n    whitelist?: string[]\n  } = {},\n) => {\n  const chainData = chains.map((chain) => {\n    const metadata = options.whitelist\n      ? applyWhitelist(chain.metadata, options.whitelist)\n      : chain.metadata\n    const lookup = getLookupFn(metadata)\n    const builder = getChecksumBuilder(lookup)\n    const { checksums, types, entryPoints } = getUsedTypes(lookup, builder)\n    return {\n      ...chain,\n      lookup,\n      builder,\n      checksums,\n      types,\n      entryPoints,\n      knownTypes: {\n        ...knownTypes,\n        ...chain.knownTypes,\n      },\n    }\n  })\n  resolveConflicts(chainData)\n  const types = mergeTypes(chainData)\n\n  const declarations = defaultDeclarations()\n  const chainFiles = chainData.map((chain) =>\n    generateDescriptors(\n      chain.lookup,\n      types.checksumToIdx,\n      getTypesBuilder(\n        declarations,\n        chain.lookup,\n        chain.knownTypes,\n        chain.builder,\n      ),\n      chain.builder,\n      chain.key,\n      paths,\n      chain.genesis,\n    ),\n  )\n\n  const descriptorsFileContent = generateDescriptorValuesContent(\n    Object.fromEntries(\n      chainFiles.map((file, i) => [chainData[i].key, file.descriptorValues]),\n    ),\n  )\n\n  return {\n    descriptorsFileContent,\n    metadataTypes: types,\n    descriptorTypesFiles: chainFiles.map((file) => ({\n      content: file.descriptorTypes,\n      exports: file.exports,\n    })),\n    typesFileContent: generateTypes(declarations, paths),\n    publicTypes: getPublicTypes(declarations.variables),\n  }\n}\n\nfunction getPublicTypes(variables: Map<string, Variable>) {\n  return Array.from(variables.values())\n    .filter((variable) => variable.type.startsWith(\"Enum<\"))\n    .map((variable) => variable.name)\n}\n\nfunction resolveConflicts(\n  chainData: Array<{\n    key: string\n    checksums: string[]\n    knownTypes: KnownTypes\n  }>,\n) {\n  // Name => chain => checksum\n  const usedNames = new Map<string, Map<string, Set<string>>>()\n\n  chainData.forEach((chain) =>\n    chain.checksums.forEach((checksum) => {\n      const known = chain.knownTypes[checksum]\n      if (!known) return\n      const { name } = known\n      if (!usedNames.has(name)) {\n        usedNames.set(name, new Map())\n      }\n      if (!usedNames.get(name)!.has(chain.key)) {\n        usedNames.get(name)!.set(chain.key, new Set())\n      }\n      usedNames.get(name)!.get(chain.key)!.add(checksum)\n    }),\n  )\n\n  const conflictedNames = Array.from(usedNames.entries())\n    .filter(([_, chainToChecksums]) => {\n      const checksums = new Set(\n        Array.from(chainToChecksums.values()).flatMap((v) => [...v]),\n      )\n      if (checksums.size === 1) return false\n      const allAreTheSame = Array.from(chainToChecksums.values()).every(\n        (chainChecksums) => chainChecksums.size === checksums.size,\n      )\n      if (allAreTheSame) return false\n      return true\n    })\n    .map(([name]) => name)\n\n  conflictedNames.forEach((name) => {\n    const nameChecksums = Array.from(\n      new Set(\n        Array.from(usedNames.get(name)?.values() ?? []).flatMap((v) =>\n          Array.from(v),\n        ),\n      ),\n    )\n\n    const checksumMaxPriority = nameChecksums.map((checksum) => ({\n      checksum,\n      priority: chainData\n        .map((chain) => chain.knownTypes[checksum]?.priority ?? 0)\n        .reduce((a, b) => Math.max(a, b), 0),\n    }))\n    const absoluteMax = checksumMaxPriority\n      .map((v) => v.priority)\n      .reduce((a, b) => Math.max(a, b), 0)\n    const checksumsLowPriority = checksumMaxPriority.filter(\n      (v) => v.priority !== absoluteMax,\n    )\n\n    const checksumsChangingName =\n      checksumsLowPriority.length === checksumMaxPriority.length - 1\n        ? checksumsLowPriority\n        : checksumMaxPriority\n\n    chainData.forEach((chain) =>\n      checksumsChangingName.forEach(({ checksum }) => {\n        if (!chain.knownTypes[checksum]) return\n        chain.knownTypes[checksum] = {\n          name: capitalize(chain.key) + name,\n          priority: chain.knownTypes[checksum].priority,\n        }\n      }),\n    )\n  })\n}\n\nfunction mergeTypes(\n  chainData: Array<{\n    types: Map<string, TypedefNode>\n    entryPoints: Map<string, EntryPoint>\n    checksums: string[]\n  }>,\n) {\n  const typedefs: Array<[TypedefNode, string[]]> = []\n  const entryPoints: Array<[EntryPoint, string[]]> = []\n  const loookupToTypedefIdx: Map<string, number> = new Map()\n  const checksumToIdx: Map<string, number> = new Map()\n\n  chainData.forEach(({ types, entryPoints: chainEntryPoints, checksums }) => {\n    for (const entry of types.entries()) {\n      const [checksum, value] = entry\n      if (loookupToTypedefIdx.has(checksum)) continue\n      loookupToTypedefIdx.set(checksum, typedefs.length)\n      typedefs.push([value, checksums])\n    }\n    for (const entry of chainEntryPoints.entries()) {\n      const [checksum, value] = entry\n      if (checksumToIdx.has(checksum)) continue\n      checksumToIdx.set(checksum, entryPoints.length)\n      entryPoints.push([value, checksums])\n    }\n  })\n\n  // Update indices to the new one\n  const updatedTypedefs = typedefs.map(([typedef, checksums]) =>\n    mapReferences(typedef, (id) => loookupToTypedefIdx.get(checksums[id])!),\n  )\n  const updatedEntryPoints = entryPoints.map(([entryPoint, checksums]) =>\n    mapEntryPointReferences(\n      entryPoint,\n      (id) => loookupToTypedefIdx.get(checksums[id])!,\n    ),\n  )\n\n  return {\n    typedefs: updatedTypedefs,\n    entryPoints: updatedEntryPoints,\n    checksumToIdx,\n  }\n}\n\nfunction generateDescriptorValuesContent(\n  descriptorValues: Record<string, DescriptorValues>,\n) {\n  const usages: Record<string, number> = {}\n  const countUsages = (obj: Record<string, any>): void =>\n    Object.entries(obj).forEach(([key, value]) => {\n      usages[key] = usages[key] ?? 0\n      usages[key]++\n      if (typeof value === \"object\") countUsages(value)\n    })\n  countUsages(descriptorValues)\n\n  const tokens: Array<string> = []\n  const tokenToIdx: Record<string, number> = {}\n  const minifyKeys = <T extends Record<string | number, any>>(obj: T): T =>\n    Object.fromEntries(\n      Object.entries(obj).map(([key, value]) => {\n        const newValue = typeof value === \"number\" ? value : minifyKeys(value)\n        if (usages[key] <= 1) return [key, newValue]\n        if (!(key in tokenToIdx)) {\n          tokenToIdx[key] = tokens.length\n          tokens.push(key)\n        }\n        return [tokenToIdx[key], newValue]\n      }),\n    ) as T\n  const minified = mapObject(descriptorValues, minifyKeys)\n\n  const getTreeKey = (tree: Record<string, unknown>): string =>\n    Object.entries(tree)\n      .sort(([a], [b]) => a.localeCompare(b))\n      .map(\n        ([key, value]) =>\n          `[${key}:${typeof value === \"object\" ? getTreeKey(value as any) : value}]`,\n      )\n      .join(\"\")\n\n  type Transformed = Record<string, number | Record<string, number>>\n  /**\n   * Modifies in-place, changes type to Transformed.\n   */\n  const findCommonTrees = (\n    values: Array<Record<string, Record<string, unknown>>>,\n  ) => {\n    const treeUsages: Record<string, number> = {}\n    const keys = values.map((obj) =>\n      mapObject(obj, (tree) => {\n        const key = getTreeKey(tree)\n        treeUsages[key] = treeUsages[key] ?? 0\n        treeUsages[key]++\n        return key\n      }),\n    )\n\n    const commonTrees: Array<Record<string, unknown>> = []\n    const keyToCommonTree: Record<string, number> = {}\n    values.forEach((obj, i) =>\n      Object.entries(obj).forEach(([objKey, tree]) => {\n        const key = keys[i][objKey]\n        if (treeUsages[key] > 1) {\n          if (!(key in keyToCommonTree)) {\n            keyToCommonTree[key] = commonTrees.length\n            commonTrees.push(tree)\n          }\n          ;(obj as Transformed)[objKey] = keyToCommonTree[key]\n        }\n      }),\n    )\n\n    return commonTrees\n  }\n\n  const commonTrees = findCommonTrees(\n    Object.keys(Object.values(minified)[0]).flatMap((type) =>\n      Object.values(minified).map((d) => d[type as keyof DescriptorValues]),\n    ),\n  )\n\n  const data = JSON.stringify([minified, commonTrees, tokens])\n\n  return `\n    const [minified, commonTrees, tokens] = JSON.parse(\\`${data}\\`);\n\n    const replaceTokens = <T>(obj: Record<string | number, T>): Record<string, T> =>\n      Object.fromEntries(\n        Object.entries(obj).map(([key, value]) => {\n          const unwrappedValue =\n            typeof value === \"object\" ? replaceTokens(value as any) : value\n          const numericKey = Number(key)\n          if (Number.isNaN(numericKey)) {\n            return [key, unwrappedValue]\n          }\n          return [tokens[numericKey], unwrappedValue]\n        }),\n      ) as Record<string, T>\n    const tokenizedCommonTrees = commonTrees.map(replaceTokens)\n\n    const unwrap = (\n      obj: Record<string, object | number>,\n      depth: number,\n    ): Record<string, object> =>\n      depth === 0\n        ? (obj as Record<string, object>)\n        : Object.fromEntries(\n            Object.entries(obj).map(([key, value]) => [\n              key,\n              unwrap(\n                typeof value === \"object\" ? value : tokenizedCommonTrees[value],\n                depth - 1,\n              ),\n            ]),\n          )\n\n    const getChainDescriptors = (key: string) =>\n      unwrap(replaceTokens(minified[key]), 2)\n\n    ${Object.keys(descriptorValues)\n      .map(\n        (key) =>\n          `export const ${capitalize(key)} = getChainDescriptors(\"${key}\")`,\n      )\n      .join(\"\\n\")}\n  `\n}\n"],"names":["types","commonTrees"],"mappings":"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"}