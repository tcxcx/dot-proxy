{"version":3,"file":"ink-types.mjs","sources":["../../src/ink-types.ts"],"sourcesContent":["import {\n  InkMetadataLookup,\n  MessageParamSpec,\n  TypeSpec,\n} from \"@polkadot-api/ink-contracts\"\nimport {\n  EnumVariant,\n  getInternalTypesBuilder,\n  isPrimitive,\n  LookupTypeNode,\n  StructField,\n  TypeNode,\n} from \"./internal-types\"\nimport { getReusedNodes } from \"./internal-types/reused-nodes\"\nimport {\n  CodegenOutput,\n  generateTypescript,\n  mergeImports,\n  nativeNodeCodegen,\n  processPapiPrimitives,\n} from \"./internal-types/generate-typescript\"\nimport { anonymizeImports, anonymizeType } from \"./anonymize\"\n\nexport function generateInkTypes(lookup: InkMetadataLookup) {\n  const internalBuilder = getInternalTypesBuilder(lookup)\n\n  const buildCallable = (callable: {\n    args: Array<MessageParamSpec>\n    returnType: TypeSpec\n  }) => {\n    const call: TypeNode = {\n      type: \"struct\",\n      value: callable.args.map((param) => ({\n        label: param.label,\n        value: internalBuilder(param.type.type),\n        docs: [],\n      })),\n    }\n\n    return {\n      call,\n      value: internalBuilder(callable.returnType.type),\n    }\n  }\n  const constructors = lookup.metadata.spec.constructors.map((ct) => ({\n    ...ct,\n    types: buildCallable(ct),\n  }))\n  const messages = lookup.metadata.spec.messages.map((ct) => ({\n    ...ct,\n    types: buildCallable(ct),\n  }))\n\n  const event: TypeNode = {\n    type: \"enum\",\n    value: lookup.metadata.spec.events.map(\n      (evt): EnumVariant => ({\n        label: evt.label,\n        value: {\n          type: \"struct\",\n          value: evt.args.map(\n            (arg): StructField => ({\n              label: arg.label,\n              value: internalBuilder(arg.type.type),\n              docs: arg.docs,\n            }),\n          ),\n        },\n        docs: evt.docs,\n      }),\n    ),\n  }\n\n  const storageRoots = Object.entries(lookup.storage).map(([name, value]) => ({\n    name,\n    key: value.key !== null ? internalBuilder(value.key) : null,\n    value: internalBuilder(value.typeId),\n  }))\n  const storageRoot: TypeNode = {\n    type: \"struct\",\n    value: storageRoots.map(({ name, key, value }) => ({\n      docs: [],\n      label: name,\n      value: {\n        type: \"struct\",\n        value: [\n          {\n            docs: [],\n            label: \"key\",\n            value: key ?? { type: \"primitive\", value: \"undefined\" },\n          },\n          {\n            docs: [],\n            label: \"value\",\n            value,\n          },\n        ],\n      },\n    })),\n  }\n\n  const entryPoints: TypeNode[] = [\n    storageRoot,\n    ...constructors.flatMap((v) => [v.types.call, v.types.value]),\n    ...messages.flatMap((v) => [v.types.call, v.types.value]),\n  ]\n  const rootNodes = getReusedNodes(entryPoints, new Set())\n\n  const assignedNames: Record<number, string> = {}\n  let nextAnonymousId = 0\n  const getName = (id: number) => {\n    if (!assignedNames[id]) {\n      assignedNames[id] = `T${nextAnonymousId++}`\n    }\n    return assignedNames[id]\n  }\n\n  // Exclude primitive types from rootNodes\n  const filteredRootNodes = Array.from(rootNodes).filter(\n    (id) => !isPrimitive(internalBuilder(id)),\n  )\n\n  const types: Record<number, CodegenOutput & { name?: string }> = {}\n  const generateNodeType = (node: TypeNode | LookupTypeNode): CodegenOutput => {\n    const anonymize = (name: string) => `Anonymize<${name}>`\n\n    const result = generateTypescript(node, (node, next): CodegenOutput => {\n      if (!(\"id\" in node) || isPrimitive(node)) {\n        return (\n          processPapiPrimitives(node, next, true) ??\n          nativeNodeCodegen(node, next)\n        )\n      }\n      if (types[node.id]) {\n        const cached = types[node.id]\n        return cached.name\n          ? {\n              code: anonymize(cached.name),\n              imports: {\n                types: new Set([cached.name]),\n              },\n            }\n          : cached\n      }\n\n      const assignedName =\n        (assignedNames[node.id] as any as null) ??\n        (filteredRootNodes.includes(node.id) ? getName(node.id) : null)\n      if (assignedName) {\n        // Preassign the type to allow recursion\n        types[node.id] = {\n          code: \"\",\n          imports: {},\n          name: assignedName,\n        }\n      }\n\n      const result =\n        processPapiPrimitives(node, next, true) ?? nativeNodeCodegen(node, next)\n      if (assignedName) {\n        types[node.id].code = result.code\n        types[node.id].imports = result.imports\n        return {\n          code: anonymize(assignedName),\n          imports: {\n            types: new Set([assignedName]),\n          },\n        }\n      }\n      types[node.id] = result\n      return types[node.id]\n    })\n\n    if (\"id\" in node && types[node.id]?.name) {\n      const name = types[node.id].name!\n      return {\n        code: anonymize(name),\n        imports: {\n          types: new Set([name]),\n        },\n      }\n    }\n    return result\n  }\n\n  const createCallableDescriptor = (\n    callables: Array<{\n      label: string\n      docs: string[]\n      types: ReturnType<typeof buildCallable>\n    }>,\n  ) =>\n    generateNodeType({\n      type: \"struct\",\n      value: callables.map(\n        (callable): StructField => ({\n          label: callable.label,\n          value: {\n            type: \"struct\",\n            value: [\n              {\n                label: \"message\",\n                value: callable.types.call,\n                docs: [],\n              },\n              {\n                label: \"response\",\n                value: callable.types.value,\n                docs: [],\n              },\n            ],\n          },\n          docs: callable.docs,\n        }),\n      ),\n    })\n  const constructorsDescriptor = createCallableDescriptor(constructors)\n  const messagesDescriptor = createCallableDescriptor(messages)\n  const eventDescriptor = generateNodeType(event)\n  const storageTypes = generateNodeType(storageRoot)\n\n  const namedTypes = Object.entries(assignedNames)\n    .filter(([id]) => types[Number(id)])\n    .map(([id, value]) => `type ${value} = ${types[Number(id)].code};`)\n    .join(\"\\n\")\n\n  const clientImports = Array.from(\n    mergeImports([\n      storageTypes.imports,\n      messagesDescriptor.imports,\n      constructorsDescriptor.imports,\n      eventDescriptor.imports,\n      ...Object.values(types).map((v) => v.imports),\n      {\n        client: new Set(anonymizeImports),\n      },\n    ]).client,\n  )\n\n  const result = `\n    import type { ${clientImports.join(\", \")} } from 'polkadot-api';\n    import type { InkDescriptors } from 'polkadot-api/ink';\n\n    ${anonymizeType}\n\n    ${namedTypes}\n\n    type StorageDescriptor = ${storageTypes.code};\n    type MessagesDescriptor = ${messagesDescriptor.code};\n    type ConstructorsDescriptor = ${constructorsDescriptor.code};\n    type EventDescriptor = ${eventDescriptor.code};\n\n    export const descriptor: InkDescriptors<StorageDescriptor, MessagesDescriptor, ConstructorsDescriptor, EventDescriptor> = { metadata: ${JSON.stringify(lookup.metadata)} } as any;\n  `\n\n  return result\n}\n"],"names":["result","node"],"mappings":"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"}