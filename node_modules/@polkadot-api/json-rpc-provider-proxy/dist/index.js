'use strict';

const jsonRpcMsg = (msg) => JSON.stringify({
  jsonrpc: "2.0",
  ...msg
});

const unfollowMethods = new Set(
  ["v1", "unstable"].map((x) => `chainHead_${x}_unfollow`)
);
const getProxy = (toConsumer) => {
  let state = {
    type: 1 /* Connecting */,
    pending: []
  };
  const onMsgFromProvider = (msg) => {
    if (state.type === 0 /* Connected */) {
      const parsed = JSON.parse(msg);
      if ("id" in parsed) {
        if ("result" in parsed && state.onGoingRequests.get(parsed.id)?.type === 0 /* ChainHeadFollow */)
          state.activeChainHeads.add(parsed.result);
        state.onGoingRequests.delete(parsed.id);
      } else if ("params" in parsed) {
        const { subscription, result } = parsed.params;
        if (result?.event === "stop")
          state.activeChainHeads.delete(subscription);
      }
    }
    if (state.type !== 2 /* Done */) toConsumer(msg);
  };
  const send = (msg) => {
    if (state.type === 2 /* Done */) return;
    if (state.type === 1 /* Connecting */) {
      state.pending.push(msg);
      return;
    }
    const parsed = JSON.parse(msg);
    if (unfollowMethods.has(parsed.method))
      state.activeChainHeads.delete(parsed.params[0]);
    if ("id" in parsed) {
      const { method, id } = parsed;
      const ongoingMsg = method.startsWith("chainHead") ? method.endsWith("follow") ? {
        type: 0 /* ChainHeadFollow */,
        msg
      } : { type: 1 /* ChainHeadOperation */, id } : { type: 2 /* Other */, msg };
      state.onGoingRequests.set(id, ongoingMsg);
    }
    state.connection.send(msg);
  };
  return {
    send,
    disconnect: () => {
      if (state.type === 2 /* Done */) return;
      if (state.type === 0 /* Connected */) state.connection.disconnect();
      state = { type: 2 /* Done */ };
    },
    connect: (cb) => {
      if (state.type !== 1 /* Connecting */) throw new Error("Nonesense");
      const { pending } = state;
      const onGoingRequests = /* @__PURE__ */ new Map();
      const activeChainHeads = /* @__PURE__ */ new Set();
      const onHalt = () => {
        state = {
          type: 1 /* Connecting */,
          pending: []
        };
        activeChainHeads.forEach((subscription) => {
          onMsgFromProvider(
            jsonRpcMsg({
              params: {
                subscription,
                result: {
                  event: "stop",
                  internal: true
                }
              }
            })
          );
        });
        activeChainHeads.clear();
        for (const x of onGoingRequests.values()) {
          if (x.type === 1 /* ChainHeadOperation */)
            onMsgFromProvider(
              jsonRpcMsg({
                id: x.id,
                error: { code: -32603, message: "Internal error" },
                internal: true
              })
            );
          else send(x.msg);
        }
        onGoingRequests.clear();
      };
      state = {
        type: 0 /* Connected */,
        connection: cb(onMsgFromProvider, onHalt),
        onGoingRequests,
        activeChainHeads
      };
      pending.forEach(send);
    }
  };
};

const getSyncProvider = (input) => (onMessage) => {
  let proxy = getProxy(onMessage);
  const start = () => {
    input().then(
      (cb) => {
        if (!proxy) {
          try {
            cb(
              () => {
              },
              () => {
              }
            ).disconnect();
          } catch (_) {
          }
        } else
          proxy.connect(
            (onMsg, onHalt) => cb(onMsg, () => {
              onHalt();
              start();
            })
          );
      },
      () => {
        proxy && setTimeout(start, 0);
      }
    );
  };
  start();
  return {
    send: (msg) => {
      proxy?.send(msg);
    },
    disconnect: () => {
      proxy?.disconnect();
      proxy = null;
    }
  };
};

exports.getSyncProvider = getSyncProvider;
//# sourceMappingURL=index.js.map
