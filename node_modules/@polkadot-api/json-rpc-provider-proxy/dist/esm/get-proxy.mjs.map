{"version":3,"file":"get-proxy.mjs","sources":["../../src/get-proxy.ts"],"sourcesContent":["import { JsonRpcConnection } from \"@polkadot-api/json-rpc-provider\"\nimport { ReconnectableJsonRpcConnection } from \"./internal-types\"\nimport { jsonRpcMsg } from \"./json-rpc-message\"\n\nconst enum State {\n  Connected,\n  Connecting,\n  Done,\n}\n\nconst enum OngoingMsgType {\n  ChainHeadFollow,\n  ChainHeadOperation,\n  Other,\n}\ntype OngoingMsg =\n  | {\n      type: OngoingMsgType.ChainHeadFollow\n      msg: string\n    }\n  | { type: OngoingMsgType.ChainHeadOperation; id: string }\n  | { type: OngoingMsgType.Other; msg: string }\n\nconst unfollowMethods = new Set(\n  [\"v1\", \"unstable\"].map((x) => `chainHead_${x}_unfollow`),\n)\n\nexport const getProxy: ReconnectableJsonRpcConnection = (\n  toConsumer: (msg: string) => void,\n) => {\n  let state:\n    | {\n        type: State.Connected\n        connection: JsonRpcConnection\n        onGoingRequests: Map<string, OngoingMsg>\n        activeChainHeads: Set<string>\n      }\n    | { type: State.Connecting; pending: Array<string> }\n    | { type: State.Done } = {\n    type: State.Connecting,\n    pending: [],\n  }\n\n  const onMsgFromProvider = (msg: string) => {\n    if (state.type === State.Connected) {\n      const parsed = JSON.parse(msg)\n      if (\"id\" in parsed) {\n        if (\n          \"result\" in parsed &&\n          state.onGoingRequests.get(parsed.id)?.type ===\n            OngoingMsgType.ChainHeadFollow\n        )\n          state.activeChainHeads.add(parsed.result)\n        state.onGoingRequests.delete(parsed.id)\n      } else if (\"params\" in parsed) {\n        const { subscription, result } = parsed.params\n        if (result?.event === \"stop\")\n          state.activeChainHeads.delete(subscription)\n      }\n    }\n    // If the state is \"Connecting\", then these are messages\n    // sent from the `onHalt` function. So, we mus realy them\n    if (state.type !== State.Done) toConsumer(msg)\n  }\n\n  const send = (msg: string) => {\n    if (state.type === State.Done) return\n    if (state.type === State.Connecting) {\n      state.pending.push(msg)\n      return\n    }\n    const parsed = JSON.parse(msg)\n    if (unfollowMethods.has(parsed.method))\n      state.activeChainHeads.delete(parsed.params[0])\n\n    if (\"id\" in parsed) {\n      const { method, id } = parsed as { method: string; id: string }\n      const ongoingMsg: OngoingMsg = method.startsWith(\"chainHead\")\n        ? method.endsWith(\"follow\")\n          ? {\n              type: OngoingMsgType.ChainHeadFollow,\n              msg,\n            }\n          : { type: OngoingMsgType.ChainHeadOperation, id }\n        : { type: OngoingMsgType.Other, msg }\n      state.onGoingRequests.set(id, ongoingMsg)\n    }\n\n    state.connection.send(msg)\n  }\n\n  return {\n    send,\n    disconnect: () => {\n      if (state.type === State.Done) return\n      if (state.type === State.Connected) state.connection.disconnect()\n      state = { type: State.Done }\n    },\n    connect: (cb) => {\n      if (state.type !== State.Connecting) throw new Error(\"Nonesense\")\n\n      const { pending } = state\n      const onGoingRequests = new Map<string, OngoingMsg>()\n      const activeChainHeads = new Set<string>()\n      const onHalt = () => {\n        state = {\n          type: State.Connecting,\n          pending: [],\n        }\n        activeChainHeads.forEach((subscription) => {\n          // We don't send the messages directy to the consumer\n          // b/c they could have disconnected after receiving one\n          // of these messages. The `onMsgFromProvider` fn handles that\n          onMsgFromProvider(\n            jsonRpcMsg({\n              params: {\n                subscription,\n                result: {\n                  event: \"stop\",\n                  internal: true,\n                },\n              },\n            }),\n          )\n        })\n        activeChainHeads.clear()\n        for (const x of onGoingRequests.values()) {\n          if (x.type === OngoingMsgType.ChainHeadOperation)\n            onMsgFromProvider(\n              jsonRpcMsg({\n                id: x.id,\n                error: { code: -32603, message: \"Internal error\" },\n                internal: true,\n              }),\n            )\n          else send(x.msg)\n        }\n        onGoingRequests.clear()\n      }\n      state = {\n        type: State.Connected,\n        connection: cb(onMsgFromProvider, onHalt),\n        onGoingRequests,\n        activeChainHeads,\n      }\n      pending.forEach(send)\n    },\n  }\n}\n"],"names":[],"mappings":"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"}