import { JsonRpcProvider } from '@polkadot-api/json-rpc-provider';
import { BlockInfo, SystemEvent as SystemEvent$1 } from '@polkadot-api/observable-client';
import { HexString, OpaqueKeyHash, Binary, SS58String, Enum, BlockHeader } from '@polkadot-api/substrate-bindings';
export { AccountId, Binary, Codec, Enum, EnumVariant, FixedSizeBinary, GetEnum, HexString, ResultPayload, SS58AddressInfo, SS58String, _Enum, getSs58AddressInfo } from '@polkadot-api/substrate-bindings';
import { ChainSpecData } from '@polkadot-api/substrate-client';
import { Observable } from 'rxjs';
import { CompatibilityLevel } from '@polkadot-api/metadata-compatibility';
export { CompatibilityLevel } from '@polkadot-api/metadata-compatibility';
import { DescriptorValues } from '@polkadot-api/codegen';
export { DescriptorValues } from '@polkadot-api/codegen';
import { PolkadotSigner } from '@polkadot-api/polkadot-signer';
export { PolkadotSigner } from '@polkadot-api/polkadot-signer';

type PlainDescriptor<T> = {
    _type?: T;
};
type StorageDescriptor<Args extends Array<any>, T, Optional extends true | false, Opaque extends string> = {
    _type: T;
    _args: Args;
    _optional: Optional;
    _Opaque: Opaque;
};
type TxDescriptor<Args extends {} | undefined> = {
    ___: Args;
};
type RuntimeDescriptor<Args extends Array<any>, T> = [Args, T];
type DescriptorEntry<T> = Record<string, Record<string, T>>;
type PalletsTypedef<St extends DescriptorEntry<StorageDescriptor<any, any, any, any>>, Tx extends DescriptorEntry<TxDescriptor<any>>, Ev extends DescriptorEntry<PlainDescriptor<any>>, Err extends DescriptorEntry<PlainDescriptor<any>>, Ct extends DescriptorEntry<PlainDescriptor<any>>> = {
    __storage: St;
    __tx: Tx;
    __event: Ev;
    __error: Err;
    __const: Ct;
};
type ApisTypedef<T extends DescriptorEntry<RuntimeDescriptor<any, any>>> = T;

type ChainDefinition = {
    descriptors: Promise<DescriptorValues> & {
        pallets: PalletsTypedef<any, any, any, any, any>;
        apis: ApisTypedef<any>;
    };
    asset: PlainDescriptor<any>;
    metadataTypes: Promise<Uint8Array>;
    getMetadata: () => Promise<Uint8Array>;
    genesis: HexString | undefined;
};
type BuildTuple<L extends number, E, R extends Array<E>> = R["length"] extends L ? R : BuildTuple<L, E, [E, ...R]>;
type UnwrapFixedSizeArray<T extends Array<any>> = T extends [] | [any, ...any[]] ? T : T extends FixedSizeArray<infer L, infer E> ? number extends L ? T : BuildTuple<L, E, []> : T;
type RemapKeys<Key extends Array<any>, Opaque> = {
    [K in keyof Key]: K extends Opaque ? OpaqueKeyHash : Key[K];
};
type ApplyOpaque<Key extends Array<any>, Opaque> = RemapKeys<UnwrapFixedSizeArray<Key>, Opaque>;
type ExtractStorage<T extends DescriptorEntry<StorageDescriptor<any, any, any, any>>> = {
    [K in keyof T]: {
        [KK in keyof T[K]]: T[K][KK] extends StorageDescriptor<infer Key, infer Value, infer Optional, infer Opaque> ? {
            KeyArgs: Key;
            KeyArgsOut: ApplyOpaque<Key, Opaque>;
            Value: Value;
            IsOptional: Optional;
        } : unknown;
    };
};
type ExtractTx<T extends DescriptorEntry<TxDescriptor<any>>> = {
    [K in keyof T]: {
        [KK in keyof T[K]]: T[K][KK] extends TxDescriptor<infer Args> ? Args : unknown;
    };
};
type ExtractPlain<T extends DescriptorEntry<PlainDescriptor<any>>> = {
    [K in keyof T]: {
        [KK in keyof T[K]]: T[K][KK] extends PlainDescriptor<infer Value> ? Value : unknown;
    };
};
type QueryFromPalletsDef<T extends PalletsTypedef<any, any, any, any, any>> = ExtractStorage<T["__storage"]>;
type TxFromPalletsDef<T extends PalletsTypedef<any, any, any, any, any>> = ExtractTx<T["__tx"]>;
type EventsFromPalletsDef<T extends PalletsTypedef<any, any, any, any, any>> = ExtractPlain<T["__event"]>;
type ErrorsFromPalletsDef<T extends PalletsTypedef<any, any, any, any, any>> = ExtractPlain<T["__error"]>;
type ConstFromPalletsDef<T extends PalletsTypedef<any, any, any, any, any>> = ExtractPlain<T["__const"]>;

declare class RuntimeToken<D = unknown> {
    private constructor();
    protected _runtime(value: D): void;
}
declare class CompatibilityToken<D = unknown> {
    private constructor();
    protected _compatibility(value: D): void;
}
interface CompatibilityFunctions<D> {
    /**
     * Returns the `CompatibilityLevel` for this call comparing the descriptors
     * generated on dev time with the current live metadata.
     */
    getCompatibilityLevel(): Promise<CompatibilityLevel>;
    /**
     * Returns the `CompatibilityLevel` for this call comparing the descriptors
     * generated on dev time with the current live metadata.
     *
     * @param compatibilityToken  CompatibilityToken awaited from
     *                            typedApi.compatibilityToken.
     */
    getCompatibilityLevel(compatibilityToken: CompatibilityToken<D>): CompatibilityLevel;
    /**
     * Returns whether this call is compatible based on the CompatibilityLevel
     * threshold.
     *
     * @param threshold  CompatibilityLevel threshold to use, inclusive.
     */
    isCompatible(threshold: CompatibilityLevel): Promise<boolean>;
    /**
     * Returns whether this call is compatible based on the CompatibilityLevel
     * threshold.
     *
     * @param threshold           CompatibilityLevel threshold to use,
     *                            inclusive.
     * @param compatibilityToken  CompatibilityToken awaited from
     *                            typedApi.compatibilityToken.
     */
    isCompatible(threshold: CompatibilityLevel, compatibilityToken: CompatibilityToken<D>): boolean;
}

type ConstantEntry<Unsafe, D, T> = Unsafe extends true ? {
    /**
     * Constants are simple key-value structures found in the runtime
     * metadata.
     *
     * @returns Promise that will resolve in the value of the constant.
     */
    (): Promise<T>;
    /**
     * @param runtimeToken  Token from got with `await
     *                      typedApi.runtimeToken`
     * @returns Synchronously returns value of the constant.
     */
    (runtimeToken: RuntimeToken): T;
} : {
    /**
     * Constants are simple key-value structures found in the runtime
     * metadata.
     *
     * @returns Promise that will resolve in the value of the constant.
     */
    (): Promise<T>;
    /**
     * @param compatibilityToken  Token from got with `await
     *                            typedApi.compatibilityToken`
     * @returns Synchronously returns value of the constant.
     */
    (compatibilityToken: CompatibilityToken): T;
} & CompatibilityFunctions<D>;

type EventPhase = {
    type: "ApplyExtrinsic";
    value: number;
} | {
    type: "Finalization";
} | {
    type: "Initialization";
};
type EvWatch<T> = (filter?: (value: T) => boolean) => Observable<{
    meta: {
        block: BlockInfo;
        phase: EventPhase;
    };
    payload: T;
}>;
type EvPull<T> = () => Promise<Array<{
    meta: {
        block: BlockInfo;
        phase: EventPhase;
    };
    payload: T;
}>>;
type EvFilter<T> = (collection: SystemEvent["event"][]) => Array<T>;
type EvClient<Unsafe, D, T> = {
    /**
     * Multicast and stateful Observable watching for new events (matching the
     * event kind chosen) in the latest known `finalized` block.
     *
     * @param filter  Optional filter function to only emit events complying
     *                with the function.
     */
    watch: EvWatch<T>;
    /**
     * Fetch (Promise-based) all events (matching the event kind chosen) available
     * in the latest known `finalized` block.
     */
    pull: EvPull<T>;
    /**
     * Filter a bunch of `SystemEvent` and return the decoded `payload` of every
     * of them.
     *
     * @param collection  Array of `SystemEvent` to filter.
     */
    filter: EvFilter<T>;
} & (Unsafe extends true ? {} : CompatibilityFunctions<D>);
type SystemEvent = {
    phase: EventPhase;
    event: {
        type: string;
        value: {
            type: string;
            value: any;
        };
    };
    topics: Array<any>;
};

type CallOptions$1 = Partial<{
    at: string;
    signal: AbortSignal;
}>;
type WithCallOptions$1<Args extends Array<any>> = Args["length"] extends 0 ? [options?: CallOptions$1] : [...args: Args, options?: CallOptions$1];
type RuntimeCall<Unsafe, D, Args extends Array<any>, Payload> = {
    /**
     * Get `Payload` (Promise-based) for the runtime call.
     *
     * @param args  All keys needed for that runtime call.
     *              At the end, optionally set which block to target (latest
     *              known finalized is the default) and an AbortSignal.
     */
    (...args: WithCallOptions$1<Args>): Promise<Payload>;
} & (Unsafe extends true ? {} : CompatibilityFunctions<D>);

type CallOptions = Partial<{
    /**
     * `at` could be a blockHash, `best`, or `finalized` (default)
     */
    at: string;
    /**
     * `signal` allows you to abort an ongoing Promise. See [MDN
     * docs](https://developer.mozilla.org/en-US/docs/Web/API/AbortSignal) for
     * more information
     */
    signal: AbortSignal;
}>;
type WithCallOptions<Args extends Array<any>> = [
    ...args: Args,
    options?: CallOptions
];
type WithWatchOptions<Args extends Array<any>> = [
    ...args: Args,
    options?: {
        at: "best";
    }
];
type PossibleParents<A extends Array<any>> = A extends [...infer Left, any] ? Left | PossibleParents<Left> : ArrayPossibleParents<A>;
type ArrayPossibleParents<A extends Array<any>, Count extends Array<any> = [], R = []> = A extends Array<infer T> & {
    length: infer L;
} ? number extends L ? Array<T> : L extends Count["length"] ? R : ArrayPossibleParents<A, [...Count, T], R | Count> : never;
type StorageEntryWithoutKeys<Unsafe, D, Payload> = {
    /**
     * Get `Payload` (Promise-based) for the storage entry.
     *
     * @param options  Optionally set which block to target (latest known
     *                 finalized is the default) and an AbortSignal.
     */
    getValue: (options?: CallOptions) => Promise<Payload>;
    /**
     * Watch changes in `Payload` (observable-based) for the storage entry.
     *
     * @param bestOrFinalized  Optionally choose which block to query and watch
     *                         changes, `best` or `finalized` (default)
     */
    watchValue: (bestOrFinalized?: "best" | "finalized") => Observable<Payload>;
} & (Unsafe extends true ? {} : CompatibilityFunctions<D>);
type StorageEntryWithKeys<Unsafe, D, Args extends Array<any>, Payload, ArgsOut extends Array<any>> = {
    /**
     * Get `Payload` (Promise-based) for the storage entry with a specific set of
     * `Args`.
     *
     * @param args  All keys needed for that storage entry.
     *              At the end, optionally set which block to target (latest
     *              known finalized is the default) and an AbortSignal.
     */
    getValue: (...args: [...WithCallOptions<Args>]) => Promise<Payload>;
    /**
     * Watch changes in `Payload` (observable-based) for the storage entry.
     *
     * @param args  All keys needed for that storage entry.
     *              At the end, optionally choose which block to query and
     *              watch changes, `best` or `finalized` (default)
     */
    watchValue: (...args: [...Args, bestOrFinalized?: "best" | "finalized"]) => Observable<Payload>;
    /**
     * Get an Array of `Payload` (Promise-based) for the storage entry with
     * several sets of `Args`.
     *
     * @param keys     Array of sets of keys needed for the storage entry.
     * @param options  Optionally set which block to target (latest known
     *                 finalized is the default) and an AbortSignal.
     */
    getValues: (keys: Array<[...Args]>, options?: CallOptions) => Promise<Array<Payload>>;
    /**
     * Get an Array of `Payload` (Promise-based) for the storage entry with a
     * subset of `Args`.
     *
     * @param args  Subset of keys needed for the storage entry.
     *              At the end, optionally set which block to target (latest
     *              known finalized is the default) and an AbortSignal.
     * @example
     *
     *   // this is a query with 3 keys
     *   typedApi.query.Pallet.Query.getEntries({ at: "best" }) // no keys
     *   typedApi.query.Pallet.Query.getEntries(arg1, { at: "finalized" }) // 1/3 keys
     *   typedApi.query.Pallet.Query.getEntries(arg1, arg2, { at: "0x12345678" }) // 2/3 keys
     *
     */
    getEntries: (...args: WithCallOptions<PossibleParents<Args>>) => Promise<Array<{
        keyArgs: ArgsOut;
        value: NonNullable<Payload>;
    }>>;
    /**
     * Watch changes (Observable-based) for the storage entries with a subset of
     * `Args`.
     *
     * @param args  Subset of keys needed for the storage entry.
     *              At the end, optionally set whether to watch against the
     *              `best` block.
     *              By default watches changes against the finalized block.
     *              When watching changes against the "best" block, this API
     *              gratiously handles the re-orgs and provides the deltas
     *              based on the latest emission.
     *              The observed value contains the following properties:
     *              - `block`: the block in where the `deltas` took place -
     *              `deltas`: `null` indicates that nothing has changed from
     *              the latest emission.
     *              If the value is not `null` then the `deleted` and `upsrted`
     *              properties indicate the entries that have changed.
     *              - `entries`: it's an immutable data-structure with the
     *              latest entries.
     * @example
     *
     *   typedApi.query.Staking.Nominators.watchEntries()
     *   typedApi.query.Staking.Nominators.watchEntries({ at: "best" })
     *
     */
    watchEntries: (...args: WithWatchOptions<PossibleParents<Args>>) => Observable<{
        block: BlockInfo;
        deltas: null | {
            deleted: Array<{
                args: ArgsOut;
                value: NonNullable<Payload>;
            }>;
            upserted: Array<{
                args: ArgsOut;
                value: NonNullable<Payload>;
            }>;
        };
        entries: Array<{
            args: ArgsOut;
            value: NonNullable<Payload>;
        }>;
    }>;
} & (Unsafe extends true ? {} : CompatibilityFunctions<D>);
type StorageEntry<Unsafe, D, Args extends Array<any>, ArgsOut extends Array<any>, Payload> = Args extends [] ? StorageEntryWithoutKeys<Unsafe, D, Payload> : StorageEntryWithKeys<Unsafe, D, Args, Payload, ArgsOut>;

type TxEvent = TxSigned | TxBroadcasted | TxBestBlocksState | TxFinalized;
type TxBroadcastEvent = TxSigned | TxBroadcasted | TxBestBlocksState | TxFinalized;
type TxSigned = {
    type: "signed";
    txHash: HexString;
};
type TxBroadcasted = {
    type: "broadcasted";
    txHash: HexString;
};
type TxBestBlocksState = {
    type: "txBestBlocksState";
    txHash: HexString;
} & (TxInBestBlocksNotFound | TxInBestBlocksFound);
type TxInBestBlocksNotFound = {
    found: false;
    isValid: boolean;
};
type TxInBestBlocksFound = {
    found: true;
} & TxEventsPayload;
type EventWithTopics = SystemEvent$1["event"] & {
    topics: SystemEvent$1["topics"];
};
type TxEventsPayload = {
    /**
     * Verify if extrinsic was successful, i.e. check if `System.ExtrinsicSuccess`
     * is found.
     */
    ok: boolean;
    /**
     * Array of all events emitted by the tx. Ordered as they are emitted
     * on-chain.
     */
    events: Array<EventWithTopics>;
    /**
     * Block information where the tx is found. `hash` of the block, `number` of
     * the block, `index` of the tx in the block.
     */
    block: {
        hash: string;
        number: number;
        index: number;
    };
} & ({
    ok: true;
    /**
     * Dispatch Error found at `System.ExtrinsicFailed` event.
     */
    dispatchError?: undefined;
} | {
    ok: false;
    /**
     * Dispatch Error found at `System.ExtrinsicFailed` event.
     */
    dispatchError: {
        type: string;
        value: unknown;
    };
});
type TxFinalized = {
    type: "finalized";
    txHash: HexString;
} & TxEventsPayload;
type TxFinalizedPayload = {
    txHash: HexString;
} & TxEventsPayload;
type CustomSignedExtensionValues = {
    value: any;
    additionalSigned: any;
} | {
    value: any;
} | {
    additionalSigned: any;
};
type TxOptions<Asset> = Partial<void extends Asset ? {
    /**
     * Block to target the transaction against. Default: `"finalized"`
     */
    at: HexString | "best" | "finalized";
    /**
     * Tip in fundamental units. Default: `0`
     */
    tip: bigint;
    /**
     * Mortality of the transaction. Default: `{ mortal: true, period: 64 }`
     */
    mortality: {
        mortal: false;
    } | {
        mortal: true;
        period: number;
    };
    /**
     * Custom nonce for the transaction. Default: retrieve from latest known
     * finalized block.
     */
    nonce: number;
    /**
     * Custom values for chains that have custom signed-extensions.
     * The key of the Object should be the signed-extension name and the
     * value is an Object that accepts 2 possible keys: one for `value`
     * and the other one for `additionallySigned`. They both receive either
     * the encoded value as a `Uint8Array` that should be used for the
     * signed-extension, or the decoded value that PAPI will encode using
     * its dynamic codecs. At least one of the 2 values must be included
     * into the signed-extension Object.
     */
    customSignedExtensions: Record<string, CustomSignedExtensionValues>;
} : {
    /**
     * Block to target the transaction against. Default: `"finalized"`
     */
    at: HexString | "best" | "finalized";
    /**
     * Tip in fundamental units. Default: `0`
     */
    tip: bigint;
    /**
     * Mortality of the transaction. Default: `{ mortal: true, period: 64 }`
     */
    mortality: {
        mortal: false;
    } | {
        mortal: true;
        period: number;
    };
    /**
     * Custom nonce for the transaction. Default: retrieve from latest known
     * finalized block.
     */
    nonce: number;
    /**
     * Custom values for chains that have custom signed-extensions.
     * The key of the Object should be the signed-extension name and the
     * value is an Object that accepts 2 possible keys: one for `value`
     * and the other one for `additionallySigned`. They both receive either
     * the encoded value as a `Uint8Array` that should be used for the
     * signed-extension, or the decoded value that PAPI will encode using
     * its dynamic codecs. At least one of the 2 values must be included
     * into the signed-extension Object.
     */
    customSignedExtensions: Record<string, CustomSignedExtensionValues>;
    /**
     * Asset information to pay fees, tip, etc. By default it'll use the
     * native token of the chain.
     */
    asset?: Asset;
}>;
type OfflineTxExtensions<Asset> = void extends Asset ? {
    /**
     * Nonce for the signer of the transaction.
     */
    nonce: number;
    /**
     * Mortality of the transaction.
     */
    mortality: {
        mortal: false;
    } | {
        mortal: true;
        period: number;
        startAtBlock: {
            height: number;
            hash: HexString;
        };
    };
    /**
     * Tip in fundamental units. Default: `0n`
     */
    tip?: bigint;
    /**
     * Custom values for chains that have custom signed-extensions.
     * The key of the Object should be the signed-extension name and the value
     * is an Object that accepts 2 possible keys: one for `value`
     * and the other one for `additionallySigned`. They both receive either
     * the encoded value as a `Uint8Array` that should be used for the
     * signed-extension, or the decoded value that PAPI will encode using its
     * dynamic codecs. At least one of the 2 values must be included into the
     * signed-extension Object.
     */
    customSignedExtensions?: Record<string, CustomSignedExtensionValues>;
} : {
    /**
     * Nonce for the signer of the transaction.
     */
    nonce: number;
    /**
     * Mortality of the transaction.
     */
    mortality: {
        mortal: false;
    } | {
        mortal: true;
        period: number;
        startAtBlock: {
            height: number;
            hash: HexString;
        };
    };
    /**
     * Tip in fundamental units. Default: `0n`
     */
    tip?: bigint;
    /**
     * Custom values for chains that have custom signed-extensions.
     * The key of the Object should be the signed-extension name and the value
     * is an Object that accepts 2 possible keys: one for `value`
     * and the other one for `additionallySigned`. They both receive either
     * the encoded value as a `Uint8Array` that should be used for the
     * signed-extension, or the decoded value that PAPI will encode using its
     * dynamic codecs. At least one of the 2 values must be included into the
     * signed-extension Object.
     */
    customSignedExtensions?: Record<string, CustomSignedExtensionValues>;
    /**
     * Asset information to pay fees, tip, etc. By default it'll use the
     * native token of the chain.
     */
    asset?: Asset;
};
type TxPromise<Asset> = (from: PolkadotSigner, txOptions?: TxOptions<Asset>) => Promise<TxFinalizedPayload>;
type TxObservable<Asset> = (from: PolkadotSigner, txOptions?: TxOptions<Asset>) => Observable<TxEvent>;
interface TxCall {
    /**
     * SCALE-encoded callData of the transaction.
     *
     * @returns Promise resolving in the encoded data.
     */
    (): Promise<Binary>;
    /**
     * SCALE-encoded callData of the transaction.
     *
     * @param compatibilityToken  Token from got with `await
     *                            typedApi.compatibilityToken`
     * @returns Synchronously returns encoded data.
     */
    (compatibilityToken: CompatibilityToken): Binary;
}
interface UnsafeTxCall {
    /**
     * SCALE-encoded callData of the transaction.
     *
     * @returns Promise resolving in the encoded data.
     */
    (): Promise<Binary>;
    /**
     * SCALE-encoded callData of the transaction.
     *
     * @param runtimeToken  Token from got with `await typedApi.runtimeToken`
     * @returns Synchronously returns encoded data.
     */
    (runtimeToken: RuntimeToken): Binary;
}
type TxSignFn<Asset> = (from: PolkadotSigner, txOptions?: TxOptions<Asset>) => Promise<HexString>;
type PaymentInfo = {
    weight: {
        ref_time: bigint;
        proof_size: bigint;
    };
    class: Enum<{
        Normal: undefined;
        Operational: undefined;
        Mandatory: undefined;
    }>;
    partial_fee: bigint;
};
type InnerTransaction<Unsafe, Arg extends {} | undefined, Pallet extends string, Name extends string, Asset> = {
    /**
     * Pack the transaction, sends it to the signer, and return the signature
     * asynchronously. If the signer fails (or the user cancels the signature)
     * it'll throw an error.
     *
     * @param from       `PolkadotSigner`-compliant signer.
     * @param txOptions  Optionally pass any number of txOptions.
     * @returns Encoded `SignedExtrinsic` ready for broadcasting.
     */
    sign: TxSignFn<Asset>;
    /**
     * Observable-based all-in-one transaction submitting. It will sign,
     * broadcast, and track the transaction. The observable is singlecast, i.e.
     * it will sign, broadcast, etc at every subscription. It will complete once
     * the transaction is found in a `finalizedBlock`.
     *
     * @param from       `PolkadotSigner`-compliant signer.
     * @param txOptions  Optionally pass any number of txOptions.
     * @returns Observable to the transaction.
     */
    signSubmitAndWatch: TxObservable<Asset>;
    /**
     * Pack the transaction, sends it to the signer, broadcast, and track the
     * transaction. The promise will resolve as soon as the transaction in found
     * in a `finalizedBlock`. If the signer fails (or the user cancels the
     * signature), or the transaction becomes invalid it'll throw an error.
     *
     * @param from       `PolkadotSigner`-compliant signer.
     * @param txOptions  Optionally pass any number of txOptions.
     * @returns Finalized transaction information.
     */
    signAndSubmit: TxPromise<Asset>;
    /**
     * SCALE-encoded callData of the transaction.
     */
    getEncodedData: Unsafe extends true ? UnsafeTxCall : TxCall;
    /**
     * Estimate fees against the latest known `finalizedBlock`
     *
     * @param from       Public key or address from the potencial sender.
     * @param txOptions  Optionally pass any number of txOptions.
     * @returns Fees in fundamental units.
     */
    getEstimatedFees: (from: Uint8Array | SS58String, txOptions?: TxOptions<Asset>) => Promise<bigint>;
    /**
     * Payment info against the latest known `finalizedBlock`
     *
     * @param from       Public key or address from the potencial sender.
     * @param txOptions  Optionally pass any number of txOptions.
     * @returns PaymentInfo for the given transaction (weight, estimated fees
     *          and class).
     */
    getPaymentInfo: (from: Uint8Array | SS58String, txOptions?: TxOptions<Asset>) => Promise<PaymentInfo>;
    /**
     * PAPI way of expressing an extrinsic with arguments.
     * It's useful to pass as a parameter to extrinsics that accept calls.
     */
    decodedCall: Enum<{
        [P in Pallet]: Enum<{
            [N in Name]: Arg;
        }>;
    }>;
};
type Transaction<Arg extends {} | undefined, Pallet extends string, Name extends string, Asset> = InnerTransaction<false, Arg, Pallet, Name, Asset>;
type UnsafeTransaction<Arg extends {} | undefined, Pallet extends string, Name extends string, Asset> = InnerTransaction<true, Arg, Pallet, Name, Asset>;
type InnerTxEntry<Unsafe, D, Arg extends {} | undefined, Pallet extends string, Name extends string, Asset> = Unsafe extends true ? {
    /**
     * Synchronously create the transaction object ready to sign, submit,
     * estimate fees, etc.
     *
     * @param args  All parameters required by the transaction.
     * @returns Transaction object.
     */
    (...args: Arg extends undefined ? [] : [data: Arg]): UnsafeTransaction<Arg, Pallet, Name, Asset>;
} : {
    /**
     * Synchronously create the transaction object ready to sign, submit,
     * estimate fees, etc.
     *
     * @param args  All parameters required by the transaction.
     * @returns Transaction object.
     */
    (...args: Arg extends undefined ? [] : [data: Arg]): Transaction<Arg, Pallet, Name, Asset>;
} & CompatibilityFunctions<D>;
type OfflineTxEntry<Arg extends {} | undefined, Pallet extends string, Name extends string, Asset> = (input: Arg) => {
    /**
     * Pack the transaction, sends it to the signer, and return the signature
     * asynchronously. If the signer fails (or the user cancels the signature)
     * it'll throw an error.
     *
     * @param from        `PolkadotSigner`-compliant signer.
     * @param extensions  Information needed for the transaction extensions
     *                    that will be signed.
     * @returns Encoded `SignedExtrinsic` ready for broadcasting.
     */
    sign: (from: PolkadotSigner, extensions: OfflineTxExtensions<Asset>) => Promise<HexString>;
    encodedData: Binary;
    decodedCall: Enum<{
        [P in Pallet]: Enum<{
            [N in Name]: Arg;
        }>;
    }>;
};
type TxEntry<D, Arg extends {} | undefined, Pallet extends string, Name extends string, Asset> = InnerTxEntry<false, D, Arg, Pallet, Name, Asset>;
type UnsafeTxEntry<D, Arg extends {} | undefined, Pallet extends string, Name extends string, Asset> = InnerTxEntry<true, D, Arg, Pallet, Name, Asset>;
type TxFromBinary<Unsafe, Asset> = Unsafe extends true ? {
    /**
     * Asynchronously create the transaction object from a binary call data
     * ready to sign, submit, estimate fees, etc.
     *
     * @param callData  SCALE-encoded call data.
     * @returns Transaction object.
     */
    (callData: Binary): Promise<UnsafeTransaction<any, string, string, Asset>>;
    /**
     * Synchronously create the transaction object from a binary call data
     * ready to sign, submit, estimate fees, etc.
     *
     * @param callData      SCALE-encoded call data.
     * @param runtimeToken  Token from got with `await
     *                      typedApi.runtimeToken`
     * @returns Transaction object.
     */
    (callData: Binary, runtimeToken: RuntimeToken): UnsafeTransaction<any, string, string, Asset>;
} : {
    /**
     * Asynchronously create the transaction object from a binary call data
     * ready to sign, submit, estimate fees, etc.
     *
     * @param callData  SCALE-encoded call data.
     * @returns Transaction object.
     */
    (callData: Binary): Promise<Transaction<any, string, string, Asset>>;
    /**
     * Synchronously create the transaction object from a binary call data
     * ready to sign, submit, estimate fees, etc.
     *
     * @param callData            SCALE-encoded call data.
     * @param compatibilityToken  Token from got with `await
     *                            typedApi.compatibilityToken`
     * @returns Transaction object.
     */
    (callData: Binary, compatibilityToken: CompatibilityToken): Transaction<any, string, string, Asset>;
};

declare class InvalidTxError extends Error {
    error: any;
    constructor(e: any);
}

type StorageApi<Unsafe, D, A extends Record<string, Record<string, {
    KeyArgs: Array<any>;
    KeyArgsOut: Array<any>;
    Value: any;
    IsOptional: false | true;
} | unknown>>> = {
    [K in keyof A]: {
        [KK in keyof A[K]]: A[K][KK] extends {
            KeyArgs: Array<any>;
            KeyArgsOut: Array<any>;
            Value: any;
            IsOptional: false | true;
        } ? StorageEntry<Unsafe, D, A[K][KK]["KeyArgs"], A[K][KK]["KeyArgsOut"], A[K][KK]["IsOptional"] extends true ? A[K][KK]["Value"] | undefined : A[K][KK]["Value"]> : unknown;
    };
};
type RuntimeCallsApi<Unsafe, D, A extends Record<string, Record<string, RuntimeDescriptor<Array<any>, any>>>> = {
    [K in keyof A]: {
        [KK in keyof A[K]]: A[K][KK] extends RuntimeDescriptor<infer Args, infer Value> ? RuntimeCall<Unsafe, D, Args, Value> : unknown;
    };
};
type TxApi<Unsafe, D, A extends Record<string, Record<string, any>>, Asset> = {
    [K in keyof A]: {
        [KK in keyof A[K]]: A[K][KK] extends {} | undefined ? InnerTxEntry<Unsafe, D, A[K][KK], K & string, KK & string, Asset> : unknown;
    };
};
type OfflineTxApi<A extends Record<string, Record<string, any>>, Asset> = {
    [K in keyof A]: {
        [KK in keyof A[K]]: A[K][KK] extends {} | undefined ? OfflineTxEntry<A[K][KK], K & string, KK & string, Asset> : unknown;
    };
};
type EvApi<Unsafe, D, A extends Record<string, Record<string, any>>> = {
    [K in keyof A]: {
        [KK in keyof A[K]]: EvClient<Unsafe, D, A[K][KK]>;
    };
};
type ConstApi<Unsafe, D, A extends Record<string, Record<string, any>>> = {
    [K in keyof A]: {
        [KK in keyof A[K]]: ConstantEntry<Unsafe, D, A[K][KK]>;
    };
};
type OfflineConstApi<A extends Record<string, Record<string, any>>> = {
    [K in keyof A]: {
        [KK in keyof A[K]]: A[K][KK];
    };
};
type UnsafeEntry<T> = Record<string, Record<string, T>>;
type AnyApi<Unsafe extends true | false, D> = D extends ChainDefinition ? {
    query: StorageApi<Unsafe, D, QueryFromPalletsDef<D["descriptors"]["pallets"]>>;
    tx: TxApi<Unsafe, D, TxFromPalletsDef<D["descriptors"]["pallets"]>, D["asset"]["_type"]>;
    txFromCallData: TxFromBinary<Unsafe, D["asset"]["_type"]>;
    event: EvApi<Unsafe, D, EventsFromPalletsDef<D["descriptors"]["pallets"]>>;
    apis: RuntimeCallsApi<Unsafe, D, D["descriptors"]["apis"]>;
    constants: ConstApi<Unsafe, D, ConstFromPalletsDef<D["descriptors"]["pallets"]>>;
} : {
    query: UnsafeEntry<StorageEntryWithKeys<true, D, any, any, any>>;
    tx: UnsafeEntry<UnsafeTxEntry<D, any, string, string, any>>;
    txFromCallData: TxFromBinary<Unsafe, any>;
    event: UnsafeEntry<EvClient<true, D, any>>;
    apis: UnsafeEntry<RuntimeCall<true, D, any, any>>;
    constants: UnsafeEntry<ConstantEntry<true, D, any>>;
};
type TypedApi<D extends ChainDefinition> = AnyApi<false, D> & {
    compatibilityToken: Promise<CompatibilityToken<D>>;
};
type OfflineApi<D extends ChainDefinition> = {
    constants: OfflineConstApi<ConstFromPalletsDef<D["descriptors"]["pallets"]>>;
    tx: OfflineTxApi<TxFromPalletsDef<D["descriptors"]["pallets"]>, D["asset"]["_type"]>;
};
type UnsafeApi<D> = AnyApi<true, D> & {
    runtimeToken: Promise<RuntimeToken<D>>;
};
type TransactionValidityError<D extends ChainDefinition> = (D["descriptors"]["apis"]["TaggedTransactionQueue"]["validate_transaction"][1] & {
    success: false;
})["value"];
interface PolkadotClient {
    /**
     * Retrieve the ChainSpecData as it comes from the [JSON-RPC
     * spec](https://paritytech.github.io/json-rpc-interface-spec/api/chainSpec.html)
     */
    getChainSpecData: () => Promise<ChainSpecData>;
    /**
     * Observable that emits `BlockInfo` from the latest known finalized block.
     * It's a multicast and stateful observable, that will synchronously replay
     * its latest known state.
     */
    finalizedBlock$: Observable<BlockInfo>;
    /**
     * @returns Latest known finalized block.
     */
    getFinalizedBlock: () => Promise<BlockInfo>;
    /**
     * Observable that emits an Array of `BlockInfo`, being the first element the
     * latest known best block, and the last element the latest known finalized
     * block. It's a multicast and stateful observable, that will synchronously
     * replay its latest known state. This array is an immutable data structure;
     * i.e. a new array is emitted at every event but the reference to its
     * children are stable if the children didn't change.
     *
     * Note that subscribing to this observable already supersedes the need of
     * subscribing to `finalizedBlock$`, since the last element of the array will
     * be the latest known finalized block.
     */
    bestBlocks$: Observable<BlockInfo[]>;
    /**
     * @returns Array of `BlockInfo`, being the first element the latest
     *          known best block, and the last element the latest known
     *          finalized block.
     */
    getBestBlocks: () => Promise<BlockInfo[]>;
    /**
     * Observable to watch Block Body.
     *
     * @param hash  It can be a block hash, `"finalized"`, or `"best"`
     * @returns Observable to watch a block body. There'll be just one event
     *          with the payload and the observable will complete.
     */
    watchBlockBody: (hash: string) => Observable<HexString[]>;
    /**
     * Get Block Body (Promise-based)
     *
     * @param hash  It can be a block hash, `"finalized"`, or `"best"`
     * @returns Block body.
     */
    getBlockBody: (hash: string) => Promise<HexString[]>;
    /**
     * Get Block Header (Promise-based)
     *
     * @param hash  It can be a block hash, `"finalized"` (default), or
     *              `"best"`
     * @returns Block hash.
     */
    getBlockHeader: (hash?: string) => Promise<BlockHeader>;
    /**
     * Broadcast a transaction (Promise-based)
     *
     * @param transaction  SCALE-encoded tx to broadcast.
     * @param at           It can be a block hash, `"finalized"`, or `"best"`.
     *                     That block will be used to verify the validity of
     *                     the tx, retrieve the next nonce,
     *                     and create the mortality taking that block into
     *                     account.
     */
    submit: (transaction: HexString, at?: HexString) => Promise<TxFinalizedPayload>;
    /**
     * Broadcast a transaction and returns an Observable. The observable will
     * complete as soon as the transaction is in a finalized block.
     *
     * @param transaction  SCALE-encoded tx to broadcast.
     * @param at           It can be a block hash, `"finalized"`, or `"best"`.
     *                     That block will be used to verify the validity of
     *                     the tx, retrieve the next nonce,
     *                     and create the mortality taking that block into
     *                     account.
     */
    submitAndWatch: (transaction: HexString, at?: HexString) => Observable<TxBroadcastEvent>;
    /**
     * Returns an instance of a `TypedApi`
     *
     * @param descriptors  Pass descriptors from `@polkadot-api/descriptors`
     *                     generated by `papi` CLI.
     */
    getTypedApi: <D extends ChainDefinition>(descriptors: D) => TypedApi<D>;
    /**
     * Returns an instance of a `UnsafeApi`.
     *
     * Note that this method is only meant for advanced users that really know
     * what are they doing. This API does not provide any runtime compatibility
     * checks protection and the consumer should implement them on their own.
     */
    getUnsafeApi: <D>() => UnsafeApi<D>;
    /**
     * This will `unfollow` the provider, disconnect and error every subscription.
     * After calling it nothing can be done with the client.
     */
    destroy: () => void;
    /**
     * This API is meant as an "escape hatch" to allow access to debug endpoints
     * such as `system_version`, and other useful endpoints that are not spec
     * compliant.
     *
     * @example
     *
     *   const systemVersion = await client._request<string>("system_version", [])
     *   const myFancyThhing = await client._request<
     *     { value: string },
     *     [id: number]
     *   >("very_fancy", [1714])
     *
     */
    _request: <Reply = any, Params extends Array<any> = any[]>(method: string, params: Params) => Promise<Reply>;
}
type FixedSizeArray<L extends number, T> = Array<T> & {
    length: L;
};
type TxCallData = {
    type: string;
    value: {
        type: string;
        value: any;
    };
};

/**
 * This is the top-level export for `polkadot-api`.
 *
 * @param provider  A `JsonRpcProvider` compliant with the [JSON-RPC
 *                  spec](https://paritytech.github.io/json-rpc-interface-spec/),
 *                  which must support the `chainHead`, `transaction` and
 *                  `chainSpec` groups.
 * @example
 *
 *   import { createClient } from "polkadot-api"
 *   import { getSmProvider } from "polkadot-api/sm-provider"
 *   import { chainSpec } from "polkadot-api/chains/polkadot"
 *   import { start } from "polkadot-api/smoldot"
 *
 *   const smoldot = start()
 *   const chain = await smoldot.addChain({ chainSpec })
 *
 *   // Connect to the polkadot relay chain.
 *   const client = createClient(getSmProvider(chain))
 *
 */
declare function createClient(provider: JsonRpcProvider): PolkadotClient;

/**
 * Returns an async instance of a `OfflineApi`
 *
 * @param descriptors  Pass descriptors from `@polkadot-api/descriptors`
 *                     generated by `papi` CLI.
 */
declare const getOfflineApi: <D extends ChainDefinition>({ genesis: genesisHex, getMetadata, }: D) => Promise<OfflineApi<D>>;

export { type ApisTypedef, type ChainDefinition, CompatibilityToken, type ConstFromPalletsDef, type DescriptorEntry, type ErrorsFromPalletsDef, type EventPhase, type EventsFromPalletsDef, type FixedSizeArray, InvalidTxError, type PalletsTypedef, type PlainDescriptor, type PolkadotClient, type QueryFromPalletsDef, type RuntimeDescriptor, RuntimeToken, type StorageDescriptor, type Transaction, type TransactionValidityError, type TxBestBlocksState, type TxBroadcastEvent, type TxBroadcasted, type TxCall, type TxCallData, type TxDescriptor, type TxEntry, type TxEvent, type TxEventsPayload, type TxFinalized, type TxFinalizedPayload, type TxFromPalletsDef, type TxInBestBlocksFound, type TxInBestBlocksNotFound, type TxObservable, type TxOptions, type TxPromise, type TxSignFn, type TxSigned, type TypedApi, type UnsafeApi, type UnsafeTransaction, type UnsafeTxCall, type UnsafeTxEntry, createClient, getOfflineApi };
