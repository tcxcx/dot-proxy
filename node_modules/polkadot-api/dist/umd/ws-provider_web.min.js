(function(v,C){typeof exports=="object"&&typeof module<"u"?C(exports):typeof define=="function"&&define.amd?define(["exports"],C):(v=typeof globalThis<"u"?globalThis:v||self,C(v.papiWsProviderWeb={}))})(this,function(v){"use strict";const C=o=>JSON.stringify({jsonrpc:"2.0",...o}),I=new Set(["v1","unstable"].map(o=>`chainHead_${o}_unfollow`)),G=o=>{let e={type:1,pending:[]};const r=n=>{if(e.type===0){const t=JSON.parse(n);if("id"in t)"result"in t&&e.onGoingRequests.get(t.id)?.type===0&&e.activeChainHeads.add(t.result),e.onGoingRequests.delete(t.id);else if("params"in t){const{subscription:u,result:i}=t.params;i?.event==="stop"&&e.activeChainHeads.delete(u)}}e.type!==2&&o(n)},s=n=>{if(e.type===2)return;if(e.type===1){e.pending.push(n);return}const t=JSON.parse(n);if(I.has(t.method)&&e.activeChainHeads.delete(t.params[0]),"id"in t){const{method:u,id:i}=t,m=u.startsWith("chainHead")?u.endsWith("follow")?{type:0,msg:n}:{type:1,id:i}:{type:2,msg:n};e.onGoingRequests.set(i,m)}e.connection.send(n)};return{send:s,disconnect:()=>{e.type!==2&&(e.type===0&&e.connection.disconnect(),e={type:2})},connect:n=>{if(e.type!==1)throw new Error("Nonesense");const{pending:t}=e,u=new Map,i=new Set;e={type:0,connection:n(r,()=>{e={type:1,pending:[]},i.forEach(f=>{r(C({params:{subscription:f,result:{event:"stop",internal:!0}}}))}),i.clear();for(const f of u.values())f.type===1?r(C({id:f.id,error:{code:-32603,message:"Internal error"},internal:!0})):s(f.msg);u.clear()}),onGoingRequests:u,activeChainHeads:i},t.forEach(s)}}},$=o=>e=>{let r=G(e);const s=()=>{o().then(n=>{if(r)r.connect((t,u)=>n(t,()=>{u(),s()}));else try{n(()=>{},()=>{}).disconnect()}catch{}},()=>{r&&setTimeout(s,0)})};return s(),{send:n=>{r?.send(n)},disconnect:()=>{r?.disconnect(),r=null}}};var h=(o=>(o[o.CONNECTING=0]="CONNECTING",o[o.CONNECTED=1]="CONNECTED",o[o.ERROR=2]="ERROR",o[o.CLOSE=3]="CLOSE",o))(h||{});const H={};["v1","unstable"].forEach(o=>{H[`chainHead_${o}_follow`]="follow",H[`chainHead_${o}_unfollow`]="unfollow"});const M=(o,e)=>{const r=new Set,s=new Map,n=new Set;let t;return Object.assign(i=>{const{send:m,disconnect:f}=o(y=>{const d=JSON.parse(y);if("id"in d){const{id:p,result:l}=d;if(p===t&&(t=void 0,l&&!l.methods.some(c=>{const[R,,S]=c.split("_");return R==="chainHead"&&S==="follow"}))){i(y),e();return}const E=s.get(p);if(E){if(s.delete(p),r.has(l)){r.delete(l);return}n.add(l);const c=n.size+s.size;if(c>2)console.warn(`Too many chainHead follow subscriptions (${c})`);else if(d.error){console.warn(`chainHead follow failed on the ${c} sub`),e(),s.set(p,E),m(E);return}}}else{const{subscription:p,result:l}=d.params;l?.event==="stop"&&(n.has(p)?n.delete(p):r.add(p))}i(y)});return{send(y){const d=JSON.parse(y);d.method==="rpc_methods"&&(t=d.id);const p=H[d.method];p==="follow"?s.set(d.id,y):p==="unfollow"&&n.delete(d.params[0]),m(y)},disconnect:f}},{cleanup:()=>{r.clear(),s.clear(),n.clear()}})},b={type:h.ERROR,event:{type:"timeout"}},g=()=>{},_=o=>o.map(e=>typeof e=="string"?[e]:[e.uri,e.protocol]),j=(o=>(...e)=>{let r=[],s=g,n=3500;const[t]=e;e.length===1&&typeof t=="object"&&!Array.isArray(t)?(r=_(t.endpoints),s=t.onStatusChanged??g,n=t.timeout??n):(typeof e[1]=="function"&&(s=e[1]),Array.isArray(t)?r=_(t):(r=[[t]],e[1]&&e[1]!==s&&(r[0][1]=e[1]),e[2]&&(s=e[2])));let u=0,i,m=null,f=g,y=g;const d=M($(async()=>{const[l,E]=m||r[u++%r.length];m=null;const c=new o(l,E),R=()=>{try{c.addEventListener("error",g,{once:!0}),c.close()}catch{}};return s(i={type:h.CONNECTING,uri:l,protocols:E}),await new Promise((S,L)=>{const N=()=>{w(),S()},O=a=>{w(),a==null&&R(),console.error(`Unable to connect to ${l}${E?", protocols: "+E:""}`),s(i={type:a?h.ERROR:h.CLOSE,event:a}),setTimeout(L,a?300:0,a)},T=n!==1/0?setTimeout(()=>{w(),R(),s(i=b),L(b.event)},n):void 0,w=()=>{clearTimeout(T),c.removeEventListener("error",O),c.removeEventListener("open",N)};c.addEventListener("open",N),c.addEventListener("error",O),f=()=>{O(null)}}),s(i={type:h.CONNECTED,uri:l,protocols:E}),(S,L)=>{const N=a=>{typeof a.data=="string"&&S(a.data)},O=a=>q=>{console.warn(`WS halt (${a})`),s(i={type:a,event:q}),L()},T=O(h.ERROR),w=O(h.CLOSE);return c.addEventListener("message",N),c.addEventListener("error",T),c.addEventListener("close",w),f=a=>{y(),f=g,c.removeEventListener("message",N),c.removeEventListener("error",T),c.removeEventListener("close",w),R(),a&&w({})},{send:a=>{c.send(a)},disconnect:f}}}),()=>{p()});y=d.cleanup,delete d.cleanup;const p=(...l)=>{i.type!==h.CLOSE&&(l.length&&(m=l),i.type!==h.ERROR&&f(!0))};return Object.assign(d,{switch:p,getStatus:()=>i})})(WebSocket);v.WsEvent=h,v.getWsProvider=j});
