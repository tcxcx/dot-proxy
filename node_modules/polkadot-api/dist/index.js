'use strict';

var metadataCompatibility = require('@polkadot-api/metadata-compatibility');
var observableClient = require('@polkadot-api/observable-client');
var substrateClient = require('@polkadot-api/substrate-client');
var rxjs = require('rxjs');
var substrateBindings = require('@polkadot-api/substrate-bindings');
var utils = require('@polkadot-api/utils');
var operators = require('rxjs/operators');
var signer = require('@polkadot-api/signer');
var core = require('@rx-state/core');
var metadataBuilders = require('@polkadot-api/metadata-builders');

class RuntimeToken {
  constructor() {
  }
  // @ts-ignore
  _runtime(value) {
  }
}
class CompatibilityToken {
  constructor() {
  }
  // @ts-ignore
  _compatibility(value) {
  }
}
const compatibilityTokenApi = /* @__PURE__ */ new WeakMap();
const runtimeTokenApi = /* @__PURE__ */ new WeakMap();
const getCompatibilityApi = (token) => token instanceof RuntimeToken ? runtimeTokenApi.get(token) : compatibilityTokenApi.get(token);
var OpType = /* @__PURE__ */ ((OpType2) => {
  OpType2["Storage"] = "storage";
  OpType2["Tx"] = "tx";
  OpType2["Event"] = "events";
  OpType2["Const"] = "constants";
  return OpType2;
})(OpType || {});
const EntryPointsCodec = substrateBindings.Vector(metadataCompatibility.EntryPointCodec);
const TypedefsCodec = substrateBindings.Vector(metadataCompatibility.TypedefCodec);
const TypesCodec = substrateBindings.Tuple(EntryPointsCodec, TypedefsCodec);
const createCompatibilityToken = (chainDefinition, chainHead) => {
  const awaitedRuntime = new Promise(async (resolve) => {
    const loadedRuntime$ = chainHead.runtime$.pipe(rxjs.filter((v) => v != null));
    let latest = await rxjs.firstValueFrom(loadedRuntime$);
    loadedRuntime$.subscribe((v) => latest = v);
    resolve(() => latest);
  });
  const promise = Promise.all([
    chainDefinition.metadataTypes.then(TypesCodec.dec),
    chainDefinition.descriptors,
    awaitedRuntime
  ]).then(([[entryPoints, typedefNodes], descriptors, runtime]) => {
    const token = new CompatibilityToken();
    compatibilityTokenApi.set(token, {
      runtime,
      getPalletEntryPoint(opType, pallet, name) {
        const idx = descriptors[opType]?.[pallet]?.[name];
        if (idx == null)
          throw new Error(
            `Descriptor for ${opType} ${pallet}.${name} does not exist`
          );
        return entryPoints[idx];
      },
      getApiEntryPoint(name, method) {
        const idx = descriptors.apis?.[name]?.[method];
        if (idx == null)
          throw new Error(`Descriptor for API ${name}.${method} does not exist`);
        return entryPoints[idx];
      },
      typedefNodes
    });
    return token;
  });
  return promise;
};
const createRuntimeToken = (chainHead) => {
  const awaitedRuntime = new Promise(async (resolve) => {
    const loadedRuntime$ = chainHead.runtime$.pipe(rxjs.filter((v) => v != null));
    let latest = await rxjs.firstValueFrom(loadedRuntime$);
    loadedRuntime$.subscribe((v) => latest = v);
    resolve(() => latest);
  });
  const promise = awaitedRuntime.then((runtime) => {
    const token = new RuntimeToken();
    runtimeTokenApi.set(token, {
      runtime
    });
    return token;
  });
  return promise;
};
const metadataCache = /* @__PURE__ */ new WeakMap();
const getMetadataCache = (ctx) => {
  if (!metadataCache.has(ctx.metadataRaw)) {
    metadataCache.set(ctx.metadataRaw, {
      compat: /* @__PURE__ */ new Map(),
      lookup: ctx.lookup,
      typeNodes: []
    });
  }
  return metadataCache.get(ctx.metadataRaw);
};
const compatibilityHelper = (descriptors, getDescriptorEntryPoint, getRuntimeEntryPoint) => {
  const getRuntimeTypedef = (ctx, id) => {
    var _a;
    const cache = getMetadataCache(ctx);
    return (_a = cache.typeNodes)[id] || (_a[id] = metadataCompatibility.mapLookupToTypedef(cache.lookup(id)));
  };
  function getCompatibilityLevels(descriptors2, ctx) {
    if (descriptors2 instanceof RuntimeToken) {
      return {
        args: metadataCompatibility.CompatibilityLevel.Identical,
        values: metadataCompatibility.CompatibilityLevel.Identical
      };
    }
    const compatibilityApi = compatibilityTokenApi.get(descriptors2);
    ctx || (ctx = compatibilityApi.runtime());
    const descriptorEntryPoint = getDescriptorEntryPoint(compatibilityApi);
    const runtimeEntryPoint = getRuntimeEntryPoint(ctx);
    if (runtimeEntryPoint == null)
      return {
        args: metadataCompatibility.CompatibilityLevel.Incompatible,
        values: metadataCompatibility.CompatibilityLevel.Incompatible
      };
    const descriptorNodes = compatibilityApi.typedefNodes;
    const cache = getMetadataCache(ctx);
    return metadataCompatibility.entryPointsAreCompatible(
      descriptorEntryPoint,
      (id) => descriptorNodes[id],
      runtimeEntryPoint,
      (id) => getRuntimeTypedef(ctx, id),
      cache.compat
    );
  }
  const getCompatibilityLevel = withOptionalToken(
    descriptors,
    (runtime) => minCompatLevel(getCompatibilityLevels(runtime))
  );
  const isCompatible = withOptionalToken(
    descriptors,
    (threshold, runtime) => getCompatibilityLevel(runtime) >= threshold
  );
  const compatibleRuntime$ = (chainHead, hash) => rxjs.combineLatest([descriptors, chainHead.getRuntimeContext$(hash)]);
  const withCompatibleRuntime = (chainHead, mapper) => (source$) => rxjs.combineLatest([
    source$.pipe(chainHead.withRuntime(mapper)),
    descriptors
  ]).pipe(rxjs.map(([[x, ctx], descriptors2]) => [x, descriptors2, ctx]));
  const argsAreCompatible = (descriptors2, ctx, args) => {
    if (descriptors2 instanceof RuntimeToken) return true;
    const levels = getCompatibilityLevels(descriptors2, ctx);
    if (levels.args === metadataCompatibility.CompatibilityLevel.Incompatible) return false;
    if (levels.args > metadataCompatibility.CompatibilityLevel.Partial) return true;
    if (levels.values === metadataCompatibility.CompatibilityLevel.Incompatible) return false;
    const entryPoint = getRuntimeEntryPoint(ctx);
    if (entryPoint == null) return false;
    return metadataCompatibility.valueIsCompatibleWithDest(
      entryPoint.args,
      (id) => getRuntimeTypedef(ctx, id),
      args
    );
  };
  const valuesAreCompatible = (descriptors2, ctx, values) => {
    if (descriptors2 instanceof RuntimeToken) return true;
    const level = getCompatibilityLevels(descriptors2, ctx).values;
    if (level === metadataCompatibility.CompatibilityLevel.Incompatible) return false;
    if (level > metadataCompatibility.CompatibilityLevel.Partial) return true;
    const compatibilityApi = compatibilityTokenApi.get(descriptors2);
    const entryPoint = getDescriptorEntryPoint(compatibilityApi);
    return metadataCompatibility.valueIsCompatibleWithDest(
      entryPoint.values,
      (id) => compatibilityApi.typedefNodes[id],
      values
    );
  };
  return {
    isCompatible,
    getCompatibilityLevel,
    getCompatibilityLevels,
    descriptors,
    withCompatibleRuntime,
    compatibleRuntime$,
    argsAreCompatible,
    valuesAreCompatible,
    getRuntimeTypedef
  };
};
const minCompatLevel = (levels) => Math.min(levels.args, levels.values);
const withOptionalToken = (compatibilityToken, fn) => (...args) => {
  const lastElement = args.at(-1);
  if (lastElement instanceof CompatibilityToken || lastElement instanceof RuntimeToken) {
    return fn(...args);
  }
  return compatibilityToken.then((token) => fn(...args, token));
};

const createConstantEntry = (palletName, name, {
  valuesAreCompatible,
  descriptors,
  isCompatible,
  getCompatibilityLevel
}) => {
  const cachedResults = /* @__PURE__ */ new WeakMap();
  const getValueWithContext = (ctx) => {
    if (cachedResults.has(ctx)) {
      return cachedResults.get(ctx);
    }
    const pallet = ctx.lookup.metadata.pallets.find(
      (p) => p.name === palletName
    );
    const constant = pallet?.constants.find((c) => c.name === name);
    if (constant == null)
      throw new Error(`Runtime entry Constant(${palletName}.${name}) not found`);
    const result = ctx.dynamicBuilder.buildConstant(palletName, name).dec(constant.value);
    cachedResults.set(ctx, result);
    return result;
  };
  const fn = (token) => {
    if (token) {
      const ctx = getCompatibilityApi(token).runtime();
      const value = getValueWithContext(ctx);
      if (!valuesAreCompatible(token, ctx, value))
        throw new Error(
          `Incompatible runtime entry Constant(${palletName}.${name})`
        );
      return value;
    }
    return descriptors.then(fn);
  };
  return Object.assign(fn, { isCompatible, getCompatibilityLevel });
};

const shareLatest = rxjs.share({
  connector: () => new rxjs.ReplaySubject(1),
  resetOnError: true,
  resetOnComplete: true,
  resetOnRefCountZero: true
});

function firstValueFromWithSignal(source, signal) {
  return new Promise((resolve, reject) => {
    let subscription = null;
    let isDone = false;
    const onAbort = signal ? () => {
      subscription?.unsubscribe();
      reject(new utils.AbortError());
    } : rxjs.noop;
    subscription = source.subscribe({
      next: (value) => {
        resolve(value);
        subscription?.unsubscribe();
        isDone = true;
      },
      error: (e) => {
        signal?.removeEventListener("abort", onAbort);
        reject(e);
        isDone = true;
      },
      complete: () => {
        signal?.removeEventListener("abort", onAbort);
        reject(new Error("Observable completed without emitting"));
        isDone = true;
      }
    });
    if (!isDone) signal?.addEventListener("abort", onAbort);
  });
}

const EMPTY_VALUE = Symbol("EMPTY_VALUE");
const lossLessExhaustMap = (mapper) => (source$) => new rxjs.Observable((observer) => {
  let idx = 0;
  let innerSubscription = null;
  let queuedValue = EMPTY_VALUE;
  let isOutterDone = false;
  const setInnerSubscription = () => {
    const observable = mapper(queuedValue, idx++);
    queuedValue = EMPTY_VALUE;
    innerSubscription = observable.subscribe({
      next(vv) {
        observer.next(vv);
      },
      error(ee) {
        observer.error(ee);
      },
      complete() {
        if (queuedValue !== EMPTY_VALUE) setInnerSubscription();
        else {
          innerSubscription = null;
          if (isOutterDone) observer.complete();
        }
      }
    });
  };
  const subscription = source$.subscribe({
    next(v) {
      queuedValue = v;
      if (!innerSubscription) setInnerSubscription();
    },
    error(e) {
      observer.error(e);
    },
    complete() {
      if (!innerSubscription) observer.complete();
      isOutterDone = true;
    }
  });
  return () => {
    innerSubscription?.unsubscribe();
    subscription.unsubscribe();
  };
});

let NOTIN = {};
const continueWith = (mapper) => (source) => new rxjs.Observable((observer) => {
  let latestValue = NOTIN;
  let subscription = source.subscribe({
    next(v) {
      observer.next(latestValue = v);
    },
    error(e) {
      observer.error(e);
    },
    complete() {
      if (latestValue === NOTIN) observer.complete();
      else subscription = mapper(latestValue).subscribe(observer);
    }
  });
  return () => {
    subscription.unsubscribe();
  };
});

const isOptionalArg = (lastArg) => typeof lastArg === "object" && lastArg !== null && Object.entries(lastArg).every(
  ([k, v]) => k === "at" && (v === void 0 || typeof v === "string") || k === "signal" && (v === void 0 || v instanceof AbortSignal)
);

const selfDependent = () => {
  const activeSubject = new rxjs.BehaviorSubject(
    new rxjs.Subject()
  );
  return [
    activeSubject.pipe(operators.switchAll()),
    () => operators.tap({
      next: (v) => activeSubject.value.next(v),
      error: (e) => {
        activeSubject.value.error(e);
        activeSubject.next(new rxjs.Subject());
      },
      complete: () => {
        activeSubject.value.complete();
        activeSubject.next(new rxjs.Subject());
      }
    })
  ];
};

const createEventEntry = (pallet, name, chainHead, {
  isCompatible,
  getCompatibilityLevel,
  withCompatibleRuntime,
  argsAreCompatible,
  valuesAreCompatible
}) => {
  const compatibilityError = () => new Error(`Incompatible runtime entry Event(${pallet}.${name})`);
  const shared$ = chainHead.finalized$.pipe(
    withCompatibleRuntime(chainHead, (x) => x.hash),
    rxjs.map(([block, runtime, ctx]) => {
      const eventsIdx = ctx.lookup.metadata.pallets.find(
        (p) => p.name === pallet
      )?.events;
      if (eventsIdx == null || ctx.lookup.metadata.lookup[eventsIdx].def.tag !== "variant" || ctx.lookup.metadata.lookup[eventsIdx].def.value.find(
        (ev) => ev.name === name
      ) == null)
        throw new Error(`Runtime entry Event(${pallet}.${name}) not found`);
      if (!argsAreCompatible(runtime, ctx, null)) throw compatibilityError();
      return [block, runtime, ctx];
    }),
    observableClient.concatMapEager(
      ([block, runtime, ctx]) => chainHead.eventsAt$(block.hash).pipe(
        rxjs.map((events) => {
          const winners = events.filter(
            (e) => e.event.type === pallet && e.event.value.type === name
          );
          return winners.map((x) => {
            if (!valuesAreCompatible(runtime, ctx, x.event.value.value))
              throw compatibilityError();
            return {
              meta: {
                phase: x.phase,
                block
              },
              payload: x.event.value.value
            };
          });
        })
      )
    ),
    shareLatest
  );
  const watch = (f) => shared$.pipe(rxjs.mergeMap((x) => f ? x.filter((d) => f(d.payload)) : x));
  const pull = () => rxjs.firstValueFrom(shared$);
  const filter = (events) => events.filter((e) => e.type === pallet && e.value.type === name).map((x) => x.value.value);
  return { watch, pull, filter, getCompatibilityLevel, isCompatible };
};

const createRuntimeCallEntry = (api, method, chainHead, {
  isCompatible,
  getCompatibilityLevel,
  compatibleRuntime$,
  argsAreCompatible,
  valuesAreCompatible
}) => {
  const callName = `${api}_${method}`;
  const compatibilityError = () => new Error(`Incompatible runtime entry RuntimeCall(${callName})`);
  const fn = (...args) => {
    const lastArg = args[args.length - 1];
    const isLastArgOptional = isOptionalArg(lastArg);
    const { signal, at: _at } = isLastArgOptional ? lastArg : {};
    const at = _at ?? null;
    const result$ = compatibleRuntime$(chainHead, at).pipe(
      rxjs.mergeMap(([runtime, ctx]) => {
        let codecs;
        try {
          codecs = ctx.dynamicBuilder.buildRuntimeCall(api, method);
        } catch {
          throw new Error(`Runtime entry RuntimeCall(${callName}) not found`);
        }
        if (!argsAreCompatible(runtime, ctx, args)) throw compatibilityError();
        return chainHead.call$(at, callName, utils.toHex(codecs.args.enc(args))).pipe(
          rxjs.map(codecs.value.dec),
          rxjs.map((value) => {
            if (!valuesAreCompatible(runtime, ctx, value))
              throw compatibilityError();
            return value;
          })
        );
      })
    );
    return firstValueFromWithSignal(result$, signal);
  };
  return Object.assign(fn, { getCompatibilityLevel, isCompatible });
};

const toMapped = rxjs.map((x) => x.mapped);
const createStorageEntry = (pallet, name, chainHead, getWatchEntries, {
  isCompatible,
  getCompatibilityLevel,
  getCompatibilityLevels,
  descriptors: descriptorsPromise,
  argsAreCompatible,
  valuesAreCompatible
}) => {
  const isSystemNumber = pallet === "System" && name === "Number";
  const isBlockHash = pallet === "System" && name === "BlockHash";
  const sysNumberMapper$ = chainHead.runtime$.pipe(
    rxjs.filter(Boolean),
    rxjs.take(1),
    rxjs.map(
      ({ dynamicBuilder }) => typeof dynamicBuilder.buildStorage("System", "Number").value.dec(new Uint8Array(32)) === "bigint" ? BigInt : rxjs.identity
    ),
    rxjs.shareReplay()
  );
  const bigIntOrNumber = rxjs.pipe(
    rxjs.combineLatestWith(sysNumberMapper$),
    rxjs.map(([input, mapper]) => mapper(input))
  );
  const incompatibleError = () => new Error(`Incompatible runtime entry Storage(${pallet}.${name})`);
  const invalidArgs = (args) => new Error(`Invalid Arguments calling ${pallet}.${name}(${args})`);
  const getCodec = (ctx) => {
    try {
      return ctx.dynamicBuilder.buildStorage(pallet, name);
    } catch (e) {
      throw new Error(`Runtime entry Storage(${pallet}.${name}) not found`);
    }
  };
  const watchValue = (...args) => {
    const target = args[args.length - 1];
    const isBest = target === "best";
    const actualArgs = isBest || target === "finalized" ? args.slice(0, -1) : args;
    return chainHead[isBest ? "best$" : "finalized$"].pipe(
      lossLessExhaustMap(
        () => getRawValue$(...actualArgs, isBest ? { at: "best" } : {})
      ),
      rxjs.distinctUntilChanged((a, b) => a.raw === b.raw),
      toMapped
    );
  };
  const getRawValue$ = (...args) => {
    const lastArg = args[args.length - 1];
    const isLastArgOptional = isOptionalArg(lastArg);
    const { at: _at } = isLastArgOptional ? lastArg : {};
    const at = _at ?? null;
    if (isSystemNumber)
      return chainHead.bestBlocks$.pipe(
        rxjs.map((blocks) => {
          if (at === "finalized" || !at) return blocks.at(-1);
          if (at === "best") return blocks.at(0);
          return blocks.find((block) => block.hash === at);
        }),
        rxjs.map((block) => {
          if (!block) throw new observableClient.NotBestBlockError();
          return block.number;
        }),
        rxjs.distinctUntilChanged(),
        bigIntOrNumber,
        rxjs.map((mapped) => ({ raw: mapped, mapped }))
      );
    if (isBlockHash && Number(args[0]) === 0) {
      return chainHead.genesis$.pipe(
        rxjs.map((raw) => ({ raw, mapped: substrateBindings.FixedSizeBinary.fromHex(raw) }))
      );
    }
    return rxjs.from(descriptorsPromise).pipe(
      rxjs.mergeMap(
        (descriptors) => chainHead.storage$(
          at,
          "value",
          (ctx) => {
            const codecs = getCodec(ctx);
            const actualArgs = args.length === codecs.len ? args : args.slice(0, -1);
            if (args !== actualArgs && !isLastArgOptional)
              throw invalidArgs(args);
            if (!argsAreCompatible(descriptors, ctx, actualArgs))
              throw incompatibleError();
            return codecs.keys.enc(...actualArgs);
          },
          null,
          (data, ctx) => {
            const codecs = getCodec(ctx);
            const value = data === null ? codecs.fallback : codecs.value.dec(data);
            if (!valuesAreCompatible(descriptors, ctx, value))
              throw incompatibleError();
            return value;
          }
        )
      )
    );
  };
  const getValue = async (...args) => {
    const lastArg = args[args.length - 1];
    const isLastArgOptional = isOptionalArg(lastArg);
    const { signal } = isLastArgOptional ? lastArg : {};
    return firstValueFromWithSignal(
      getRawValue$(...args).pipe(toMapped),
      signal
    );
  };
  const getEntries = async (...args) => {
    const lastArg = args[args.length - 1];
    const isLastArgOptional = isOptionalArg(lastArg);
    const { signal, at: _at } = isLastArgOptional ? lastArg : {};
    const at = _at ?? null;
    const descriptors = await descriptorsPromise;
    const result$ = chainHead.storage$(
      at,
      "descendantsValues",
      (ctx) => {
        const codecs = getCodec(ctx);
        if (minCompatLevel(getCompatibilityLevels(descriptors, ctx)) === metadataCompatibility.CompatibilityLevel.Incompatible)
          throw incompatibleError();
        if (args.length > codecs.len) throw invalidArgs(args);
        const actualArgs = args.length > 0 && isLastArgOptional ? args.slice(0, -1) : args;
        if (args.length === codecs.len && actualArgs === args)
          throw invalidArgs(args);
        return codecs.keys.enc(...actualArgs);
      },
      null,
      (values, ctx) => {
        const codecs = getCodec(ctx);
        const decodedValues = values.map(({ key, value }) => ({
          keyArgs: codecs.keys.dec(key),
          value: codecs.value.dec(value)
        }));
        if (decodedValues.some(
          ({ value }) => !valuesAreCompatible(descriptors, ctx, value)
        ))
          throw incompatibleError();
        return decodedValues;
      }
    ).pipe(toMapped);
    return firstValueFromWithSignal(result$, signal);
  };
  const getValues = (keyArgs, options) => Promise.all(
    keyArgs.map((args) => getValue(...options ? [...args, options] : args))
  );
  const watchEntries = (...args) => {
    const lastArg = args.at(-1);
    const isLastArgOptional = isOptionalArg(lastArg);
    return getWatchEntries(
      pallet,
      name,
      isLastArgOptional ? args.slice(0, -1) : args,
      isLastArgOptional && lastArg.at === "best"
    );
  };
  return {
    isCompatible,
    getCompatibilityLevel,
    getValue,
    getValues,
    getEntries,
    watchValue,
    watchEntries
  };
};

const getSystemVersionStruct = (lookupFn, dynamicBuilder) => {
  const constant = lookupFn.metadata.pallets.find((x) => x.name === "System").constants.find((s) => s.name === "Version");
  const systemVersion = lookupFn(constant.type);
  const systemVersionDec = dynamicBuilder.buildDefinition(constant.type).dec;
  if (systemVersion.type !== "struct") throw new Error("not a struct");
  return systemVersionDec(constant.value);
};

function trailingZeroes(n) {
  let i = 0;
  while (!(n & 1)) {
    i++;
    n >>= 1;
  }
  return i;
}
const mortal = substrateBindings.enhanceEncoder(
  substrateBindings.Bytes(2)[0],
  (value) => {
    const factor = Math.max(value.period >> 12, 1);
    const left = Math.min(Math.max(trailingZeroes(value.period) - 1, 1), 15);
    const right = value.phase / factor << 4;
    return substrateBindings.u16[0](left | right);
  }
);

const [ChargeAssetTxPaymentEnc] = substrateBindings.Struct({
  tip: substrateBindings.compact,
  asset: substrateBindings.Option(substrateBindings.Bytes(Infinity))
});

const empty = new Uint8Array();
const zero = Uint8Array.from([0]);
const value = (value2) => ({
  value: value2,
  additionalSigned: empty
});
const additionalSigned = (additionalSigned2) => ({
  value: empty,
  additionalSigned: additionalSigned2
});
const both = (value2, additionalSigned2) => ({
  value: value2,
  additionalSigned: additionalSigned2
});
const getSignExtensionsCreator = (genesis, lookupFn, dynamicBuilder) => {
  const signedExtensionsEncoders = {};
  lookupFn.metadata.extrinsic.signedExtensions.forEach(
    ({ identifier, type, additionalSigned: additionalSigned2 }) => {
      signedExtensionsEncoders[identifier] = [type, additionalSigned2].map(
        (x) => dynamicBuilder.buildDefinition(x)[0]
      );
    }
  );
  return ({
    mortality,
    tip = 0n,
    nonce,
    customSignedExtensions = {},
    ...rest
  }) => {
    const invalidKeys = [];
    const systemVersion = getSystemVersionStruct(lookupFn, dynamicBuilder);
    const getFromCustomEntry = (key) => {
      const [valueEnc, additionalEnc] = signedExtensionsEncoders[key];
      const customEntry = customSignedExtensions[key];
      try {
        return utils.mapObject(
          {
            value: valueEnc,
            additionalSigned: additionalEnc
          },
          (encoder, key2) => {
            const input = customEntry?.[key2];
            return input instanceof Uint8Array ? input : encoder(input);
          }
        );
      } catch {
        invalidKeys.push(key);
        return null;
      }
    };
    const result = utils.mapObject(
      signedExtensionsEncoders,
      ([valueEnc, additionalEnc], key) => {
        if (customSignedExtensions[key]) return getFromCustomEntry(key);
        switch (key) {
          case "CheckNonce":
            return value(valueEnc(nonce));
          case "CheckMortality":
            return mortality.mortal ? both(
              mortal({
                period: mortality.period,
                phase: mortality.startAtBlock.height % mortality.period
              }),
              utils.fromHex(mortality.startAtBlock.hash)
            ) : both(zero, genesis);
          case "ChargeTransactionPayment":
            return value(valueEnc(tip));
          case "ChargeAssetTxPayment":
            return value(
              ChargeAssetTxPaymentEnc({
                tip,
                asset: rest.asset
              })
            );
          case "CheckGenesis":
            return additionalSigned(genesis);
          case "CheckMetadataHash":
            return both(zero, zero);
          case "CheckSpecVersion":
            return additionalSigned(
              additionalEnc(systemVersion["spec_version"])
            );
          case "CheckTxVersion":
            return additionalSigned(
              additionalEnc(systemVersion["transaction_version"])
            );
          default:
            return getFromCustomEntry(key);
        }
      }
    );
    invalidKeys.forEach((key) => {
      delete result[key];
    });
    return utils.mapObject(result, (x, identifier) => ({ ...x, identifier }));
  };
};

const NONCE_RUNTIME_CALL = "AccountNonceApi_account_nonce";
const lenToDecoder = {
  1: substrateBindings.u8.dec,
  2: substrateBindings.u16.dec,
  4: substrateBindings.u32.dec,
  8: substrateBindings.u64.dec
};
const getNonce$ = (call$, from, at) => call$(at, NONCE_RUNTIME_CALL, from).pipe(
  rxjs.map((result) => {
    const bytes = utils.fromHex(result);
    const decoder = lenToDecoder[bytes.length];
    if (!decoder)
      throw new Error(`${NONCE_RUNTIME_CALL} retrieved wrong data`);
    return decoder(bytes);
  })
);
const createTx = (chainHead, signer, callData, atBlock, customSignedExtensions, hinted = {}) => rxjs.combineLatest([
  hinted.nonce ? rxjs.of(hinted.nonce) : getNonce$(chainHead.call$, utils.toHex(signer.publicKey), atBlock.hash),
  chainHead.getRuntimeContext$(atBlock.hash),
  chainHead.genesis$
]).pipe(
  rxjs.take(1),
  rxjs.mergeMap(([nonce, ctx, genesis]) => {
    const signExtCreator = getSignExtensionsCreator(
      utils.fromHex(genesis),
      ctx.lookup,
      ctx.dynamicBuilder
    );
    const mortality = hinted.mortality ?? { period: 64, mortal: true };
    const signExtensions = signExtCreator({
      nonce,
      tip: hinted.tip ?? 0n,
      mortality: mortality.mortal ? {
        mortal: true,
        period: mortality.period,
        startAtBlock: {
          height: atBlock.number,
          hash: atBlock.hash
        }
      } : { mortal: false },
      customSignedExtensions
    });
    return signer.signTx(
      callData,
      signExtensions,
      ctx.metadataRaw,
      atBlock.number
    );
  })
);

var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => __defNormalProp(obj, key + "" , value);
const hashFromTx = (tx) => utils.toHex(substrateBindings.Blake2256(utils.fromHex(tx)));
const computeState = (analized$, blocks$) => new rxjs.Observable((observer) => {
  const analyzedBlocks = /* @__PURE__ */ new Map();
  let pinnedBlocks;
  let latestState;
  const computeNextState = () => {
    let current = pinnedBlocks.best;
    let analyzed = analyzedBlocks.get(current);
    let analyzedNumber = pinnedBlocks.blocks.get(current).number;
    while (!analyzed) {
      const block = pinnedBlocks.blocks.get(current);
      if (!block) break;
      analyzed = analyzedBlocks.get(current = block.parent);
      analyzedNumber--;
    }
    if (!analyzed) return;
    const isFinalized = analyzedNumber <= pinnedBlocks.blocks.get(pinnedBlocks.finalized).number;
    const found = analyzed.found.type;
    if (found && latestState?.found && latestState.hash === analyzed.hash) {
      if (isFinalized) observer.complete();
      return;
    }
    observer.next(
      latestState = analyzed.found.type ? {
        found,
        hash: analyzed.hash,
        number: analyzedNumber,
        index: analyzed.found.index,
        events: analyzed.found.events
      } : {
        found,
        validity: analyzed.found.validity
      }
    );
    if (isFinalized) {
      if (found) observer.complete();
      else if (analyzed.found.validity?.success === false)
        observer.error(new InvalidTxError(analyzed.found.validity.value));
    }
  };
  const subscription = blocks$.pipe(
    rxjs.distinctUntilChanged(
      (a, b) => a.finalized === b.finalized && a.best === b.best
    )
  ).subscribe({
    next: (pinned) => {
      pinnedBlocks = pinned;
      if (analyzedBlocks.size === 0) return;
      computeNextState();
    },
    error(e) {
      observer.error(e);
    }
  });
  subscription.add(
    analized$.subscribe({
      next: (block) => {
        analyzedBlocks.set(block.hash, block);
        computeNextState();
      },
      error(e) {
        observer.error(e);
      }
    })
  );
  return subscription;
}).pipe(rxjs.distinctUntilChanged((a, b) => a === b));
const getTxSuccessFromSystemEvents = (systemEvents, txIdx) => {
  const events = systemEvents.filter((x) => x.phase.type === "ApplyExtrinsic" && x.phase.value === txIdx).map((x) => ({ ...x.event, topics: x.topics }));
  const lastEvent = events[events.length - 1];
  if (lastEvent.type === "System" && lastEvent.value.type === "ExtrinsicFailed") {
    return {
      ok: false,
      events,
      dispatchError: lastEvent.value.value.dispatch_error
    };
  }
  return { ok: true, events };
};
class InvalidTxError extends Error {
  // likely to be a `TransactionValidityError`
  constructor(e) {
    super(
      JSON.stringify(
        e,
        (_, value) => {
          if (typeof value === "bigint") return value.toString();
          return value instanceof substrateBindings.Binary ? value.asHex() : value;
        },
        2
      )
    );
    __publicField(this, "error");
    this.name = "InvalidTxError";
    this.error = e;
  }
}
const submit$ = (chainHead, broadcastTx$, tx, at, emitSign = false) => {
  const txHash = hashFromTx(tx);
  const getTxEvent = (type, rest) => ({
    type,
    txHash,
    ...rest
  });
  const at$ = chainHead.pinnedBlocks$.pipe(
    rxjs.take(1),
    rxjs.map((blocks) => {
      const block = blocks.blocks.get(at);
      return block && !block.unpinned ? block.hash : blocks.finalized;
    })
  );
  const validate$ = at$.pipe(
    rxjs.mergeMap(
      (at2) => chainHead.validateTx$(at2, tx).pipe(
        rxjs.filter((x) => !x.success),
        rxjs.map((x) => {
          throw new InvalidTxError(x.value);
        })
      )
    )
  );
  const track$ = new rxjs.Observable((observer) => {
    const subscription = chainHead.trackTx$(tx).subscribe(observer);
    subscription.add(
      broadcastTx$(tx).subscribe({
        error(e) {
          observer.error(e);
        }
      })
    );
    return subscription;
  });
  const bestBlockState$ = computeState(track$, chainHead.pinnedBlocks$).pipe(
    rxjs.map((x) => {
      if (!x.found)
        return getTxEvent("txBestBlocksState", {
          found: false,
          isValid: x.validity?.success !== false
        });
      return getTxEvent("txBestBlocksState", {
        found: true,
        block: {
          index: x.index,
          number: x.number,
          hash: x.hash
        },
        ...getTxSuccessFromSystemEvents(x.events, x.index)
      });
    })
  );
  return rxjs.concat(
    emitSign ? rxjs.of(getTxEvent("signed", {})) : rxjs.EMPTY,
    validate$,
    rxjs.of(getTxEvent("broadcasted", {})),
    bestBlockState$.pipe(
      continueWith(
        ({ found, type, ...rest }) => found ? rxjs.of(getTxEvent("finalized", rest)) : rxjs.EMPTY
      )
    )
  );
};
const submit = async (chainHead, broadcastTx$, transaction, at) => rxjs.lastValueFrom(submit$(chainHead, broadcastTx$, transaction, at)).then((x) => {
  if (x.type !== "finalized") throw null;
  const result = { ...x };
  delete result.type;
  return result;
});

const accountIdEnc = substrateBindings.AccountId().enc;
const fakeSignature = new Uint8Array(64);
const fakeSignatureEth = new Uint8Array(65);
const getFakeSignature = (isEth) => () => isEth ? fakeSignatureEth : fakeSignature;
const [, queryInfoDecFallback] = substrateBindings.Struct({
  weight: substrateBindings.Struct({
    ref_time: substrateBindings.compactBn,
    proof_size: substrateBindings.compactBn
  }),
  class: substrateBindings.Variant({
    Normal: substrateBindings._void,
    Operational: substrateBindings._void,
    Mandatory: substrateBindings._void
  }),
  partial_fee: substrateBindings.u128
});
const createTxEntry = (pallet, name, chainHead, broadcast, {
  isCompatible: isCompatibleHelper,
  getCompatibilityLevel,
  compatibleRuntime$,
  argsAreCompatible,
  getRuntimeTypedef
}, checkCompatibility) => {
  const fn = (arg) => {
    const getCallDataWithContext = (runtime, arg2, txOptions = {}) => {
      const ctx = getCompatibilityApi(runtime).runtime();
      const { dynamicBuilder, assetId, lookup } = ctx;
      let codecs;
      try {
        codecs = dynamicBuilder.buildCall(pallet, name);
      } catch {
        throw new Error(`Runtime entry Tx(${pallet}.${name}) not found`);
      }
      if (checkCompatibility && !argsAreCompatible(runtime, ctx, arg2))
        throw new Error(`Incompatible runtime entry Tx(${pallet}.${name})`);
      let returnOptions = txOptions;
      if (txOptions.asset) {
        if (assetId == null || !metadataCompatibility.isCompatible(
          txOptions.asset,
          metadataCompatibility.mapLookupToTypedef(lookup(assetId)),
          (id) => getRuntimeTypedef(ctx, id)
        ))
          throw new Error(`Incompatible runtime asset`);
        returnOptions = {
          ...txOptions,
          asset: dynamicBuilder.buildDefinition(assetId).enc(txOptions.asset)
        };
      }
      const { location, codec } = codecs;
      return {
        callData: substrateBindings.Binary.fromBytes(
          utils.mergeUint8(new Uint8Array(location), codec.enc(arg2))
        ),
        options: returnOptions
      };
    };
    const getCallData$ = (arg2, options = {}) => compatibleRuntime$(chainHead, null).pipe(
      rxjs.map(([runtime]) => getCallDataWithContext(runtime, arg2, options))
    );
    const getEncodedData = (token) => {
      if (!token)
        return rxjs.firstValueFrom(getCallData$(arg).pipe(rxjs.map((x) => x.callData)));
      return getCallDataWithContext(token, arg).callData;
    };
    const sign$ = (from, { ..._options }, atBlock) => getCallData$(arg, _options).pipe(
      rxjs.mergeMap(
        ({ callData, options }) => createTx(
          chainHead,
          from,
          callData.asBytes(),
          atBlock,
          _options.customSignedExtensions || {},
          options
        )
      )
    );
    const _sign = (from, { at, ..._options } = {}) => {
      return (!at || at === "finalized" ? chainHead.finalized$ : at === "best" ? chainHead.best$ : chainHead.bestBlocks$.pipe(
        rxjs.map((x) => x.find((b) => b.hash === at))
      )).pipe(
        rxjs.take(1),
        rxjs.mergeMap(
          (atBlock) => atBlock ? sign$(from, _options, atBlock).pipe(
            rxjs.map((signed) => ({
              tx: utils.toHex(signed),
              block: atBlock
            }))
          ) : rxjs.throwError(() => new Error(`Uknown block ${at}`))
        )
      );
    };
    const sign = (from, options) => rxjs.firstValueFrom(_sign(from, options)).then((x) => x.tx);
    const signAndSubmit = (from, _options) => rxjs.firstValueFrom(_sign(from, _options)).then(
      ({ tx, block }) => submit(chainHead, broadcast, tx, block.hash)
    );
    const signSubmitAndWatch = (from, _options) => _sign(from, _options).pipe(
      rxjs.mergeMap(
        ({ tx, block }) => submit$(chainHead, broadcast, tx, block.hash, true)
      )
    );
    const getPaymentInfo = async (from, _options) => {
      if (typeof from === "string")
        from = from.startsWith("0x") ? utils.fromHex(from) : accountIdEnc(from);
      const isEth = from.length === 20;
      const fakeSigner = signer.getPolkadotSigner(
        from,
        isEth ? "Ecdsa" : "Sr25519",
        getFakeSignature(isEth)
      );
      const encoded = utils.fromHex(await sign(fakeSigner, _options));
      const args = utils.toHex(utils.mergeUint8(encoded, substrateBindings.u32.enc(encoded.length)));
      const decoder$ = chainHead.getRuntimeContext$(null).pipe(
        rxjs.map((ctx) => {
          try {
            return ctx.dynamicBuilder.buildRuntimeCall(
              "TransactionPaymentApi",
              "query_info"
            ).value[1];
          } catch {
            return queryInfoDecFallback;
          }
        })
      );
      const call$ = chainHead.call$(
        null,
        "TransactionPaymentApi_query_info",
        args
      );
      return rxjs.firstValueFrom(
        rxjs.combineLatest([call$, decoder$]).pipe(
          rxjs.map(([result, decoder]) => decoder(result))
        )
      );
    };
    const getEstimatedFees = async (from, _options) => (await getPaymentInfo(from, _options)).partial_fee;
    return {
      getPaymentInfo,
      getEstimatedFees,
      decodedCall: {
        type: pallet,
        value: substrateBindings.Enum(name, arg)
      },
      getEncodedData,
      sign,
      signSubmitAndWatch,
      signAndSubmit
    };
  };
  return Object.assign(fn, {
    getCompatibilityLevel,
    isCompatible: isCompatibleHelper
  });
};

const getDiff = (_prev, _current, patch) => {
  const current = new Map(_current.map((x) => [x.key, x]));
  const prev = new Map(_prev.map((x) => [x.key, x]));
  const upserted = /* @__PURE__ */ new Map();
  const deleted = [];
  _current.forEach((value) => {
    const { key } = value;
    const prevVal = prev.get(key);
    if (!prevVal || prevVal.value !== value.value)
      upserted.set(key, patch(value));
  });
  _prev.forEach((x) => {
    if (!current.has(x.key)) deleted.push(x);
  });
  return {
    deltas: {
      deleted,
      upserted: [...upserted.values()]
    },
    entries: _current.map(({ key }) => upserted.get(key) ?? prev.get(key))
  };
};
const findPrevious = (start, state2, pinned, includeStart = false) => {
  try {
    let target = includeStart ? start : pinned.blocks.get(start).parent;
    while (target && !state2[target]) target = pinned.blocks.get(target).parent;
    if (!target) return null;
    return state2[target];
  } catch {
    return null;
  }
};
const getPatcherFromRuntime = (pallet, entry) => (runtime) => {
  const { keys, value } = runtime.dynamicBuilder.buildStorage(pallet, entry);
  return (x) => {
    x.dec = {
      value: value.dec(x.value),
      args: keys.dec(x.key)
    };
    return x;
  };
};
const createWatchEntries = (blocks$, storage, withRuntime) => {
  const getMemoryBlocks$ = core.state(
    (pallet, entry, storageKey) => {
      const getPatcher = getPatcherFromRuntime(pallet, entry);
      const getNextMemoryBlock$ = (prev, block) => {
        const isNotCanonical$ = observableClient.isBestOrFinalizedBlock(
          blocks$,
          block.hash
        ).pipe(
          rxjs.filter((x) => !x),
          rxjs.take(1)
        );
        return storage(
          block.hash,
          "closestDescendantMerkleValue",
          () => storageKey
        ).pipe(
          rxjs.mergeMap((rootHash) => {
            if (rootHash === prev?.rootHash)
              return rxjs.of({
                ...prev,
                block,
                deltas: null,
                prev: prev.block.hash
              });
            return storage(
              block.hash,
              "descendantsValues",
              () => storageKey
            ).pipe(
              withRuntime(() => block.hash),
              rxjs.map(
                ([entries, runtimeCtx]) => [entries, getPatcher(runtimeCtx)]
              ),
              rxjs.map(
                ([entries, patcher]) => ({
                  prev: prev && prev.block.hash,
                  rootHash,
                  block,
                  ...getDiff(
                    prev?.entries ?? [],
                    entries,
                    patcher
                  )
                })
              )
            );
          }),
          rxjs.takeUntil(isNotCanonical$),
          rxjs.catchError(
            (e) => e instanceof observableClient.BlockNotPinnedError ? rxjs.EMPTY : rxjs.throwError(() => e)
          )
        );
      };
      const initial$ = blocks$.pipe(
        rxjs.distinctUntilChanged((a, b) => a.finalized === b.finalized),
        lossLessExhaustMap(
          ({ blocks, finalized }) => getNextMemoryBlock$(null, blocks.get(finalized))
        ),
        rxjs.take(1),
        rxjs.map(
          (x) => ({
            blocks: { [x.block.hash]: x },
            finalized: x.block.hash
          })
        )
      );
      const [_memoryBlocks$, connectMemoryBlocks] = selfDependent();
      const updates$ = blocks$.pipe(
        rxjs.distinctUntilChanged((a, b) => a.best === b.best),
        rxjs.withLatestFrom(_memoryBlocks$),
        lossLessExhaustMap(([pinned, memoryBlocks]) => {
          const { best } = pinned;
          const { blocks } = memoryBlocks;
          let target = !blocks[best] ? best : null;
          if (!target) return rxjs.EMPTY;
          const previous = findPrevious(target, blocks, pinned);
          if (previous)
            return getNextMemoryBlock$(
              previous,
              pinned.blocks.get(target)
            ).pipe(
              rxjs.map((x) => {
                blocks[target] = x;
                return memoryBlocks;
              })
            );
          target = pinned.finalized;
          return getNextMemoryBlock$(
            blocks[memoryBlocks.finalized],
            pinned.blocks.get(target)
          ).pipe(
            rxjs.map((x) => {
              x.prev = null;
              return {
                blocks: { [target]: x },
                finalized: target
              };
            })
          );
        })
      );
      return rxjs.merge(initial$, updates$).pipe(connectMemoryBlocks());
    }
  );
  const getBestOrFinalized = (isFinalized) => (pallet, entry, storageKey) => {
    const memoryBlocks$ = getMemoryBlocks$(pallet, entry, storageKey);
    const getPatcher = getPatcherFromRuntime(pallet, entry);
    const prop = isFinalized ? "finalized" : "best";
    return rxjs.combineLatest([
      memoryBlocks$.pipe(rxjs.delay(0)),
      blocks$.pipe(rxjs.distinctUntilChanged((a, b) => a[prop] === b[prop]))
    ]).pipe(
      rxjs.map(
        ([state2, blocks]) => findPrevious(blocks[prop], state2.blocks, blocks, true)
      ),
      rxjs.filter(Boolean),
      rxjs.distinctUntilChanged(),
      rxjs.startWith(null),
      rxjs.pairwise(),
      rxjs.withLatestFrom(memoryBlocks$),
      withRuntime(([[, _latest]]) => _latest.block.hash),
      rxjs.map(
        ([[[prevUpdate, latest], memoryBlocks], runtimeCtx]) => [
          prevUpdate,
          latest,
          memoryBlocks,
          getPatcher(runtimeCtx)
        ]
      ),
      rxjs.mergeMap(([prevUpdate, latest, memoryBlocks, patcher]) => {
        if (!prevUpdate) return [latest];
        let ancestor = latest;
        const updates = [];
        while (ancestor && ancestor.block.number > prevUpdate.block.number) {
          updates.unshift(ancestor);
          ancestor = ancestor.prev ? memoryBlocks.blocks[ancestor.prev] : null;
        }
        if (isFinalized) {
          memoryBlocks.finalized = latest.block.hash;
          if (updates.length) {
            const { blocks } = memoryBlocks;
            Object.keys(blocks).forEach((key) => {
              if (blocks[key].block.number < updates[0].block.number)
                delete blocks[key];
            });
          }
        }
        if (prevUpdate === ancestor) return updates;
        return [
          {
            ...latest,
            ...prevUpdate.rootHash === latest.rootHash ? {
              entries: prevUpdate.entries,
              deltas: null
            } : getDiff(prevUpdate.entries, latest.entries, patcher)
          }
        ];
      })
    );
  };
  const getFinalized$ = core.state(getBestOrFinalized(true));
  const getBest$ = core.state(getBestOrFinalized(false));
  return (pallet, entry, args, atBest) => {
    const fn = atBest ? getBest$ : getFinalized$;
    const storageKey$ = blocks$.pipe(
      rxjs.take(1),
      rxjs.mergeMap(
        (b) => b.runtimes[b.blocks.get(b[atBest ? "best" : "finalized"]).runtime].runtime
      ),
      rxjs.map(
        (runtime) => runtime.dynamicBuilder.buildStorage(pallet, entry).keys.enc(...args)
      )
    );
    return storageKey$.pipe(
      rxjs.take(1),
      rxjs.mergeMap((storageKey) => fn(pallet, entry, storageKey)),
      rxjs.map(({ block: { hash, number, parent }, deltas, entries }, idx) => {
        const actualDeltas = idx > 0 ? deltas : { deleted: [], upserted: entries };
        return {
          block: { hash, number, parent },
          entries: entries.map(toDec),
          deltas: actualDeltas && {
            deleted: actualDeltas.deleted.map(toDec),
            upserted: actualDeltas.upserted.map(toDec)
          }
        };
      })
    );
  };
};
const toDec = (x) => x.dec;

const createApi = (compatibilityToken, chainHead, broadcast$) => {
  const target = {};
  const createProxy = (propCall) => new Proxy(target, {
    get(_, prop) {
      return propCall(prop);
    }
  });
  const createProxyPath = (pathCall) => {
    const cache = {};
    return createProxy((a) => {
      if (!cache[a]) cache[a] = {};
      return createProxy((b) => {
        if (!cache[a][b]) cache[a][b] = pathCall(a, b);
        return cache[a][b];
      });
    });
  };
  const getPallet = (ctx, name) => ctx.lookup.metadata.pallets.find((p) => p.name === name);
  const getWatchEntries = createWatchEntries(
    chainHead.pinnedBlocks$,
    chainHead.storage$,
    chainHead.withRuntime
  );
  const query = createProxyPath(
    (pallet, name) => createStorageEntry(
      pallet,
      name,
      chainHead,
      getWatchEntries,
      compatibilityHelper(
        compatibilityToken,
        (r) => r.getPalletEntryPoint(OpType.Storage, pallet, name),
        // TODO this is way sub-optimal. Needs some rethought - maybe a builder for entry points?.
        (ctx) => {
          const item = getPallet(ctx, pallet)?.storage?.items.find(
            (s) => s.name === name
          );
          return item == null ? null : metadataCompatibility.storageEntryPoint(item);
        }
      )
    )
  );
  const getEnumEntry = (ctx, side, id, name) => {
    if (id == null) return null;
    const entry = ctx.lookup(id);
    if (entry.type !== "enum") throw new Error("Expected enum");
    if (entry.value[name] == null) return null;
    const node = metadataCompatibility.enumValueEntryPointNode(entry.value[name]);
    return {
      args: side === "args" ? node : metadataCompatibility.voidEntryPointNode,
      values: side === "args" ? metadataCompatibility.voidEntryPointNode : node
    };
  };
  const tx = createProxyPath(
    (pallet, name) => createTxEntry(
      pallet,
      name,
      chainHead,
      broadcast$,
      compatibilityHelper(
        compatibilityToken,
        (r) => r.getPalletEntryPoint(OpType.Tx, pallet, name),
        (ctx) => getEnumEntry(ctx, "args", getPallet(ctx, pallet)?.calls, name)
      ),
      true
    )
  );
  const event = createProxyPath(
    (pallet, name) => createEventEntry(
      pallet,
      name,
      chainHead,
      compatibilityHelper(
        compatibilityToken,
        (r) => r.getPalletEntryPoint(OpType.Event, pallet, name),
        (ctx) => getEnumEntry(ctx, "values", getPallet(ctx, pallet)?.events, name)
      )
    )
  );
  const constants = createProxyPath(
    (pallet, name) => createConstantEntry(
      pallet,
      name,
      compatibilityHelper(
        compatibilityToken,
        (r) => r.getPalletEntryPoint(OpType.Const, pallet, name),
        (ctx) => {
          const item = getPallet(ctx, pallet)?.constants.find(
            (c) => c.name === name
          )?.type;
          return item == null ? null : metadataCompatibility.singleValueEntryPoint(item);
        }
      )
    )
  );
  const apis = createProxyPath(
    (api, method) => createRuntimeCallEntry(
      api,
      method,
      chainHead,
      compatibilityHelper(
        compatibilityToken,
        (r) => r.getApiEntryPoint(api, method),
        (ctx) => metadataCompatibility.runtimeCallEntryPoint(
          ctx.lookup.metadata.apis.find((a) => a.name === api).methods.find((m) => m.name === method)
        )
      )
    )
  );
  const _callDataTx = (callData, token) => {
    const { lookup, dynamicBuilder } = getCompatibilityApi(token).runtime();
    try {
      const decoded = dynamicBuilder.buildDefinition(lookup.call).dec(callData.asBytes());
      const pallet = decoded.type;
      const call = decoded.value.type;
      const args = decoded.value.value;
      return createTxEntry(
        pallet,
        call,
        chainHead,
        broadcast$,
        compatibilityHelper(
          compatibilityToken,
          (r) => r.getPalletEntryPoint(OpType.Tx, pallet, call),
          (ctx) => getEnumEntry(ctx, "args", getPallet(ctx, pallet)?.calls, call)
        ),
        false
      )(args);
    } catch {
      throw new Error("createTx: invalid call data");
    }
  };
  return {
    query,
    txFromCallData: (callData, token) => token ? _callDataTx(callData, token) : compatibilityToken.then((t) => _callDataTx(callData, t)),
    tx,
    event,
    apis,
    constants
  };
};
function createClient(provider) {
  const rawClient = substrateClient.createClient(provider);
  const client = observableClient.getObservableClient(rawClient);
  const chainHead = client.chainHead$();
  const { getChainSpecData } = rawClient;
  const _request = rawClient.request;
  let runtimeToken;
  const compatibilityToken = /* @__PURE__ */ new WeakMap();
  const getChainToken = (chainDefinition) => {
    const result = compatibilityToken.get(chainDefinition) || createCompatibilityToken(chainDefinition, chainHead);
    compatibilityToken.set(chainDefinition, result);
    return result;
  };
  const getRuntimeToken = () => runtimeToken ?? (runtimeToken = createRuntimeToken(chainHead));
  const { broadcastTx$ } = client;
  return {
    getChainSpecData,
    finalizedBlock$: chainHead.finalized$,
    getFinalizedBlock: () => rxjs.firstValueFrom(chainHead.finalized$),
    bestBlocks$: chainHead.bestBlocks$,
    getBestBlocks: () => rxjs.firstValueFrom(chainHead.bestBlocks$),
    watchBlockBody: chainHead.body$,
    getBlockBody: (hash) => rxjs.firstValueFrom(chainHead.body$(hash)),
    getBlockHeader: (hash) => rxjs.firstValueFrom(chainHead.header$(hash ?? null)),
    submit: (...args) => submit(chainHead, broadcastTx$, ...args),
    submitAndWatch: (...args) => submit$(chainHead, broadcastTx$, ...args),
    getTypedApi: (chainDefinition) => {
      const token = getChainToken(chainDefinition);
      return Object.assign(
        createApi(token, chainHead, broadcastTx$),
        { compatibilityToken: token }
      );
    },
    getUnsafeApi: () => {
      const token = getRuntimeToken();
      return Object.assign(createApi(token, chainHead, broadcastTx$), {
        runtimeToken: token
      });
    },
    destroy: () => {
      chainHead.unfollow();
      client.destroy();
    },
    _request
  };
}

const createOfflineTxEntry = (pallet, name, metadataRaw, dynamicBuilder, signExtensionCreator) => {
  let codecs;
  try {
    codecs = dynamicBuilder.buildCall(pallet, name);
  } catch {
    throw new Error(`Runtime entry Tx(${pallet}.${name}) not found`);
  }
  const { location, codec } = codecs;
  const locationBytes = new Uint8Array(location);
  return (arg) => {
    const encodedData = substrateBindings.Binary.fromBytes(
      utils.mergeUint8(locationBytes, codec.enc(arg))
    );
    return {
      encodedData,
      decodedCall: substrateBindings.Enum(pallet, substrateBindings.Enum(name, arg)),
      sign: async (from, extensions) => utils.toHex(
        await from.signTx(
          encodedData.asBytes(),
          signExtensionCreator(extensions),
          metadataRaw,
          extensions.mortality.mortal ? extensions.mortality.startAtBlock.height : 0
        )
      )
    };
  };
};
const getOfflineApi = async ({
  genesis: genesisHex,
  getMetadata
}) => {
  if (!genesisHex) throw new Error("Missing genesis hash");
  const genesis = utils.fromHex(genesisHex);
  const metadataRaw = await getMetadata();
  const metadata = substrateBindings.metadata.dec(metadataRaw).metadata.value;
  const lookupFn = metadataBuilders.getLookupFn(metadata);
  const dynamicBuilder = metadataBuilders.getDynamicBuilder(lookupFn);
  const signExtensionCreator = getSignExtensionsCreator(
    genesis,
    lookupFn,
    dynamicBuilder
  );
  const getPallet = (name) => metadata.pallets.find((p) => p.name === name);
  const target = {};
  const createProxy = (propCall) => new Proxy(target, {
    get(_, prop) {
      return propCall(prop);
    }
  });
  const createProxyPath = (pathCall) => {
    const cache = {};
    return createProxy((a) => {
      if (!cache[a]) cache[a] = {};
      return createProxy((b) => {
        if (!cache[a][b]) cache[a][b] = pathCall(a, b);
        return cache[a][b];
      });
    });
  };
  const constants = createProxyPath((pallet, name) => {
    const constant = getPallet(pallet)?.constants.find((c) => c.name === name);
    if (!constant)
      throw new Error(`Runtime entry Constant(${pallet}.${name}) not found`);
    return dynamicBuilder.buildConstant(pallet, name).dec(constant.value);
  });
  const tx = createProxyPath(
    (pallet, name) => createOfflineTxEntry(
      pallet,
      name,
      metadataRaw,
      dynamicBuilder,
      signExtensionCreator
    )
  );
  return { constants, tx };
};

Object.defineProperty(exports, "CompatibilityLevel", {
  enumerable: true,
  get: function () { return metadataCompatibility.CompatibilityLevel; }
});
Object.defineProperty(exports, "AccountId", {
  enumerable: true,
  get: function () { return substrateBindings.AccountId; }
});
Object.defineProperty(exports, "Binary", {
  enumerable: true,
  get: function () { return substrateBindings.Binary; }
});
Object.defineProperty(exports, "Enum", {
  enumerable: true,
  get: function () { return substrateBindings.Enum; }
});
Object.defineProperty(exports, "FixedSizeBinary", {
  enumerable: true,
  get: function () { return substrateBindings.FixedSizeBinary; }
});
Object.defineProperty(exports, "_Enum", {
  enumerable: true,
  get: function () { return substrateBindings._Enum; }
});
Object.defineProperty(exports, "getSs58AddressInfo", {
  enumerable: true,
  get: function () { return substrateBindings.getSs58AddressInfo; }
});
exports.InvalidTxError = InvalidTxError;
exports.createClient = createClient;
exports.getOfflineApi = getOfflineApi;
//# sourceMappingURL=index.js.map
