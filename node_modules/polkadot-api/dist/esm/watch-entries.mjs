import { isBestOrFinalizedBlock, BlockNotPinnedError } from '@polkadot-api/observable-client';
import { distinctUntilChanged, take, map, withLatestFrom, merge, mergeMap, combineLatest, delay, filter, startWith, pairwise, EMPTY, of, takeUntil, catchError, throwError } from 'rxjs';
import './utils/shareLatest.mjs';
import '@polkadot-api/utils';
import { lossLessExhaustMap } from './utils/lossLessExhaustMap.mjs';
import { selfDependent } from './utils/self-dependent.mjs';
import { state } from '@rx-state/core';

const getDiff = (_prev, _current, patch) => {
  const current = new Map(_current.map((x) => [x.key, x]));
  const prev = new Map(_prev.map((x) => [x.key, x]));
  const upserted = /* @__PURE__ */ new Map();
  const deleted = [];
  _current.forEach((value) => {
    const { key } = value;
    const prevVal = prev.get(key);
    if (!prevVal || prevVal.value !== value.value)
      upserted.set(key, patch(value));
  });
  _prev.forEach((x) => {
    if (!current.has(x.key)) deleted.push(x);
  });
  return {
    deltas: {
      deleted,
      upserted: [...upserted.values()]
    },
    entries: _current.map(({ key }) => upserted.get(key) ?? prev.get(key))
  };
};
const findPrevious = (start, state2, pinned, includeStart = false) => {
  try {
    let target = includeStart ? start : pinned.blocks.get(start).parent;
    while (target && !state2[target]) target = pinned.blocks.get(target).parent;
    if (!target) return null;
    return state2[target];
  } catch {
    return null;
  }
};
const getPatcherFromRuntime = (pallet, entry) => (runtime) => {
  const { keys, value } = runtime.dynamicBuilder.buildStorage(pallet, entry);
  return (x) => {
    x.dec = {
      value: value.dec(x.value),
      args: keys.dec(x.key)
    };
    return x;
  };
};
const createWatchEntries = (blocks$, storage, withRuntime) => {
  const getMemoryBlocks$ = state(
    (pallet, entry, storageKey) => {
      const getPatcher = getPatcherFromRuntime(pallet, entry);
      const getNextMemoryBlock$ = (prev, block) => {
        const isNotCanonical$ = isBestOrFinalizedBlock(
          blocks$,
          block.hash
        ).pipe(
          filter((x) => !x),
          take(1)
        );
        return storage(
          block.hash,
          "closestDescendantMerkleValue",
          () => storageKey
        ).pipe(
          mergeMap((rootHash) => {
            if (rootHash === prev?.rootHash)
              return of({
                ...prev,
                block,
                deltas: null,
                prev: prev.block.hash
              });
            return storage(
              block.hash,
              "descendantsValues",
              () => storageKey
            ).pipe(
              withRuntime(() => block.hash),
              map(
                ([entries, runtimeCtx]) => [entries, getPatcher(runtimeCtx)]
              ),
              map(
                ([entries, patcher]) => ({
                  prev: prev && prev.block.hash,
                  rootHash,
                  block,
                  ...getDiff(
                    prev?.entries ?? [],
                    entries,
                    patcher
                  )
                })
              )
            );
          }),
          takeUntil(isNotCanonical$),
          catchError(
            (e) => e instanceof BlockNotPinnedError ? EMPTY : throwError(() => e)
          )
        );
      };
      const initial$ = blocks$.pipe(
        distinctUntilChanged((a, b) => a.finalized === b.finalized),
        lossLessExhaustMap(
          ({ blocks, finalized }) => getNextMemoryBlock$(null, blocks.get(finalized))
        ),
        take(1),
        map(
          (x) => ({
            blocks: { [x.block.hash]: x },
            finalized: x.block.hash
          })
        )
      );
      const [_memoryBlocks$, connectMemoryBlocks] = selfDependent();
      const updates$ = blocks$.pipe(
        distinctUntilChanged((a, b) => a.best === b.best),
        withLatestFrom(_memoryBlocks$),
        lossLessExhaustMap(([pinned, memoryBlocks]) => {
          const { best } = pinned;
          const { blocks } = memoryBlocks;
          let target = !blocks[best] ? best : null;
          if (!target) return EMPTY;
          const previous = findPrevious(target, blocks, pinned);
          if (previous)
            return getNextMemoryBlock$(
              previous,
              pinned.blocks.get(target)
            ).pipe(
              map((x) => {
                blocks[target] = x;
                return memoryBlocks;
              })
            );
          target = pinned.finalized;
          return getNextMemoryBlock$(
            blocks[memoryBlocks.finalized],
            pinned.blocks.get(target)
          ).pipe(
            map((x) => {
              x.prev = null;
              return {
                blocks: { [target]: x },
                finalized: target
              };
            })
          );
        })
      );
      return merge(initial$, updates$).pipe(connectMemoryBlocks());
    }
  );
  const getBestOrFinalized = (isFinalized) => (pallet, entry, storageKey) => {
    const memoryBlocks$ = getMemoryBlocks$(pallet, entry, storageKey);
    const getPatcher = getPatcherFromRuntime(pallet, entry);
    const prop = isFinalized ? "finalized" : "best";
    return combineLatest([
      memoryBlocks$.pipe(delay(0)),
      blocks$.pipe(distinctUntilChanged((a, b) => a[prop] === b[prop]))
    ]).pipe(
      map(
        ([state2, blocks]) => findPrevious(blocks[prop], state2.blocks, blocks, true)
      ),
      filter(Boolean),
      distinctUntilChanged(),
      startWith(null),
      pairwise(),
      withLatestFrom(memoryBlocks$),
      withRuntime(([[, _latest]]) => _latest.block.hash),
      map(
        ([[[prevUpdate, latest], memoryBlocks], runtimeCtx]) => [
          prevUpdate,
          latest,
          memoryBlocks,
          getPatcher(runtimeCtx)
        ]
      ),
      mergeMap(([prevUpdate, latest, memoryBlocks, patcher]) => {
        if (!prevUpdate) return [latest];
        let ancestor = latest;
        const updates = [];
        while (ancestor && ancestor.block.number > prevUpdate.block.number) {
          updates.unshift(ancestor);
          ancestor = ancestor.prev ? memoryBlocks.blocks[ancestor.prev] : null;
        }
        if (isFinalized) {
          memoryBlocks.finalized = latest.block.hash;
          if (updates.length) {
            const { blocks } = memoryBlocks;
            Object.keys(blocks).forEach((key) => {
              if (blocks[key].block.number < updates[0].block.number)
                delete blocks[key];
            });
          }
        }
        if (prevUpdate === ancestor) return updates;
        return [
          {
            ...latest,
            ...prevUpdate.rootHash === latest.rootHash ? {
              entries: prevUpdate.entries,
              deltas: null
            } : getDiff(prevUpdate.entries, latest.entries, patcher)
          }
        ];
      })
    );
  };
  const getFinalized$ = state(getBestOrFinalized(true));
  const getBest$ = state(getBestOrFinalized(false));
  return (pallet, entry, args, atBest) => {
    const fn = atBest ? getBest$ : getFinalized$;
    const storageKey$ = blocks$.pipe(
      take(1),
      mergeMap(
        (b) => b.runtimes[b.blocks.get(b[atBest ? "best" : "finalized"]).runtime].runtime
      ),
      map(
        (runtime) => runtime.dynamicBuilder.buildStorage(pallet, entry).keys.enc(...args)
      )
    );
    return storageKey$.pipe(
      take(1),
      mergeMap((storageKey) => fn(pallet, entry, storageKey)),
      map(({ block: { hash, number, parent }, deltas, entries }, idx) => {
        const actualDeltas = idx > 0 ? deltas : { deleted: [], upserted: entries };
        return {
          block: { hash, number, parent },
          entries: entries.map(toDec),
          deltas: actualDeltas && {
            deleted: actualDeltas.deleted.map(toDec),
            upserted: actualDeltas.upserted.map(toDec)
          }
        };
      })
    );
  };
};
const toDec = (x) => x.dec;

export { createWatchEntries };
//# sourceMappingURL=watch-entries.mjs.map
