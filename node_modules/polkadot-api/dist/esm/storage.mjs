import { NotBestBlockError } from '@polkadot-api/observable-client';
import './utils/shareLatest.mjs';
import { map, filter, take, identity, shareReplay, pipe, combineLatestWith, distinctUntilChanged, from, mergeMap } from 'rxjs';
import { firstValueFromWithSignal } from './utils/firstValueFromWithSignal.mjs';
import { lossLessExhaustMap } from './utils/lossLessExhaustMap.mjs';
import { isOptionalArg } from './utils/optional-arg.mjs';
import 'rxjs/operators';
import { CompatibilityLevel } from '@polkadot-api/metadata-compatibility';
import { FixedSizeBinary } from '@polkadot-api/substrate-bindings';
import { minCompatLevel } from './compatibility.mjs';

const toMapped = map((x) => x.mapped);
const createStorageEntry = (pallet, name, chainHead, getWatchEntries, {
  isCompatible,
  getCompatibilityLevel,
  getCompatibilityLevels,
  descriptors: descriptorsPromise,
  argsAreCompatible,
  valuesAreCompatible
}) => {
  const isSystemNumber = pallet === "System" && name === "Number";
  const isBlockHash = pallet === "System" && name === "BlockHash";
  const sysNumberMapper$ = chainHead.runtime$.pipe(
    filter(Boolean),
    take(1),
    map(
      ({ dynamicBuilder }) => typeof dynamicBuilder.buildStorage("System", "Number").value.dec(new Uint8Array(32)) === "bigint" ? BigInt : identity
    ),
    shareReplay()
  );
  const bigIntOrNumber = pipe(
    combineLatestWith(sysNumberMapper$),
    map(([input, mapper]) => mapper(input))
  );
  const incompatibleError = () => new Error(`Incompatible runtime entry Storage(${pallet}.${name})`);
  const invalidArgs = (args) => new Error(`Invalid Arguments calling ${pallet}.${name}(${args})`);
  const getCodec = (ctx) => {
    try {
      return ctx.dynamicBuilder.buildStorage(pallet, name);
    } catch (e) {
      throw new Error(`Runtime entry Storage(${pallet}.${name}) not found`);
    }
  };
  const watchValue = (...args) => {
    const target = args[args.length - 1];
    const isBest = target === "best";
    const actualArgs = isBest || target === "finalized" ? args.slice(0, -1) : args;
    return chainHead[isBest ? "best$" : "finalized$"].pipe(
      lossLessExhaustMap(
        () => getRawValue$(...actualArgs, isBest ? { at: "best" } : {})
      ),
      distinctUntilChanged((a, b) => a.raw === b.raw),
      toMapped
    );
  };
  const getRawValue$ = (...args) => {
    const lastArg = args[args.length - 1];
    const isLastArgOptional = isOptionalArg(lastArg);
    const { at: _at } = isLastArgOptional ? lastArg : {};
    const at = _at ?? null;
    if (isSystemNumber)
      return chainHead.bestBlocks$.pipe(
        map((blocks) => {
          if (at === "finalized" || !at) return blocks.at(-1);
          if (at === "best") return blocks.at(0);
          return blocks.find((block) => block.hash === at);
        }),
        map((block) => {
          if (!block) throw new NotBestBlockError();
          return block.number;
        }),
        distinctUntilChanged(),
        bigIntOrNumber,
        map((mapped) => ({ raw: mapped, mapped }))
      );
    if (isBlockHash && Number(args[0]) === 0) {
      return chainHead.genesis$.pipe(
        map((raw) => ({ raw, mapped: FixedSizeBinary.fromHex(raw) }))
      );
    }
    return from(descriptorsPromise).pipe(
      mergeMap(
        (descriptors) => chainHead.storage$(
          at,
          "value",
          (ctx) => {
            const codecs = getCodec(ctx);
            const actualArgs = args.length === codecs.len ? args : args.slice(0, -1);
            if (args !== actualArgs && !isLastArgOptional)
              throw invalidArgs(args);
            if (!argsAreCompatible(descriptors, ctx, actualArgs))
              throw incompatibleError();
            return codecs.keys.enc(...actualArgs);
          },
          null,
          (data, ctx) => {
            const codecs = getCodec(ctx);
            const value = data === null ? codecs.fallback : codecs.value.dec(data);
            if (!valuesAreCompatible(descriptors, ctx, value))
              throw incompatibleError();
            return value;
          }
        )
      )
    );
  };
  const getValue = async (...args) => {
    const lastArg = args[args.length - 1];
    const isLastArgOptional = isOptionalArg(lastArg);
    const { signal } = isLastArgOptional ? lastArg : {};
    return firstValueFromWithSignal(
      getRawValue$(...args).pipe(toMapped),
      signal
    );
  };
  const getEntries = async (...args) => {
    const lastArg = args[args.length - 1];
    const isLastArgOptional = isOptionalArg(lastArg);
    const { signal, at: _at } = isLastArgOptional ? lastArg : {};
    const at = _at ?? null;
    const descriptors = await descriptorsPromise;
    const result$ = chainHead.storage$(
      at,
      "descendantsValues",
      (ctx) => {
        const codecs = getCodec(ctx);
        if (minCompatLevel(getCompatibilityLevels(descriptors, ctx)) === CompatibilityLevel.Incompatible)
          throw incompatibleError();
        if (args.length > codecs.len) throw invalidArgs(args);
        const actualArgs = args.length > 0 && isLastArgOptional ? args.slice(0, -1) : args;
        if (args.length === codecs.len && actualArgs === args)
          throw invalidArgs(args);
        return codecs.keys.enc(...actualArgs);
      },
      null,
      (values, ctx) => {
        const codecs = getCodec(ctx);
        const decodedValues = values.map(({ key, value }) => ({
          keyArgs: codecs.keys.dec(key),
          value: codecs.value.dec(value)
        }));
        if (decodedValues.some(
          ({ value }) => !valuesAreCompatible(descriptors, ctx, value)
        ))
          throw incompatibleError();
        return decodedValues;
      }
    ).pipe(toMapped);
    return firstValueFromWithSignal(result$, signal);
  };
  const getValues = (keyArgs, options) => Promise.all(
    keyArgs.map((args) => getValue(...options ? [...args, options] : args))
  );
  const watchEntries = (...args) => {
    const lastArg = args.at(-1);
    const isLastArgOptional = isOptionalArg(lastArg);
    return getWatchEntries(
      pallet,
      name,
      isLastArgOptional ? args.slice(0, -1) : args,
      isLastArgOptional && lastArg.at === "best"
    );
  };
  return {
    isCompatible,
    getCompatibilityLevel,
    getValue,
    getValues,
    getEntries,
    watchValue,
    watchEntries
  };
};

export { createStorageEntry };
//# sourceMappingURL=storage.mjs.map
