import { getCompatibilityApi } from './compatibility.mjs';

const createConstantEntry = (palletName, name, {
  valuesAreCompatible,
  descriptors,
  isCompatible,
  getCompatibilityLevel
}) => {
  const cachedResults = /* @__PURE__ */ new WeakMap();
  const getValueWithContext = (ctx) => {
    if (cachedResults.has(ctx)) {
      return cachedResults.get(ctx);
    }
    const pallet = ctx.lookup.metadata.pallets.find(
      (p) => p.name === palletName
    );
    const constant = pallet?.constants.find((c) => c.name === name);
    if (constant == null)
      throw new Error(`Runtime entry Constant(${palletName}.${name}) not found`);
    const result = ctx.dynamicBuilder.buildConstant(palletName, name).dec(constant.value);
    cachedResults.set(ctx, result);
    return result;
  };
  const fn = (token) => {
    if (token) {
      const ctx = getCompatibilityApi(token).runtime();
      const value = getValueWithContext(ctx);
      if (!valuesAreCompatible(token, ctx, value))
        throw new Error(
          `Incompatible runtime entry Constant(${palletName}.${name})`
        );
      return value;
    }
    return descriptors.then(fn);
  };
  return Object.assign(fn, { isCompatible, getCompatibilityLevel });
};

export { createConstantEntry };
//# sourceMappingURL=constants.mjs.map
