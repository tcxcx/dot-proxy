{"version":3,"file":"storage.mjs","sources":["../../src/storage.ts"],"sourcesContent":["import {\n  firstValueFromWithSignal,\n  isOptionalArg,\n  lossLessExhaustMap,\n} from \"@/utils\"\nimport { CompatibilityLevel } from \"@polkadot-api/metadata-compatibility\"\nimport {\n  BlockInfo,\n  ChainHead$,\n  NotBestBlockError,\n  RuntimeContext,\n} from \"@polkadot-api/observable-client\"\nimport { FixedSizeBinary } from \"@polkadot-api/substrate-bindings\"\nimport { StorageItemInput, StorageResult } from \"@polkadot-api/substrate-client\"\nimport {\n  Observable,\n  OperatorFunction,\n  combineLatestWith,\n  distinctUntilChanged,\n  filter,\n  from,\n  identity,\n  map,\n  mergeMap,\n  pipe,\n  shareReplay,\n  take,\n} from \"rxjs\"\nimport {\n  CompatibilityFunctions,\n  CompatibilityHelper,\n  minCompatLevel,\n} from \"./compatibility\"\nimport { createWatchEntries } from \"./watch-entries\"\n\ntype CallOptions = Partial<{\n  /**\n   * `at` could be a blockHash, `best`, or `finalized` (default)\n   */\n  at: string\n  /**\n   * `signal` allows you to abort an ongoing Promise. See [MDN\n   * docs](https://developer.mozilla.org/en-US/docs/Web/API/AbortSignal) for\n   * more information\n   */\n  signal: AbortSignal\n}>\n\ntype WithCallOptions<Args extends Array<any>> = [\n  ...args: Args,\n  options?: CallOptions,\n]\n\ntype WithWatchOptions<Args extends Array<any>> = [\n  ...args: Args,\n  options?: { at: \"best\" },\n]\n\ntype PossibleParents<A extends Array<any>> = A extends [...infer Left, any]\n  ? Left | PossibleParents<Left>\n  : ArrayPossibleParents<A>\n\n// Fixed-size arrays values can't be extracted one-by-one, so that's a specific case\ntype ArrayPossibleParents<\n  A extends Array<any>,\n  Count extends Array<any> = [],\n  R = [],\n> = A extends Array<infer T> & { length: infer L }\n  ? number extends L\n    ? Array<T> // Case variable-size array it's an unknown amount of entries\n    : L extends Count[\"length\"]\n      ? R\n      : ArrayPossibleParents<A, [...Count, T], R | Count>\n  : never\n\ntype StorageEntryWithoutKeys<Unsafe, D, Payload> = {\n  /**\n   * Get `Payload` (Promise-based) for the storage entry.\n   *\n   * @param options  Optionally set which block to target (latest known\n   *                 finalized is the default) and an AbortSignal.\n   */\n  getValue: (options?: CallOptions) => Promise<Payload>\n  /**\n   * Watch changes in `Payload` (observable-based) for the storage entry.\n   *\n   * @param bestOrFinalized  Optionally choose which block to query and watch\n   *                         changes, `best` or `finalized` (default)\n   */\n  watchValue: (bestOrFinalized?: \"best\" | \"finalized\") => Observable<Payload>\n} & (Unsafe extends true ? {} : CompatibilityFunctions<D>)\n\nexport type StorageEntryWithKeys<\n  Unsafe,\n  D,\n  Args extends Array<any>,\n  Payload,\n  ArgsOut extends Array<any>,\n> = {\n  /**\n   * Get `Payload` (Promise-based) for the storage entry with a specific set of\n   * `Args`.\n   *\n   * @param args  All keys needed for that storage entry.\n   *              At the end, optionally set which block to target (latest\n   *              known finalized is the default) and an AbortSignal.\n   */\n  getValue: (...args: [...WithCallOptions<Args>]) => Promise<Payload>\n  /**\n   * Watch changes in `Payload` (observable-based) for the storage entry.\n   *\n   * @param args  All keys needed for that storage entry.\n   *              At the end, optionally choose which block to query and\n   *              watch changes, `best` or `finalized` (default)\n   */\n  watchValue: (\n    ...args: [...Args, bestOrFinalized?: \"best\" | \"finalized\"]\n  ) => Observable<Payload>\n  /**\n   * Get an Array of `Payload` (Promise-based) for the storage entry with\n   * several sets of `Args`.\n   *\n   * @param keys     Array of sets of keys needed for the storage entry.\n   * @param options  Optionally set which block to target (latest known\n   *                 finalized is the default) and an AbortSignal.\n   */\n  getValues: (\n    keys: Array<[...Args]>,\n    options?: CallOptions,\n  ) => Promise<Array<Payload>>\n  /**\n   * Get an Array of `Payload` (Promise-based) for the storage entry with a\n   * subset of `Args`.\n   *\n   * @param args  Subset of keys needed for the storage entry.\n   *              At the end, optionally set which block to target (latest\n   *              known finalized is the default) and an AbortSignal.\n   * @example\n   *\n   *   // this is a query with 3 keys\n   *   typedApi.query.Pallet.Query.getEntries({ at: \"best\" }) // no keys\n   *   typedApi.query.Pallet.Query.getEntries(arg1, { at: \"finalized\" }) // 1/3 keys\n   *   typedApi.query.Pallet.Query.getEntries(arg1, arg2, { at: \"0x12345678\" }) // 2/3 keys\n   *\n   */\n  getEntries: (\n    ...args: WithCallOptions<PossibleParents<Args>>\n  ) => Promise<Array<{ keyArgs: ArgsOut; value: NonNullable<Payload> }>>\n  /**\n   * Watch changes (Observable-based) for the storage entries with a subset of\n   * `Args`.\n   *\n   * @param args  Subset of keys needed for the storage entry.\n   *              At the end, optionally set whether to watch against the\n   *              `best` block.\n   *              By default watches changes against the finalized block.\n   *              When watching changes against the \"best\" block, this API\n   *              gratiously handles the re-orgs and provides the deltas\n   *              based on the latest emission.\n   *              The observed value contains the following properties:\n   *              - `block`: the block in where the `deltas` took place -\n   *              `deltas`: `null` indicates that nothing has changed from\n   *              the latest emission.\n   *              If the value is not `null` then the `deleted` and `upsrted`\n   *              properties indicate the entries that have changed.\n   *              - `entries`: it's an immutable data-structure with the\n   *              latest entries.\n   * @example\n   *\n   *   typedApi.query.Staking.Nominators.watchEntries()\n   *   typedApi.query.Staking.Nominators.watchEntries({ at: \"best\" })\n   *\n   */\n  watchEntries: (\n    ...args: WithWatchOptions<PossibleParents<Args>>\n  ) => Observable<{\n    block: BlockInfo\n    deltas: null | {\n      deleted: Array<{ args: ArgsOut; value: NonNullable<Payload> }>\n      upserted: Array<{ args: ArgsOut; value: NonNullable<Payload> }>\n    }\n    entries: Array<{ args: ArgsOut; value: NonNullable<Payload> }>\n  }>\n} & (Unsafe extends true ? {} : CompatibilityFunctions<D>)\n\nexport type StorageEntry<\n  Unsafe,\n  D,\n  Args extends Array<any>,\n  ArgsOut extends Array<any>,\n  Payload,\n> = Args extends []\n  ? StorageEntryWithoutKeys<Unsafe, D, Payload>\n  : StorageEntryWithKeys<Unsafe, D, Args, Payload, ArgsOut>\n\nexport type Storage$ = <Type extends StorageItemInput[\"type\"]>(\n  hash: string | null,\n  type: Type,\n  key: string,\n  childTrie: string | null,\n) => Observable<StorageResult<Type>>\n\nconst toMapped = map(<T>(x: { mapped: T }) => x.mapped)\nexport const createStorageEntry = (\n  pallet: string,\n  name: string,\n  chainHead: ChainHead$,\n  getWatchEntries: ReturnType<typeof createWatchEntries>,\n  {\n    isCompatible,\n    getCompatibilityLevel,\n    getCompatibilityLevels,\n    descriptors: descriptorsPromise,\n    argsAreCompatible,\n    valuesAreCompatible,\n  }: CompatibilityHelper,\n): StorageEntry<any, any, any, any, any> => {\n  const isSystemNumber = pallet === \"System\" && name === \"Number\"\n  const isBlockHash = pallet === \"System\" && name === \"BlockHash\"\n  const sysNumberMapper$ = chainHead.runtime$.pipe(\n    filter(Boolean),\n    take(1),\n    map(({ dynamicBuilder }) =>\n      typeof dynamicBuilder\n        .buildStorage(\"System\", \"Number\")\n        .value.dec(new Uint8Array(32)) === \"bigint\"\n        ? BigInt\n        : identity,\n    ),\n    shareReplay(),\n  )\n  const bigIntOrNumber: OperatorFunction<number, number | bigint> = pipe(\n    combineLatestWith(sysNumberMapper$),\n    map(([input, mapper]) => mapper(input)),\n  )\n\n  const incompatibleError = () =>\n    new Error(`Incompatible runtime entry Storage(${pallet}.${name})`)\n  const invalidArgs = (args: Array<any>) =>\n    new Error(`Invalid Arguments calling ${pallet}.${name}(${args})`)\n\n  const getCodec = (ctx: RuntimeContext) => {\n    try {\n      return ctx.dynamicBuilder.buildStorage(pallet, name)\n    } catch (e: any) {\n      throw new Error(`Runtime entry Storage(${pallet}.${name}) not found`)\n    }\n  }\n\n  const watchValue = (...args: Array<any>) => {\n    const target = args[args.length - 1]\n    const isBest = target === \"best\"\n    const actualArgs =\n      isBest || target === \"finalized\" ? args.slice(0, -1) : args\n\n    return chainHead[isBest ? \"best$\" : \"finalized$\"].pipe(\n      lossLessExhaustMap(() =>\n        getRawValue$(...actualArgs, isBest ? { at: \"best\" } : {}),\n      ),\n      distinctUntilChanged((a, b) => a.raw === b.raw),\n      toMapped,\n    )\n  }\n\n  const getRawValue$ = (...args: Array<any>) => {\n    const lastArg = args[args.length - 1]\n    const isLastArgOptional = isOptionalArg(lastArg)\n    const { at: _at }: CallOptions = isLastArgOptional ? lastArg : {}\n    const at = _at ?? null\n\n    if (isSystemNumber)\n      return chainHead.bestBlocks$.pipe(\n        map((blocks) => {\n          if (at === \"finalized\" || !at) return blocks.at(-1)\n          if (at === \"best\") return blocks.at(0)\n          return blocks.find((block) => block.hash === at)\n        }),\n        map((block) => {\n          if (!block) throw new NotBestBlockError()\n          return block.number\n        }),\n        distinctUntilChanged(),\n        bigIntOrNumber,\n        map((mapped) => ({ raw: mapped, mapped })),\n      )\n\n    if (isBlockHash && Number(args[0]) === 0) {\n      return chainHead.genesis$.pipe(\n        map((raw) => ({ raw, mapped: FixedSizeBinary.fromHex(raw) })),\n      ) as Observable<any>\n    }\n\n    return from(descriptorsPromise).pipe(\n      mergeMap((descriptors) =>\n        chainHead.storage$(\n          at,\n          \"value\",\n          (ctx) => {\n            const codecs = getCodec(ctx)\n            const actualArgs =\n              args.length === codecs.len ? args : args.slice(0, -1)\n            if (args !== actualArgs && !isLastArgOptional)\n              throw invalidArgs(args)\n            if (!argsAreCompatible(descriptors, ctx, actualArgs))\n              throw incompatibleError()\n            return codecs.keys.enc(...actualArgs)\n          },\n          null,\n          (data, ctx) => {\n            const codecs = getCodec(ctx)\n            const value =\n              data === null ? codecs.fallback : codecs.value.dec(data)\n            if (!valuesAreCompatible(descriptors, ctx, value))\n              throw incompatibleError()\n            return value\n          },\n        ),\n      ),\n    )\n  }\n\n  const getValue = async (...args: Array<any>) => {\n    const lastArg = args[args.length - 1]\n    const isLastArgOptional = isOptionalArg(lastArg)\n    const { signal }: CallOptions = isLastArgOptional ? lastArg : {}\n\n    return firstValueFromWithSignal(\n      getRawValue$(...args).pipe(toMapped),\n      signal,\n    )\n  }\n\n  const getEntries = async (...args: Array<any>) => {\n    const lastArg = args[args.length - 1]\n    const isLastArgOptional = isOptionalArg(lastArg)\n    const { signal, at: _at }: CallOptions = isLastArgOptional ? lastArg : {}\n    const at = _at ?? null\n\n    const descriptors = await descriptorsPromise\n    const result$ = chainHead\n      .storage$(\n        at,\n        \"descendantsValues\",\n        (ctx) => {\n          const codecs = getCodec(ctx)\n          // TODO partial compatibility check for args that become optional\n          if (\n            minCompatLevel(getCompatibilityLevels(descriptors, ctx)) ===\n            CompatibilityLevel.Incompatible\n          )\n            throw incompatibleError()\n\n          if (args.length > codecs.len) throw invalidArgs(args)\n          const actualArgs =\n            args.length > 0 && isLastArgOptional ? args.slice(0, -1) : args\n          if (args.length === codecs.len && actualArgs === args)\n            throw invalidArgs(args)\n          return codecs.keys.enc(...actualArgs)\n        },\n        null,\n        (values, ctx) => {\n          const codecs = getCodec(ctx)\n          const decodedValues = values.map(({ key, value }) => ({\n            keyArgs: codecs.keys.dec(key),\n            value: codecs.value.dec(value),\n          }))\n          if (\n            decodedValues.some(\n              ({ value }) => !valuesAreCompatible(descriptors, ctx, value),\n            )\n          )\n            throw incompatibleError()\n          return decodedValues\n        },\n      )\n      .pipe(toMapped)\n    return firstValueFromWithSignal(result$, signal)\n  }\n\n  const getValues = (keyArgs: Array<Array<any>>, options?: CallOptions) =>\n    Promise.all(\n      keyArgs.map((args) => getValue(...(options ? [...args, options] : args))),\n    )\n\n  const watchEntries: any = (...args: Array<any>) => {\n    const lastArg = args.at(-1)\n    const isLastArgOptional = isOptionalArg(lastArg)\n\n    return getWatchEntries(\n      pallet,\n      name,\n      isLastArgOptional ? args.slice(0, -1) : args,\n      isLastArgOptional && lastArg.at === \"best\",\n    )\n  }\n\n  return {\n    isCompatible,\n    getCompatibilityLevel,\n    getValue,\n    getValues,\n    getEntries,\n    watchValue,\n    watchEntries,\n  }\n}\n"],"names":[],"mappings":"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"}