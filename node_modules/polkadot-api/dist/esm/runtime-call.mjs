import '@polkadot-api/observable-client';
import './utils/shareLatest.mjs';
import { mergeMap, map } from 'rxjs';
import { firstValueFromWithSignal } from './utils/firstValueFromWithSignal.mjs';
import { isOptionalArg } from './utils/optional-arg.mjs';
import 'rxjs/operators';
import { toHex } from '@polkadot-api/utils';

const createRuntimeCallEntry = (api, method, chainHead, {
  isCompatible,
  getCompatibilityLevel,
  compatibleRuntime$,
  argsAreCompatible,
  valuesAreCompatible
}) => {
  const callName = `${api}_${method}`;
  const compatibilityError = () => new Error(`Incompatible runtime entry RuntimeCall(${callName})`);
  const fn = (...args) => {
    const lastArg = args[args.length - 1];
    const isLastArgOptional = isOptionalArg(lastArg);
    const { signal, at: _at } = isLastArgOptional ? lastArg : {};
    const at = _at ?? null;
    const result$ = compatibleRuntime$(chainHead, at).pipe(
      mergeMap(([runtime, ctx]) => {
        let codecs;
        try {
          codecs = ctx.dynamicBuilder.buildRuntimeCall(api, method);
        } catch {
          throw new Error(`Runtime entry RuntimeCall(${callName}) not found`);
        }
        if (!argsAreCompatible(runtime, ctx, args)) throw compatibilityError();
        return chainHead.call$(at, callName, toHex(codecs.args.enc(args))).pipe(
          map(codecs.value.dec),
          map((value) => {
            if (!valuesAreCompatible(runtime, ctx, value))
              throw compatibilityError();
            return value;
          })
        );
      })
    );
    return firstValueFromWithSignal(result$, signal);
  };
  return Object.assign(fn, { getCompatibilityLevel, isCompatible });
};

export { createRuntimeCallEntry };
//# sourceMappingURL=runtime-call.mjs.map
