import { enumValueEntryPointNode, voidEntryPointNode, storageEntryPoint, singleValueEntryPoint, runtimeCallEntryPoint } from '@polkadot-api/metadata-compatibility';
import { getObservableClient } from '@polkadot-api/observable-client';
import { createClient as createClient$1 } from '@polkadot-api/substrate-client';
import { firstValueFrom } from 'rxjs';
import { createRuntimeToken, createCompatibilityToken, getCompatibilityApi, compatibilityHelper, OpType } from './compatibility.mjs';
import { createConstantEntry } from './constants.mjs';
import { createEventEntry } from './event.mjs';
import { createRuntimeCallEntry } from './runtime-call.mjs';
import { createStorageEntry } from './storage.mjs';
import { createTxEntry } from './tx/tx.mjs';
import { createWatchEntries } from './watch-entries.mjs';
import { submit$, submit } from './tx/submit-fns.mjs';

const createApi = (compatibilityToken, chainHead, broadcast$) => {
  const target = {};
  const createProxy = (propCall) => new Proxy(target, {
    get(_, prop) {
      return propCall(prop);
    }
  });
  const createProxyPath = (pathCall) => {
    const cache = {};
    return createProxy((a) => {
      if (!cache[a]) cache[a] = {};
      return createProxy((b) => {
        if (!cache[a][b]) cache[a][b] = pathCall(a, b);
        return cache[a][b];
      });
    });
  };
  const getPallet = (ctx, name) => ctx.lookup.metadata.pallets.find((p) => p.name === name);
  const getWatchEntries = createWatchEntries(
    chainHead.pinnedBlocks$,
    chainHead.storage$,
    chainHead.withRuntime
  );
  const query = createProxyPath(
    (pallet, name) => createStorageEntry(
      pallet,
      name,
      chainHead,
      getWatchEntries,
      compatibilityHelper(
        compatibilityToken,
        (r) => r.getPalletEntryPoint(OpType.Storage, pallet, name),
        // TODO this is way sub-optimal. Needs some rethought - maybe a builder for entry points?.
        (ctx) => {
          const item = getPallet(ctx, pallet)?.storage?.items.find(
            (s) => s.name === name
          );
          return item == null ? null : storageEntryPoint(item);
        }
      )
    )
  );
  const getEnumEntry = (ctx, side, id, name) => {
    if (id == null) return null;
    const entry = ctx.lookup(id);
    if (entry.type !== "enum") throw new Error("Expected enum");
    if (entry.value[name] == null) return null;
    const node = enumValueEntryPointNode(entry.value[name]);
    return {
      args: side === "args" ? node : voidEntryPointNode,
      values: side === "args" ? voidEntryPointNode : node
    };
  };
  const tx = createProxyPath(
    (pallet, name) => createTxEntry(
      pallet,
      name,
      chainHead,
      broadcast$,
      compatibilityHelper(
        compatibilityToken,
        (r) => r.getPalletEntryPoint(OpType.Tx, pallet, name),
        (ctx) => getEnumEntry(ctx, "args", getPallet(ctx, pallet)?.calls, name)
      ),
      true
    )
  );
  const event = createProxyPath(
    (pallet, name) => createEventEntry(
      pallet,
      name,
      chainHead,
      compatibilityHelper(
        compatibilityToken,
        (r) => r.getPalletEntryPoint(OpType.Event, pallet, name),
        (ctx) => getEnumEntry(ctx, "values", getPallet(ctx, pallet)?.events, name)
      )
    )
  );
  const constants = createProxyPath(
    (pallet, name) => createConstantEntry(
      pallet,
      name,
      compatibilityHelper(
        compatibilityToken,
        (r) => r.getPalletEntryPoint(OpType.Const, pallet, name),
        (ctx) => {
          const item = getPallet(ctx, pallet)?.constants.find(
            (c) => c.name === name
          )?.type;
          return item == null ? null : singleValueEntryPoint(item);
        }
      )
    )
  );
  const apis = createProxyPath(
    (api, method) => createRuntimeCallEntry(
      api,
      method,
      chainHead,
      compatibilityHelper(
        compatibilityToken,
        (r) => r.getApiEntryPoint(api, method),
        (ctx) => runtimeCallEntryPoint(
          ctx.lookup.metadata.apis.find((a) => a.name === api).methods.find((m) => m.name === method)
        )
      )
    )
  );
  const _callDataTx = (callData, token) => {
    const { lookup, dynamicBuilder } = getCompatibilityApi(token).runtime();
    try {
      const decoded = dynamicBuilder.buildDefinition(lookup.call).dec(callData.asBytes());
      const pallet = decoded.type;
      const call = decoded.value.type;
      const args = decoded.value.value;
      return createTxEntry(
        pallet,
        call,
        chainHead,
        broadcast$,
        compatibilityHelper(
          compatibilityToken,
          (r) => r.getPalletEntryPoint(OpType.Tx, pallet, call),
          (ctx) => getEnumEntry(ctx, "args", getPallet(ctx, pallet)?.calls, call)
        ),
        false
      )(args);
    } catch {
      throw new Error("createTx: invalid call data");
    }
  };
  return {
    query,
    txFromCallData: (callData, token) => token ? _callDataTx(callData, token) : compatibilityToken.then((t) => _callDataTx(callData, t)),
    tx,
    event,
    apis,
    constants
  };
};
function createClient(provider) {
  const rawClient = createClient$1(provider);
  const client = getObservableClient(rawClient);
  const chainHead = client.chainHead$();
  const { getChainSpecData } = rawClient;
  const _request = rawClient.request;
  let runtimeToken;
  const compatibilityToken = /* @__PURE__ */ new WeakMap();
  const getChainToken = (chainDefinition) => {
    const result = compatibilityToken.get(chainDefinition) || createCompatibilityToken(chainDefinition, chainHead);
    compatibilityToken.set(chainDefinition, result);
    return result;
  };
  const getRuntimeToken = () => runtimeToken ?? (runtimeToken = createRuntimeToken(chainHead));
  const { broadcastTx$ } = client;
  return {
    getChainSpecData,
    finalizedBlock$: chainHead.finalized$,
    getFinalizedBlock: () => firstValueFrom(chainHead.finalized$),
    bestBlocks$: chainHead.bestBlocks$,
    getBestBlocks: () => firstValueFrom(chainHead.bestBlocks$),
    watchBlockBody: chainHead.body$,
    getBlockBody: (hash) => firstValueFrom(chainHead.body$(hash)),
    getBlockHeader: (hash) => firstValueFrom(chainHead.header$(hash ?? null)),
    submit: (...args) => submit(chainHead, broadcastTx$, ...args),
    submitAndWatch: (...args) => submit$(chainHead, broadcastTx$, ...args),
    getTypedApi: (chainDefinition) => {
      const token = getChainToken(chainDefinition);
      return Object.assign(
        createApi(token, chainHead, broadcastTx$),
        { compatibilityToken: token }
      );
    },
    getUnsafeApi: () => {
      const token = getRuntimeToken();
      return Object.assign(createApi(token, chainHead, broadcastTx$), {
        runtimeToken: token
      });
    },
    destroy: () => {
      chainHead.unfollow();
      client.destroy();
    },
    _request
  };
}

export { createClient };
//# sourceMappingURL=client.mjs.map
