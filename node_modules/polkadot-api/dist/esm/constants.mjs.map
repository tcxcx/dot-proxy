{"version":3,"file":"constants.mjs","sources":["../../src/constants.ts"],"sourcesContent":["import { RuntimeContext } from \"@polkadot-api/observable-client\"\nimport {\n  CompatibilityFunctions,\n  CompatibilityHelper,\n  CompatibilityToken,\n  getCompatibilityApi,\n  RuntimeToken,\n} from \"./compatibility\"\n\nexport type ConstantEntry<Unsafe, D, T> = Unsafe extends true\n  ? {\n      /**\n       * Constants are simple key-value structures found in the runtime\n       * metadata.\n       *\n       * @returns Promise that will resolve in the value of the constant.\n       */\n      (): Promise<T>\n      /**\n       * @param runtimeToken  Token from got with `await\n       *                      typedApi.runtimeToken`\n       * @returns Synchronously returns value of the constant.\n       */\n      (runtimeToken: RuntimeToken): T\n    }\n  : {\n      /**\n       * Constants are simple key-value structures found in the runtime\n       * metadata.\n       *\n       * @returns Promise that will resolve in the value of the constant.\n       */\n      (): Promise<T>\n      /**\n       * @param compatibilityToken  Token from got with `await\n       *                            typedApi.compatibilityToken`\n       * @returns Synchronously returns value of the constant.\n       */\n      (compatibilityToken: CompatibilityToken): T\n    } & CompatibilityFunctions<D>\n\nexport const createConstantEntry = <D, T>(\n  palletName: string,\n  name: string,\n  {\n    valuesAreCompatible,\n    descriptors,\n    isCompatible,\n    getCompatibilityLevel,\n  }: CompatibilityHelper,\n): ConstantEntry<any, D, T> => {\n  const cachedResults = new WeakMap<RuntimeContext, T>()\n  const getValueWithContext = (ctx: RuntimeContext) => {\n    if (cachedResults.has(ctx)) {\n      return cachedResults.get(ctx)!\n    }\n\n    const pallet = ctx.lookup.metadata.pallets.find(\n      (p) => p.name === palletName,\n    )\n    const constant = pallet?.constants.find((c) => c.name === name)\n    if (constant == null)\n      throw new Error(`Runtime entry Constant(${palletName}.${name}) not found`)\n    const result = ctx.dynamicBuilder\n      .buildConstant(palletName, name)\n      .dec(constant.value)\n    cachedResults.set(ctx, result)\n    return result\n  }\n\n  const fn = (token?: CompatibilityToken | RuntimeToken): any => {\n    if (token) {\n      const ctx = getCompatibilityApi(token).runtime()\n      const value = getValueWithContext(ctx)\n      if (!valuesAreCompatible(token, ctx, value))\n        throw new Error(\n          `Incompatible runtime entry Constant(${palletName}.${name})`,\n        )\n      return value\n    }\n    return descriptors.then(fn)\n  }\n\n  return Object.assign(fn, { isCompatible, getCompatibilityLevel })\n}\n"],"names":[],"mappings":";;AAyCa,MAAA,mBAAA,GAAsB,CACjC,UAAA,EACA,IACA,EAAA;AAAA,EACE,mBAAA;AAAA,EACA,WAAA;AAAA,EACA,YAAA;AAAA,EACA;AACF,CAC6B,KAAA;AAC7B,EAAM,MAAA,aAAA,uBAAoB,OAA2B,EAAA;AACrD,EAAM,MAAA,mBAAA,GAAsB,CAAC,GAAwB,KAAA;AACnD,IAAI,IAAA,aAAA,CAAc,GAAI,CAAA,GAAG,CAAG,EAAA;AAC1B,MAAO,OAAA,aAAA,CAAc,IAAI,GAAG,CAAA;AAAA;AAG9B,IAAA,MAAM,MAAS,GAAA,GAAA,CAAI,MAAO,CAAA,QAAA,CAAS,OAAQ,CAAA,IAAA;AAAA,MACzC,CAAC,CAAM,KAAA,CAAA,CAAE,IAAS,KAAA;AAAA,KACpB;AACA,IAAM,MAAA,QAAA,GAAW,QAAQ,SAAU,CAAA,IAAA,CAAK,CAAC,CAAM,KAAA,CAAA,CAAE,SAAS,IAAI,CAAA;AAC9D,IAAA,IAAI,QAAY,IAAA,IAAA;AACd,MAAA,MAAM,IAAI,KAAM,CAAA,CAAA,uBAAA,EAA0B,UAAU,CAAA,CAAA,EAAI,IAAI,CAAa,WAAA,CAAA,CAAA;AAC3E,IAAM,MAAA,MAAA,GAAS,IAAI,cAChB,CAAA,aAAA,CAAc,YAAY,IAAI,CAAA,CAC9B,GAAI,CAAA,QAAA,CAAS,KAAK,CAAA;AACrB,IAAc,aAAA,CAAA,GAAA,CAAI,KAAK,MAAM,CAAA;AAC7B,IAAO,OAAA,MAAA;AAAA,GACT;AAEA,EAAM,MAAA,EAAA,GAAK,CAAC,KAAmD,KAAA;AAC7D,IAAA,IAAI,KAAO,EAAA;AACT,MAAA,MAAM,GAAM,GAAA,mBAAA,CAAoB,KAAK,CAAA,CAAE,OAAQ,EAAA;AAC/C,MAAM,MAAA,KAAA,GAAQ,oBAAoB,GAAG,CAAA;AACrC,MAAA,IAAI,CAAC,mBAAA,CAAoB,KAAO,EAAA,GAAA,EAAK,KAAK,CAAA;AACxC,QAAA,MAAM,IAAI,KAAA;AAAA,UACR,CAAA,oCAAA,EAAuC,UAAU,CAAA,CAAA,EAAI,IAAI,CAAA,CAAA;AAAA,SAC3D;AACF,MAAO,OAAA,KAAA;AAAA;AAET,IAAO,OAAA,WAAA,CAAY,KAAK,EAAE,CAAA;AAAA,GAC5B;AAEA,EAAA,OAAO,OAAO,MAAO,CAAA,EAAA,EAAI,EAAE,YAAA,EAAc,uBAAuB,CAAA;AAClE;;;;"}