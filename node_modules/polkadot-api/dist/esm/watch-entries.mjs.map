{"version":3,"file":"watch-entries.mjs","sources":["../../src/watch-entries.ts"],"sourcesContent":["import { HexString } from \"@polkadot-api/substrate-bindings\"\nimport type {\n  PinnedBlocks,\n  BlockInfo,\n  ChainHead$,\n  RuntimeContext,\n} from \"@polkadot-api/observable-client\"\nimport {\n  BlockNotPinnedError,\n  isBestOrFinalizedBlock,\n} from \"@polkadot-api/observable-client\"\nimport {\n  catchError,\n  combineLatest,\n  delay,\n  distinctUntilChanged,\n  EMPTY,\n  filter,\n  map,\n  merge,\n  mergeMap,\n  Observable,\n  of,\n  pairwise,\n  startWith,\n  take,\n  takeUntil,\n  throwError,\n  withLatestFrom,\n} from \"rxjs\"\nimport { selfDependent, lossLessExhaustMap } from \"@/utils\"\nimport { state } from \"@rx-state/core\"\n\ninterface StorageEntry {\n  key: HexString\n  value: HexString\n  dec: {\n    args: Array<any>\n    value: any\n  }\n}\n\ntype Deltas = {\n  upserted: Array<StorageEntry>\n  deleted: Array<StorageEntry>\n}\n\ninterface MemoryBlock {\n  prev: HexString | null\n  block: BlockInfo\n  rootHash: string\n  entries: Array<StorageEntry>\n  deltas: Deltas | null\n}\n\ntype MemoryBlocks = {\n  blocks: Record<HexString, MemoryBlock>\n  finalized: HexString\n}\n\nconst getDiff = (\n  _prev: Array<StorageEntry>,\n  _current: Array<StorageEntry>,\n  patch: (input: StorageEntry) => StorageEntry,\n): Pick<MemoryBlock, \"entries\" | \"deltas\"> => {\n  const current = new Map(_current.map((x) => [x.key, x]))\n  const prev = new Map(_prev.map((x) => [x.key, x]))\n\n  const upserted: Map<string, StorageEntry> = new Map()\n  const deleted: Array<StorageEntry> = []\n\n  _current.forEach((value) => {\n    const { key } = value\n    const prevVal = prev.get(key)\n    if (!prevVal || prevVal.value !== value.value)\n      upserted.set(key, patch(value))\n  })\n\n  _prev.forEach((x) => {\n    if (!current.has(x.key)) deleted.push(x)\n  })\n\n  return {\n    deltas: {\n      deleted,\n      upserted: [...upserted.values()],\n    },\n    entries: _current.map(({ key }) => upserted.get(key) ?? prev.get(key)!),\n  }\n}\n\nconst findPrevious = (\n  start: HexString,\n  state: MemoryBlocks[\"blocks\"],\n  pinned: PinnedBlocks,\n  includeStart = false,\n) => {\n  try {\n    let target = includeStart ? start : pinned.blocks.get(start)!.parent\n    while (target && !state[target]) target = pinned.blocks.get(target)!.parent!\n\n    if (!target) return null\n    return state[target]\n  } catch {\n    return null\n  }\n}\n\nconst getPatcherFromRuntime =\n  (pallet: string, entry: string) => (runtime: RuntimeContext) => {\n    const { keys, value } = runtime.dynamicBuilder.buildStorage(pallet, entry)\n    return (x: StorageEntry) => {\n      x.dec = {\n        value: value.dec(x.value),\n        args: keys.dec(x.key),\n      }\n      return x\n    }\n  }\n\nexport const createWatchEntries = (\n  blocks$: Observable<PinnedBlocks>,\n  storage: ChainHead$[\"storage$\"],\n  withRuntime: ChainHead$[\"withRuntime\"],\n) => {\n  const getMemoryBlocks$ = state(\n    (pallet: string, entry: string, storageKey: string) => {\n      const getPatcher = getPatcherFromRuntime(pallet, entry)\n      const getNextMemoryBlock$ = (\n        prev: MemoryBlock | null,\n        block: BlockInfo,\n      ): Observable<MemoryBlock> => {\n        const isNotCanonical$ = isBestOrFinalizedBlock(\n          blocks$,\n          block.hash,\n        ).pipe(\n          filter((x) => !x),\n          take(1),\n        )\n\n        return storage(\n          block.hash,\n          \"closestDescendantMerkleValue\",\n          () => storageKey,\n        ).pipe(\n          mergeMap((rootHash) => {\n            if (rootHash === prev?.rootHash)\n              return of({\n                ...prev,\n                block,\n                deltas: null,\n                prev: prev.block.hash,\n              })\n\n            return storage(\n              block.hash,\n              \"descendantsValues\",\n              () => storageKey,\n            ).pipe(\n              withRuntime(() => block.hash),\n              map(\n                ([entries, runtimeCtx]) =>\n                  [entries, getPatcher(runtimeCtx)] as const,\n              ),\n              map(\n                ([entries, patcher]): MemoryBlock => ({\n                  prev: prev && prev.block.hash,\n                  rootHash: rootHash!,\n                  block,\n                  ...getDiff(\n                    prev?.entries ?? [],\n                    entries as StorageEntry[],\n                    patcher,\n                  ),\n                }),\n              ),\n            )\n          }),\n          takeUntil(isNotCanonical$),\n          catchError((e) =>\n            e instanceof BlockNotPinnedError ? EMPTY : throwError(() => e),\n          ),\n        )\n      }\n\n      const initial$ = blocks$.pipe(\n        distinctUntilChanged((a, b) => a.finalized === b.finalized),\n        lossLessExhaustMap(({ blocks, finalized }) =>\n          getNextMemoryBlock$(null, blocks.get(finalized)!),\n        ),\n        take(1),\n        map(\n          (x): MemoryBlocks => ({\n            blocks: { [x.block.hash]: x },\n            finalized: x.block.hash,\n          }),\n        ),\n      )\n\n      const [_memoryBlocks$, connectMemoryBlocks] =\n        selfDependent<MemoryBlocks>()\n      const updates$ = blocks$.pipe(\n        distinctUntilChanged((a, b) => a.best === b.best),\n        withLatestFrom(_memoryBlocks$),\n        lossLessExhaustMap(([pinned, memoryBlocks]) => {\n          const { best } = pinned\n          const { blocks } = memoryBlocks\n          let target = !blocks[best] ? best : null\n          if (!target) return EMPTY\n\n          const previous = findPrevious(target, blocks, pinned)\n          if (previous)\n            return getNextMemoryBlock$(\n              previous,\n              pinned.blocks.get(target)!,\n            ).pipe(\n              map((x) => {\n                blocks[target!] = x\n                return memoryBlocks\n              }),\n            )\n\n          // This means that there has been a stop event that the pinned-blocks\n          // couldn't recover from. Therefore, we must \"start over\"\n          target = pinned.finalized\n          return getNextMemoryBlock$(\n            blocks[memoryBlocks.finalized],\n            pinned.blocks.get(target)!,\n          ).pipe(\n            map((x) => {\n              x.prev = null\n              return {\n                blocks: { [target]: x },\n                finalized: target,\n              }\n            }),\n          )\n        }),\n      )\n\n      return merge(initial$, updates$).pipe(connectMemoryBlocks())\n    },\n  )\n\n  const getBestOrFinalized =\n    (isFinalized: boolean) =>\n    (pallet: string, entry: string, storageKey: string) => {\n      const memoryBlocks$ = getMemoryBlocks$(pallet, entry, storageKey)\n      const getPatcher = getPatcherFromRuntime(pallet, entry)\n\n      const prop = isFinalized ? \"finalized\" : \"best\"\n\n      return combineLatest([\n        memoryBlocks$.pipe(delay(0)),\n        blocks$.pipe(distinctUntilChanged((a, b) => a[prop] === b[prop])),\n      ]).pipe(\n        map(([state, blocks]) =>\n          findPrevious(blocks[prop], state.blocks, blocks, true),\n        ),\n        filter(Boolean),\n        distinctUntilChanged(),\n        startWith(null),\n        pairwise(),\n        withLatestFrom(memoryBlocks$),\n        withRuntime(([[, _latest]]) => _latest!.block.hash),\n        map(\n          ([[[prevUpdate, latest], memoryBlocks], runtimeCtx]) =>\n            [\n              prevUpdate,\n              latest!,\n              memoryBlocks,\n              getPatcher(runtimeCtx),\n            ] as const,\n        ),\n        mergeMap(([prevUpdate, latest, memoryBlocks, patcher]) => {\n          if (!prevUpdate) return [latest]\n\n          let ancestor: MemoryBlock | null = latest\n          const updates: Array<MemoryBlock> = []\n          while (ancestor && ancestor.block.number > prevUpdate.block.number) {\n            updates.unshift(ancestor)\n            ancestor = ancestor.prev ? memoryBlocks.blocks[ancestor.prev] : null\n          }\n\n          if (isFinalized) {\n            memoryBlocks.finalized = latest.block.hash\n            if (updates.length) {\n              const { blocks } = memoryBlocks\n              Object.keys(blocks).forEach((key) => {\n                if (blocks[key].block.number < updates[0].block.number)\n                  delete blocks[key]\n              })\n            }\n          }\n\n          if (prevUpdate === ancestor) return updates\n\n          // It's a re-org\n          return [\n            {\n              ...latest,\n              ...(prevUpdate.rootHash === latest.rootHash\n                ? {\n                    entries: prevUpdate.entries,\n                    deltas: null,\n                  }\n                : getDiff(prevUpdate.entries, latest.entries, patcher)),\n            },\n          ]\n        }),\n      )\n    }\n\n  const getFinalized$ = state(getBestOrFinalized(true))\n  const getBest$ = state(getBestOrFinalized(false))\n\n  return (pallet: string, entry: string, args: Array<any>, atBest: boolean) => {\n    const fn = atBest ? getBest$ : getFinalized$\n    const storageKey$ = blocks$.pipe(\n      take(1),\n      mergeMap(\n        (b) =>\n          b.runtimes[b.blocks.get(b[atBest ? \"best\" : \"finalized\"])!.runtime]\n            .runtime,\n      ),\n      map((runtime) =>\n        runtime.dynamicBuilder.buildStorage(pallet, entry).keys.enc(...args),\n      ),\n    )\n    return storageKey$.pipe(\n      take(1),\n      mergeMap((storageKey) => fn(pallet, entry, storageKey)),\n      map(({ block: { hash, number, parent }, deltas, entries }, idx) => {\n        const actualDeltas =\n          idx > 0 ? deltas : { deleted: [], upserted: entries }\n\n        return {\n          block: { hash, number, parent },\n          entries: entries.map(toDec),\n          deltas: actualDeltas && {\n            deleted: actualDeltas.deleted.map(toDec),\n            upserted: actualDeltas.upserted.map(toDec),\n          },\n        }\n      }),\n    )\n  }\n}\n\nconst toDec = <T>(x: { dec: T }): T => x.dec\n"],"names":["state"],"mappings":"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"}