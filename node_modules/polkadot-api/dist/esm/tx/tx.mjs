import { getPolkadotSigner } from '@polkadot-api/signer';
import { AccountId, Struct, u128, Variant, _void, compactBn, Enum, u32, Binary } from '@polkadot-api/substrate-bindings';
import { toHex, fromHex, mergeUint8 } from '@polkadot-api/utils';
import { firstValueFrom, mergeMap, map, take, throwError, combineLatest } from 'rxjs';
import { getCompatibilityApi } from '../compatibility.mjs';
import { createTx } from './create-tx.mjs';
import { submit, submit$ } from './submit-fns.mjs';
export { InvalidTxError } from './submit-fns.mjs';
import { isCompatible, mapLookupToTypedef } from '@polkadot-api/metadata-compatibility';

const accountIdEnc = AccountId().enc;
const fakeSignature = new Uint8Array(64);
const fakeSignatureEth = new Uint8Array(65);
const getFakeSignature = (isEth) => () => isEth ? fakeSignatureEth : fakeSignature;
const [, queryInfoDecFallback] = Struct({
  weight: Struct({
    ref_time: compactBn,
    proof_size: compactBn
  }),
  class: Variant({
    Normal: _void,
    Operational: _void,
    Mandatory: _void
  }),
  partial_fee: u128
});
const createTxEntry = (pallet, name, chainHead, broadcast, {
  isCompatible: isCompatibleHelper,
  getCompatibilityLevel,
  compatibleRuntime$,
  argsAreCompatible,
  getRuntimeTypedef
}, checkCompatibility) => {
  const fn = (arg) => {
    const getCallDataWithContext = (runtime, arg2, txOptions = {}) => {
      const ctx = getCompatibilityApi(runtime).runtime();
      const { dynamicBuilder, assetId, lookup } = ctx;
      let codecs;
      try {
        codecs = dynamicBuilder.buildCall(pallet, name);
      } catch {
        throw new Error(`Runtime entry Tx(${pallet}.${name}) not found`);
      }
      if (checkCompatibility && !argsAreCompatible(runtime, ctx, arg2))
        throw new Error(`Incompatible runtime entry Tx(${pallet}.${name})`);
      let returnOptions = txOptions;
      if (txOptions.asset) {
        if (assetId == null || !isCompatible(
          txOptions.asset,
          mapLookupToTypedef(lookup(assetId)),
          (id) => getRuntimeTypedef(ctx, id)
        ))
          throw new Error(`Incompatible runtime asset`);
        returnOptions = {
          ...txOptions,
          asset: dynamicBuilder.buildDefinition(assetId).enc(txOptions.asset)
        };
      }
      const { location, codec } = codecs;
      return {
        callData: Binary.fromBytes(
          mergeUint8(new Uint8Array(location), codec.enc(arg2))
        ),
        options: returnOptions
      };
    };
    const getCallData$ = (arg2, options = {}) => compatibleRuntime$(chainHead, null).pipe(
      map(([runtime]) => getCallDataWithContext(runtime, arg2, options))
    );
    const getEncodedData = (token) => {
      if (!token)
        return firstValueFrom(getCallData$(arg).pipe(map((x) => x.callData)));
      return getCallDataWithContext(token, arg).callData;
    };
    const sign$ = (from, { ..._options }, atBlock) => getCallData$(arg, _options).pipe(
      mergeMap(
        ({ callData, options }) => createTx(
          chainHead,
          from,
          callData.asBytes(),
          atBlock,
          _options.customSignedExtensions || {},
          options
        )
      )
    );
    const _sign = (from, { at, ..._options } = {}) => {
      return (!at || at === "finalized" ? chainHead.finalized$ : at === "best" ? chainHead.best$ : chainHead.bestBlocks$.pipe(
        map((x) => x.find((b) => b.hash === at))
      )).pipe(
        take(1),
        mergeMap(
          (atBlock) => atBlock ? sign$(from, _options, atBlock).pipe(
            map((signed) => ({
              tx: toHex(signed),
              block: atBlock
            }))
          ) : throwError(() => new Error(`Uknown block ${at}`))
        )
      );
    };
    const sign = (from, options) => firstValueFrom(_sign(from, options)).then((x) => x.tx);
    const signAndSubmit = (from, _options) => firstValueFrom(_sign(from, _options)).then(
      ({ tx, block }) => submit(chainHead, broadcast, tx, block.hash)
    );
    const signSubmitAndWatch = (from, _options) => _sign(from, _options).pipe(
      mergeMap(
        ({ tx, block }) => submit$(chainHead, broadcast, tx, block.hash, true)
      )
    );
    const getPaymentInfo = async (from, _options) => {
      if (typeof from === "string")
        from = from.startsWith("0x") ? fromHex(from) : accountIdEnc(from);
      const isEth = from.length === 20;
      const fakeSigner = getPolkadotSigner(
        from,
        isEth ? "Ecdsa" : "Sr25519",
        getFakeSignature(isEth)
      );
      const encoded = fromHex(await sign(fakeSigner, _options));
      const args = toHex(mergeUint8(encoded, u32.enc(encoded.length)));
      const decoder$ = chainHead.getRuntimeContext$(null).pipe(
        map((ctx) => {
          try {
            return ctx.dynamicBuilder.buildRuntimeCall(
              "TransactionPaymentApi",
              "query_info"
            ).value[1];
          } catch {
            return queryInfoDecFallback;
          }
        })
      );
      const call$ = chainHead.call$(
        null,
        "TransactionPaymentApi_query_info",
        args
      );
      return firstValueFrom(
        combineLatest([call$, decoder$]).pipe(
          map(([result, decoder]) => decoder(result))
        )
      );
    };
    const getEstimatedFees = async (from, _options) => (await getPaymentInfo(from, _options)).partial_fee;
    return {
      getPaymentInfo,
      getEstimatedFees,
      decodedCall: {
        type: pallet,
        value: Enum(name, arg)
      },
      getEncodedData,
      sign,
      signSubmitAndWatch,
      signAndSubmit
    };
  };
  return Object.assign(fn, {
    getCompatibilityLevel,
    isCompatible: isCompatibleHelper
  });
};

export { createTxEntry, submit, submit$ };
//# sourceMappingURL=tx.mjs.map
