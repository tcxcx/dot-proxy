import { mapObject, fromHex } from '@polkadot-api/utils';
import { getSystemVersionStruct } from './system-version.mjs';
import { mortal } from './mortal-enc.mjs';
import { ChargeAssetTxPaymentEnc } from './charge-asset-tx-enc.mjs';

const empty = new Uint8Array();
const zero = Uint8Array.from([0]);
const value = (value2) => ({
  value: value2,
  additionalSigned: empty
});
const additionalSigned = (additionalSigned2) => ({
  value: empty,
  additionalSigned: additionalSigned2
});
const both = (value2, additionalSigned2) => ({
  value: value2,
  additionalSigned: additionalSigned2
});
const getSignExtensionsCreator = (genesis, lookupFn, dynamicBuilder) => {
  const signedExtensionsEncoders = {};
  lookupFn.metadata.extrinsic.signedExtensions.forEach(
    ({ identifier, type, additionalSigned: additionalSigned2 }) => {
      signedExtensionsEncoders[identifier] = [type, additionalSigned2].map(
        (x) => dynamicBuilder.buildDefinition(x)[0]
      );
    }
  );
  return ({
    mortality,
    tip = 0n,
    nonce,
    customSignedExtensions = {},
    ...rest
  }) => {
    const invalidKeys = [];
    const systemVersion = getSystemVersionStruct(lookupFn, dynamicBuilder);
    const getFromCustomEntry = (key) => {
      const [valueEnc, additionalEnc] = signedExtensionsEncoders[key];
      const customEntry = customSignedExtensions[key];
      try {
        return mapObject(
          {
            value: valueEnc,
            additionalSigned: additionalEnc
          },
          (encoder, key2) => {
            const input = customEntry?.[key2];
            return input instanceof Uint8Array ? input : encoder(input);
          }
        );
      } catch {
        invalidKeys.push(key);
        return null;
      }
    };
    const result = mapObject(
      signedExtensionsEncoders,
      ([valueEnc, additionalEnc], key) => {
        if (customSignedExtensions[key]) return getFromCustomEntry(key);
        switch (key) {
          case "CheckNonce":
            return value(valueEnc(nonce));
          case "CheckMortality":
            return mortality.mortal ? both(
              mortal({
                period: mortality.period,
                phase: mortality.startAtBlock.height % mortality.period
              }),
              fromHex(mortality.startAtBlock.hash)
            ) : both(zero, genesis);
          case "ChargeTransactionPayment":
            return value(valueEnc(tip));
          case "ChargeAssetTxPayment":
            return value(
              ChargeAssetTxPaymentEnc({
                tip,
                asset: rest.asset
              })
            );
          case "CheckGenesis":
            return additionalSigned(genesis);
          case "CheckMetadataHash":
            return both(zero, zero);
          case "CheckSpecVersion":
            return additionalSigned(
              additionalEnc(systemVersion["spec_version"])
            );
          case "CheckTxVersion":
            return additionalSigned(
              additionalEnc(systemVersion["transaction_version"])
            );
          default:
            return getFromCustomEntry(key);
        }
      }
    );
    invalidKeys.forEach((key) => {
      delete result[key];
    });
    return mapObject(result, (x, identifier) => ({ ...x, identifier }));
  };
};

export { getSignExtensionsCreator };
//# sourceMappingURL=sign-extensions.mjs.map
