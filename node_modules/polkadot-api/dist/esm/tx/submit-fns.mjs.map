{"version":3,"file":"submit-fns.mjs","sources":["../../../src/tx/submit-fns.ts"],"sourcesContent":["import {\n  Binary,\n  Blake2256,\n  HexString,\n  ResultPayload,\n} from \"@polkadot-api/substrate-bindings\"\nimport {\n  EMPTY,\n  Observable,\n  concat,\n  distinctUntilChanged,\n  filter,\n  lastValueFrom,\n  map,\n  mergeMap,\n  of,\n  take,\n} from \"rxjs\"\nimport {\n  ChainHead$,\n  PinnedBlocks,\n  SystemEvent,\n} from \"@polkadot-api/observable-client\"\nimport { AnalyzedBlock } from \"@polkadot-api/observable-client\"\nimport { TxEvent, TxEventsPayload, TxFinalizedPayload } from \"./types\"\nimport { continueWith } from \"@/utils\"\nimport { fromHex, toHex } from \"@polkadot-api/utils\"\n\n// TODO: make it dynamic based on the tx-function of the client\nconst hashFromTx = (tx: HexString) => toHex(Blake2256(fromHex(tx)))\n\nconst computeState = (\n  analized$: Observable<AnalyzedBlock>,\n  blocks$: Observable<PinnedBlocks>,\n) =>\n  new Observable<\n    | {\n        found: true\n        hash: string\n        number: number\n        index: number\n        events: any\n      }\n    | { found: false; validity: ResultPayload<any, any> | null }\n  >((observer) => {\n    const analyzedBlocks = new Map<string, AnalyzedBlock>()\n    let pinnedBlocks: PinnedBlocks\n    let latestState:\n      | {\n          found: true\n          hash: string\n          number: number\n          index: number\n          events: any\n        }\n      | { found: false; validity: ResultPayload<any, any> | null }\n\n    const computeNextState = () => {\n      let current: string = pinnedBlocks.best\n      let analyzed: AnalyzedBlock | undefined = analyzedBlocks.get(current)\n      let analyzedNumber = pinnedBlocks.blocks.get(current)!.number\n\n      while (!analyzed) {\n        const block = pinnedBlocks.blocks.get(current)\n        if (!block) break\n        analyzed = analyzedBlocks.get((current = block.parent))\n        analyzedNumber--\n      }\n\n      if (!analyzed) return // this shouldn't happen, though\n\n      const isFinalized =\n        analyzedNumber <=\n        pinnedBlocks.blocks.get(pinnedBlocks.finalized)!.number\n\n      const found = analyzed.found.type\n      if (found && latestState?.found && latestState.hash === analyzed.hash) {\n        if (isFinalized) observer.complete()\n        return\n      }\n\n      observer.next(\n        (latestState = analyzed.found.type\n          ? {\n              found: found as true,\n              hash: analyzed.hash,\n              number: analyzedNumber,\n              index: analyzed.found.index,\n              events: analyzed.found.events,\n            }\n          : {\n              found: found as false,\n              validity: analyzed.found.validity,\n            }),\n      )\n\n      if (isFinalized) {\n        if (found) observer.complete()\n        else if (analyzed.found.validity?.success === false)\n          observer.error(new InvalidTxError(analyzed.found.validity.value))\n      }\n    }\n\n    const subscription = blocks$\n      .pipe(\n        distinctUntilChanged(\n          (a, b) => a.finalized === b.finalized && a.best === b.best,\n        ),\n      )\n      .subscribe({\n        next: (pinned: PinnedBlocks) => {\n          pinnedBlocks = pinned\n          if (analyzedBlocks.size === 0) return\n          computeNextState()\n        },\n        error(e) {\n          observer.error(e)\n        },\n      })\n\n    subscription.add(\n      analized$.subscribe({\n        next: (block) => {\n          analyzedBlocks.set(block.hash, block)\n          computeNextState()\n        },\n        error(e) {\n          observer.error(e)\n        },\n      }),\n    )\n\n    return subscription\n  }).pipe(distinctUntilChanged((a, b) => a === b))\n\nconst getTxSuccessFromSystemEvents = (\n  systemEvents: Array<SystemEvent>,\n  txIdx: number,\n): Omit<TxEventsPayload, \"block\"> => {\n  const events = systemEvents\n    .filter((x) => x.phase.type === \"ApplyExtrinsic\" && x.phase.value === txIdx)\n    .map((x) => ({ ...x.event, topics: x.topics }))\n\n  const lastEvent = events[events.length - 1]\n  if (\n    lastEvent.type === \"System\" &&\n    lastEvent.value.type === \"ExtrinsicFailed\"\n  ) {\n    return {\n      ok: false,\n      events,\n      dispatchError: lastEvent.value.value.dispatch_error,\n    }\n  }\n\n  return { ok: true, events }\n}\n\n/*\ntype TransactionValidityError = Enum<{\n  Invalid: Enum<{\n    Call: undefined\n    Payment: undefined\n    Future: undefined\n    Stale: undefined\n    BadProof: undefined\n    AncientBirthBlock: undefined\n    ExhaustsResources: undefined\n    Custom: number\n    BadMandatory: undefined\n    MandatoryValidation: undefined\n    BadSigner: undefined\n  }>\n  Unknown: Enum<{\n    CannotLookup: undefined\n    NoUnsignedValidator: undefined\n    Custom: number\n  }>\n}>\n*/\n\nexport class InvalidTxError extends Error {\n  error: any // likely to be a `TransactionValidityError`\n  constructor(e: any) {\n    super(\n      JSON.stringify(\n        e,\n        (_, value) => {\n          if (typeof value === \"bigint\") return value.toString()\n          return value instanceof Binary ? value.asHex() : value\n        },\n        2,\n      ),\n    )\n    this.name = \"InvalidTxError\"\n    this.error = e\n  }\n}\n\nexport const submit$ = (\n  chainHead: ChainHead$,\n  broadcastTx$: (tx: string) => Observable<never>,\n  tx: HexString,\n  at?: HexString,\n  emitSign = false,\n): Observable<TxEvent> => {\n  const txHash = hashFromTx(tx)\n  const getTxEvent = <\n    Type extends TxEvent[\"type\"],\n    Rest extends Omit<TxEvent & { type: Type }, \"type\" | \"txHash\">,\n  >(\n    type: Type,\n    rest: Rest,\n  ): TxEvent & { type: Type } =>\n    ({\n      type,\n      txHash,\n      ...rest,\n    }) as any\n\n  const at$ = chainHead.pinnedBlocks$.pipe(\n    take(1),\n    map((blocks) => {\n      const block = blocks.blocks.get(at!)\n      return block && !block.unpinned ? block.hash : blocks.finalized\n    }),\n  )\n\n  const validate$: Observable<never> = at$.pipe(\n    mergeMap((at) =>\n      chainHead.validateTx$(at, tx).pipe(\n        filter((x) => !x.success),\n        map((x) => {\n          throw new InvalidTxError(x.value)\n        }),\n      ),\n    ),\n  )\n\n  const track$ = new Observable<AnalyzedBlock>((observer) => {\n    const subscription = chainHead.trackTx$(tx).subscribe(observer)\n    subscription.add(\n      broadcastTx$(tx).subscribe({\n        error(e) {\n          observer.error(e)\n        },\n      }),\n    )\n    return subscription\n  })\n\n  const bestBlockState$ = computeState(track$, chainHead.pinnedBlocks$).pipe(\n    map((x) => {\n      if (!x.found)\n        return getTxEvent(\"txBestBlocksState\", {\n          found: false,\n          isValid: x.validity?.success !== false,\n        })\n\n      return getTxEvent(\"txBestBlocksState\", {\n        found: true,\n        block: {\n          index: x.index,\n          number: x.number,\n          hash: x.hash,\n        },\n        ...getTxSuccessFromSystemEvents(x.events, x.index),\n      })\n    }),\n  )\n\n  return concat(\n    emitSign ? of(getTxEvent(\"signed\", {})) : EMPTY,\n    validate$,\n    of(getTxEvent(\"broadcasted\", {})),\n    bestBlockState$.pipe(\n      continueWith(({ found, type, ...rest }) =>\n        found ? of(getTxEvent(\"finalized\", rest as any)) : EMPTY,\n      ),\n    ),\n  )\n}\n\nexport const submit = async (\n  chainHead: ChainHead$,\n  broadcastTx$: (tx: string) => Observable<never>,\n  transaction: HexString,\n  at?: HexString,\n): Promise<TxFinalizedPayload> =>\n  lastValueFrom(submit$(chainHead, broadcastTx$, transaction, at)).then((x) => {\n    if (x.type !== \"finalized\") throw null\n    const result: TxFinalizedPayload = { ...x }\n    delete (result as any).type\n    return result\n  })\n"],"names":["at"],"mappings":"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"}