{"version":3,"file":"compatibility.mjs","sources":["../../src/compatibility.ts"],"sourcesContent":["import { MetadataLookup } from \"@polkadot-api/metadata-builders\"\nimport {\n  CompatibilityCache,\n  CompatibilityLevel,\n  EntryPoint,\n  EntryPointCodec,\n  TypedefCodec,\n  TypedefNode,\n  entryPointsAreCompatible,\n  mapLookupToTypedef,\n  valueIsCompatibleWithDest,\n} from \"@polkadot-api/metadata-compatibility\"\nimport { ChainHead$, RuntimeContext } from \"@polkadot-api/observable-client\"\nimport { Tuple, Vector } from \"@polkadot-api/substrate-bindings\"\nimport { Observable, combineLatest, filter, firstValueFrom, map } from \"rxjs\"\nimport { ChainDefinition } from \"./descriptors\"\n\nexport class RuntimeToken<D = unknown> {\n  private constructor() {}\n\n  // @ts-ignore\n  protected _runtime(value: D) {}\n}\n\nexport class CompatibilityToken<D = unknown> {\n  private constructor() {}\n\n  // @ts-ignore\n  protected _compatibility(value: D) {}\n}\n\ninterface RuntimeTokenApi {\n  runtime: () => RuntimeContext\n}\ninterface CompatibilityTokenApi extends RuntimeTokenApi {\n  typedefNodes: TypedefNode[]\n  getPalletEntryPoint: (\n    opType: OpType,\n    pallet: string,\n    name: string,\n  ) => EntryPoint\n  getApiEntryPoint: (name: string, method: string) => EntryPoint\n}\nconst compatibilityTokenApi = new WeakMap<\n  CompatibilityToken,\n  CompatibilityTokenApi\n>()\nconst runtimeTokenApi = new WeakMap<RuntimeToken, RuntimeTokenApi>()\nexport const getCompatibilityApi = (\n  token: RuntimeToken | CompatibilityToken,\n): RuntimeTokenApi | CompatibilityTokenApi =>\n  token instanceof RuntimeToken\n    ? runtimeTokenApi.get(token)!\n    : compatibilityTokenApi.get(token)!\n\nexport const enum OpType {\n  Storage = \"storage\",\n  Tx = \"tx\",\n  Event = \"events\",\n  Const = \"constants\",\n}\n\nconst EntryPointsCodec = Vector(EntryPointCodec)\nconst TypedefsCodec = Vector(TypedefCodec)\nconst TypesCodec = Tuple(EntryPointsCodec, TypedefsCodec)\n\nexport const createCompatibilityToken = <D extends ChainDefinition>(\n  chainDefinition: D,\n  chainHead: ChainHead$,\n): Promise<CompatibilityToken<D>> => {\n  const awaitedRuntime = new Promise<() => RuntimeContext>(async (resolve) => {\n    const loadedRuntime$ = chainHead.runtime$.pipe(filter((v) => v != null))\n\n    let latest = await firstValueFrom(loadedRuntime$)\n    loadedRuntime$.subscribe((v) => (latest = v))\n\n    resolve(() => latest)\n  })\n\n  const promise = Promise.all([\n    chainDefinition.metadataTypes.then(TypesCodec.dec),\n    chainDefinition.descriptors,\n    awaitedRuntime,\n  ]).then(([[entryPoints, typedefNodes], descriptors, runtime]) => {\n    const token = new (CompatibilityToken as any)()\n    compatibilityTokenApi.set(token, {\n      runtime,\n      getPalletEntryPoint(opType, pallet, name) {\n        const idx = descriptors[opType]?.[pallet]?.[name]\n        if (idx == null)\n          throw new Error(\n            `Descriptor for ${opType} ${pallet}.${name} does not exist`,\n          )\n        return entryPoints[idx]\n      },\n      getApiEntryPoint(name, method) {\n        const idx = descriptors.apis?.[name]?.[method]\n        if (idx == null)\n          throw new Error(`Descriptor for API ${name}.${method} does not exist`)\n        return entryPoints[idx]\n      },\n      typedefNodes,\n    })\n\n    return token\n  })\n\n  return promise\n}\n\nexport const createRuntimeToken = <D>(\n  chainHead: ChainHead$,\n): Promise<RuntimeToken<D>> => {\n  const awaitedRuntime = new Promise<() => RuntimeContext>(async (resolve) => {\n    const loadedRuntime$ = chainHead.runtime$.pipe(filter((v) => v != null))\n\n    let latest = await firstValueFrom(loadedRuntime$)\n    loadedRuntime$.subscribe((v) => (latest = v))\n\n    resolve(() => latest)\n  })\n\n  const promise = awaitedRuntime.then((runtime) => {\n    const token = new (RuntimeToken as any)()\n    runtimeTokenApi.set(token, {\n      runtime,\n    })\n    return token\n  })\n\n  return promise\n}\n\n// metadataRaw -> cache\nconst metadataCache = new WeakMap<\n  Uint8Array,\n  {\n    compat: CompatibilityCache\n    lookup: MetadataLookup\n    typeNodes: (TypedefNode | null)[]\n  }\n>()\nconst getMetadataCache = (ctx: RuntimeContext) => {\n  if (!metadataCache.has(ctx.metadataRaw)) {\n    metadataCache.set(ctx.metadataRaw, {\n      compat: new Map(),\n      lookup: ctx.lookup,\n      typeNodes: [],\n    })\n  }\n  return metadataCache.get(ctx.metadataRaw)!\n}\nexport const compatibilityHelper = (\n  descriptors: Promise<RuntimeToken | CompatibilityToken>,\n  getDescriptorEntryPoint: (descriptorApi: CompatibilityTokenApi) => EntryPoint,\n  getRuntimeEntryPoint: (ctx: RuntimeContext) => EntryPoint | null,\n) => {\n  const getRuntimeTypedef = (ctx: RuntimeContext, id: number) => {\n    const cache = getMetadataCache(ctx)\n    return (cache.typeNodes[id] ||= mapLookupToTypedef(cache.lookup(id)))\n  }\n\n  function getCompatibilityLevels(\n    descriptors: CompatibilityToken | RuntimeToken,\n    /**\n     * The `Runtime` of runtimeWithDescriptors already has a RuntimeContext,\n     * which is the runtime of the finalized block.\n     * But on some cases, the user wants to perform an action on a specific\n     * block hash, which has a different RuntimeContext.\n     */\n    ctx?: RuntimeContext,\n  ) {\n    if (descriptors instanceof RuntimeToken) {\n      return {\n        args: CompatibilityLevel.Identical,\n        values: CompatibilityLevel.Identical,\n      }\n    }\n    const compatibilityApi = compatibilityTokenApi.get(descriptors)!\n    ctx ||= compatibilityApi.runtime()\n    const descriptorEntryPoint = getDescriptorEntryPoint(compatibilityApi)\n    const runtimeEntryPoint = getRuntimeEntryPoint(ctx)\n    if (runtimeEntryPoint == null)\n      return {\n        args: CompatibilityLevel.Incompatible,\n        values: CompatibilityLevel.Incompatible,\n      }\n    const descriptorNodes = compatibilityApi.typedefNodes\n\n    const cache = getMetadataCache(ctx)\n\n    return entryPointsAreCompatible(\n      descriptorEntryPoint,\n      (id) => descriptorNodes[id],\n      runtimeEntryPoint,\n      (id) => getRuntimeTypedef(ctx, id),\n      cache.compat,\n    )\n  }\n\n  const getCompatibilityLevel = withOptionalToken(descriptors, (runtime) =>\n    minCompatLevel(getCompatibilityLevels(runtime)),\n  )\n  const isCompatible = withOptionalToken(\n    descriptors,\n    (threshold: CompatibilityLevel, runtime) =>\n      getCompatibilityLevel(runtime) >= threshold,\n  )\n\n  const compatibleRuntime$ = (chainHead: ChainHead$, hash: string | null) =>\n    combineLatest([descriptors, chainHead.getRuntimeContext$(hash)])\n\n  const withCompatibleRuntime =\n    <T>(chainHead: ChainHead$, mapper: (x: T) => string) =>\n    (\n      source$: Observable<T>,\n    ): Observable<[T, CompatibilityToken | RuntimeToken, RuntimeContext]> =>\n      combineLatest([\n        source$.pipe(chainHead.withRuntime(mapper)),\n        descriptors,\n      ]).pipe(map(([[x, ctx], descriptors]) => [x, descriptors, ctx]))\n\n  const argsAreCompatible = (\n    descriptors: CompatibilityToken | RuntimeToken,\n    ctx: RuntimeContext,\n    args: unknown,\n  ) => {\n    if (descriptors instanceof RuntimeToken) return true\n    const levels = getCompatibilityLevels(descriptors, ctx)\n    if (levels.args === CompatibilityLevel.Incompatible) return false\n    if (levels.args > CompatibilityLevel.Partial) return true\n    // Although technically args could still be compatible, if the output will be incompatible we might as well just return false to skip sending the request.\n    if (levels.values === CompatibilityLevel.Incompatible) return false\n\n    const entryPoint = getRuntimeEntryPoint(ctx)\n    if (entryPoint == null) return false\n\n    return valueIsCompatibleWithDest(\n      entryPoint.args,\n      (id) => getRuntimeTypedef(ctx, id),\n      args,\n    )\n  }\n  const valuesAreCompatible = (\n    descriptors: CompatibilityToken | RuntimeToken,\n    ctx: RuntimeContext,\n    values: unknown,\n  ) => {\n    if (descriptors instanceof RuntimeToken) return true\n    const level = getCompatibilityLevels(descriptors, ctx).values\n    if (level === CompatibilityLevel.Incompatible) return false\n    if (level > CompatibilityLevel.Partial) return true\n\n    const compatibilityApi = compatibilityTokenApi.get(descriptors)!\n\n    const entryPoint = getDescriptorEntryPoint(compatibilityApi)\n\n    return valueIsCompatibleWithDest(\n      entryPoint.values,\n      (id) => compatibilityApi.typedefNodes[id],\n      values,\n    )\n  }\n\n  return {\n    isCompatible,\n    getCompatibilityLevel,\n    getCompatibilityLevels,\n    descriptors,\n    withCompatibleRuntime,\n    compatibleRuntime$,\n    argsAreCompatible,\n    valuesAreCompatible,\n    getRuntimeTypedef,\n  }\n}\nexport type CompatibilityHelper = ReturnType<typeof compatibilityHelper>\n\nexport const minCompatLevel = (levels: {\n  args: CompatibilityLevel\n  values: CompatibilityLevel\n}) => Math.min(levels.args, levels.values)\n\nconst withOptionalToken =\n  <T, D, A extends [...any[], CompatibilityToken | RuntimeToken]>(\n    compatibilityToken: Promise<CompatibilityToken<D> | RuntimeToken<D>>,\n    fn: (...args: A) => T,\n  ): WithOptionalRuntime<T, D, A extends [...infer R, any] ? R : []> =>\n  (...args: any): any => {\n    const lastElement = args.at(-1)\n    if (\n      lastElement instanceof CompatibilityToken ||\n      lastElement instanceof RuntimeToken\n    ) {\n      return fn(...args)\n    }\n    return compatibilityToken.then((token) => (fn as any)(...args, token))\n  }\n\nexport type WithOptionalRuntime<T, D, A extends any[]> = {\n  /**\n   * Returns the result after waiting for the runtime to load.\n   */\n  (...args: A): Promise<T>\n  /**\n   * Returns the result synchronously with the loaded runtime.\n   */\n  (...args: [...A, runtime: CompatibilityToken<D> | RuntimeToken<D>]): T\n}\n\nexport interface CompatibilityFunctions<D> {\n  /**\n   * Returns the `CompatibilityLevel` for this call comparing the descriptors\n   * generated on dev time with the current live metadata.\n   */\n  getCompatibilityLevel(): Promise<CompatibilityLevel>\n  /**\n   * Returns the `CompatibilityLevel` for this call comparing the descriptors\n   * generated on dev time with the current live metadata.\n   *\n   * @param compatibilityToken  CompatibilityToken awaited from\n   *                            typedApi.compatibilityToken.\n   */\n  getCompatibilityLevel(\n    compatibilityToken: CompatibilityToken<D>,\n  ): CompatibilityLevel\n\n  /**\n   * Returns whether this call is compatible based on the CompatibilityLevel\n   * threshold.\n   *\n   * @param threshold  CompatibilityLevel threshold to use, inclusive.\n   */\n  isCompatible(threshold: CompatibilityLevel): Promise<boolean>\n\n  /**\n   * Returns whether this call is compatible based on the CompatibilityLevel\n   * threshold.\n   *\n   * @param threshold           CompatibilityLevel threshold to use,\n   *                            inclusive.\n   * @param compatibilityToken  CompatibilityToken awaited from\n   *                            typedApi.compatibilityToken.\n   */\n  isCompatible(\n    threshold: CompatibilityLevel,\n    compatibilityToken: CompatibilityToken<D>,\n  ): boolean\n}\n"],"names":["OpType","descriptors"],"mappings":"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"}