{"version":3,"file":"index.js","sources":["../src/compatibility.ts","../src/constants.ts","../src/utils/shareLatest.ts","../src/utils/firstValueFromWithSignal.ts","../src/utils/lossLessExhaustMap.ts","../src/utils/continue-with.ts","../src/utils/optional-arg.ts","../src/utils/self-dependent.ts","../src/event.ts","../src/runtime-call.ts","../src/storage.ts","../src/tx/signed-extensions/system-version.ts","../src/tx/signed-extensions/mortal-enc.ts","../src/tx/signed-extensions/charge-asset-tx-enc.ts","../src/tx/signed-extensions/sign-extensions.ts","../src/tx/create-tx.ts","../src/tx/submit-fns.ts","../src/tx/tx.ts","../src/watch-entries.ts","../src/client.ts","../src/offline.ts"],"sourcesContent":["import { MetadataLookup } from \"@polkadot-api/metadata-builders\"\nimport {\n  CompatibilityCache,\n  CompatibilityLevel,\n  EntryPoint,\n  EntryPointCodec,\n  TypedefCodec,\n  TypedefNode,\n  entryPointsAreCompatible,\n  mapLookupToTypedef,\n  valueIsCompatibleWithDest,\n} from \"@polkadot-api/metadata-compatibility\"\nimport { ChainHead$, RuntimeContext } from \"@polkadot-api/observable-client\"\nimport { Tuple, Vector } from \"@polkadot-api/substrate-bindings\"\nimport { Observable, combineLatest, filter, firstValueFrom, map } from \"rxjs\"\nimport { ChainDefinition } from \"./descriptors\"\n\nexport class RuntimeToken<D = unknown> {\n  private constructor() {}\n\n  // @ts-ignore\n  protected _runtime(value: D) {}\n}\n\nexport class CompatibilityToken<D = unknown> {\n  private constructor() {}\n\n  // @ts-ignore\n  protected _compatibility(value: D) {}\n}\n\ninterface RuntimeTokenApi {\n  runtime: () => RuntimeContext\n}\ninterface CompatibilityTokenApi extends RuntimeTokenApi {\n  typedefNodes: TypedefNode[]\n  getPalletEntryPoint: (\n    opType: OpType,\n    pallet: string,\n    name: string,\n  ) => EntryPoint\n  getApiEntryPoint: (name: string, method: string) => EntryPoint\n}\nconst compatibilityTokenApi = new WeakMap<\n  CompatibilityToken,\n  CompatibilityTokenApi\n>()\nconst runtimeTokenApi = new WeakMap<RuntimeToken, RuntimeTokenApi>()\nexport const getCompatibilityApi = (\n  token: RuntimeToken | CompatibilityToken,\n): RuntimeTokenApi | CompatibilityTokenApi =>\n  token instanceof RuntimeToken\n    ? runtimeTokenApi.get(token)!\n    : compatibilityTokenApi.get(token)!\n\nexport const enum OpType {\n  Storage = \"storage\",\n  Tx = \"tx\",\n  Event = \"events\",\n  Const = \"constants\",\n}\n\nconst EntryPointsCodec = Vector(EntryPointCodec)\nconst TypedefsCodec = Vector(TypedefCodec)\nconst TypesCodec = Tuple(EntryPointsCodec, TypedefsCodec)\n\nexport const createCompatibilityToken = <D extends ChainDefinition>(\n  chainDefinition: D,\n  chainHead: ChainHead$,\n): Promise<CompatibilityToken<D>> => {\n  const awaitedRuntime = new Promise<() => RuntimeContext>(async (resolve) => {\n    const loadedRuntime$ = chainHead.runtime$.pipe(filter((v) => v != null))\n\n    let latest = await firstValueFrom(loadedRuntime$)\n    loadedRuntime$.subscribe((v) => (latest = v))\n\n    resolve(() => latest)\n  })\n\n  const promise = Promise.all([\n    chainDefinition.metadataTypes.then(TypesCodec.dec),\n    chainDefinition.descriptors,\n    awaitedRuntime,\n  ]).then(([[entryPoints, typedefNodes], descriptors, runtime]) => {\n    const token = new (CompatibilityToken as any)()\n    compatibilityTokenApi.set(token, {\n      runtime,\n      getPalletEntryPoint(opType, pallet, name) {\n        const idx = descriptors[opType]?.[pallet]?.[name]\n        if (idx == null)\n          throw new Error(\n            `Descriptor for ${opType} ${pallet}.${name} does not exist`,\n          )\n        return entryPoints[idx]\n      },\n      getApiEntryPoint(name, method) {\n        const idx = descriptors.apis?.[name]?.[method]\n        if (idx == null)\n          throw new Error(`Descriptor for API ${name}.${method} does not exist`)\n        return entryPoints[idx]\n      },\n      typedefNodes,\n    })\n\n    return token\n  })\n\n  return promise\n}\n\nexport const createRuntimeToken = <D>(\n  chainHead: ChainHead$,\n): Promise<RuntimeToken<D>> => {\n  const awaitedRuntime = new Promise<() => RuntimeContext>(async (resolve) => {\n    const loadedRuntime$ = chainHead.runtime$.pipe(filter((v) => v != null))\n\n    let latest = await firstValueFrom(loadedRuntime$)\n    loadedRuntime$.subscribe((v) => (latest = v))\n\n    resolve(() => latest)\n  })\n\n  const promise = awaitedRuntime.then((runtime) => {\n    const token = new (RuntimeToken as any)()\n    runtimeTokenApi.set(token, {\n      runtime,\n    })\n    return token\n  })\n\n  return promise\n}\n\n// metadataRaw -> cache\nconst metadataCache = new WeakMap<\n  Uint8Array,\n  {\n    compat: CompatibilityCache\n    lookup: MetadataLookup\n    typeNodes: (TypedefNode | null)[]\n  }\n>()\nconst getMetadataCache = (ctx: RuntimeContext) => {\n  if (!metadataCache.has(ctx.metadataRaw)) {\n    metadataCache.set(ctx.metadataRaw, {\n      compat: new Map(),\n      lookup: ctx.lookup,\n      typeNodes: [],\n    })\n  }\n  return metadataCache.get(ctx.metadataRaw)!\n}\nexport const compatibilityHelper = (\n  descriptors: Promise<RuntimeToken | CompatibilityToken>,\n  getDescriptorEntryPoint: (descriptorApi: CompatibilityTokenApi) => EntryPoint,\n  getRuntimeEntryPoint: (ctx: RuntimeContext) => EntryPoint | null,\n) => {\n  const getRuntimeTypedef = (ctx: RuntimeContext, id: number) => {\n    const cache = getMetadataCache(ctx)\n    return (cache.typeNodes[id] ||= mapLookupToTypedef(cache.lookup(id)))\n  }\n\n  function getCompatibilityLevels(\n    descriptors: CompatibilityToken | RuntimeToken,\n    /**\n     * The `Runtime` of runtimeWithDescriptors already has a RuntimeContext,\n     * which is the runtime of the finalized block.\n     * But on some cases, the user wants to perform an action on a specific\n     * block hash, which has a different RuntimeContext.\n     */\n    ctx?: RuntimeContext,\n  ) {\n    if (descriptors instanceof RuntimeToken) {\n      return {\n        args: CompatibilityLevel.Identical,\n        values: CompatibilityLevel.Identical,\n      }\n    }\n    const compatibilityApi = compatibilityTokenApi.get(descriptors)!\n    ctx ||= compatibilityApi.runtime()\n    const descriptorEntryPoint = getDescriptorEntryPoint(compatibilityApi)\n    const runtimeEntryPoint = getRuntimeEntryPoint(ctx)\n    if (runtimeEntryPoint == null)\n      return {\n        args: CompatibilityLevel.Incompatible,\n        values: CompatibilityLevel.Incompatible,\n      }\n    const descriptorNodes = compatibilityApi.typedefNodes\n\n    const cache = getMetadataCache(ctx)\n\n    return entryPointsAreCompatible(\n      descriptorEntryPoint,\n      (id) => descriptorNodes[id],\n      runtimeEntryPoint,\n      (id) => getRuntimeTypedef(ctx, id),\n      cache.compat,\n    )\n  }\n\n  const getCompatibilityLevel = withOptionalToken(descriptors, (runtime) =>\n    minCompatLevel(getCompatibilityLevels(runtime)),\n  )\n  const isCompatible = withOptionalToken(\n    descriptors,\n    (threshold: CompatibilityLevel, runtime) =>\n      getCompatibilityLevel(runtime) >= threshold,\n  )\n\n  const compatibleRuntime$ = (chainHead: ChainHead$, hash: string | null) =>\n    combineLatest([descriptors, chainHead.getRuntimeContext$(hash)])\n\n  const withCompatibleRuntime =\n    <T>(chainHead: ChainHead$, mapper: (x: T) => string) =>\n    (\n      source$: Observable<T>,\n    ): Observable<[T, CompatibilityToken | RuntimeToken, RuntimeContext]> =>\n      combineLatest([\n        source$.pipe(chainHead.withRuntime(mapper)),\n        descriptors,\n      ]).pipe(map(([[x, ctx], descriptors]) => [x, descriptors, ctx]))\n\n  const argsAreCompatible = (\n    descriptors: CompatibilityToken | RuntimeToken,\n    ctx: RuntimeContext,\n    args: unknown,\n  ) => {\n    if (descriptors instanceof RuntimeToken) return true\n    const levels = getCompatibilityLevels(descriptors, ctx)\n    if (levels.args === CompatibilityLevel.Incompatible) return false\n    if (levels.args > CompatibilityLevel.Partial) return true\n    // Although technically args could still be compatible, if the output will be incompatible we might as well just return false to skip sending the request.\n    if (levels.values === CompatibilityLevel.Incompatible) return false\n\n    const entryPoint = getRuntimeEntryPoint(ctx)\n    if (entryPoint == null) return false\n\n    return valueIsCompatibleWithDest(\n      entryPoint.args,\n      (id) => getRuntimeTypedef(ctx, id),\n      args,\n    )\n  }\n  const valuesAreCompatible = (\n    descriptors: CompatibilityToken | RuntimeToken,\n    ctx: RuntimeContext,\n    values: unknown,\n  ) => {\n    if (descriptors instanceof RuntimeToken) return true\n    const level = getCompatibilityLevels(descriptors, ctx).values\n    if (level === CompatibilityLevel.Incompatible) return false\n    if (level > CompatibilityLevel.Partial) return true\n\n    const compatibilityApi = compatibilityTokenApi.get(descriptors)!\n\n    const entryPoint = getDescriptorEntryPoint(compatibilityApi)\n\n    return valueIsCompatibleWithDest(\n      entryPoint.values,\n      (id) => compatibilityApi.typedefNodes[id],\n      values,\n    )\n  }\n\n  return {\n    isCompatible,\n    getCompatibilityLevel,\n    getCompatibilityLevels,\n    descriptors,\n    withCompatibleRuntime,\n    compatibleRuntime$,\n    argsAreCompatible,\n    valuesAreCompatible,\n    getRuntimeTypedef,\n  }\n}\nexport type CompatibilityHelper = ReturnType<typeof compatibilityHelper>\n\nexport const minCompatLevel = (levels: {\n  args: CompatibilityLevel\n  values: CompatibilityLevel\n}) => Math.min(levels.args, levels.values)\n\nconst withOptionalToken =\n  <T, D, A extends [...any[], CompatibilityToken | RuntimeToken]>(\n    compatibilityToken: Promise<CompatibilityToken<D> | RuntimeToken<D>>,\n    fn: (...args: A) => T,\n  ): WithOptionalRuntime<T, D, A extends [...infer R, any] ? R : []> =>\n  (...args: any): any => {\n    const lastElement = args.at(-1)\n    if (\n      lastElement instanceof CompatibilityToken ||\n      lastElement instanceof RuntimeToken\n    ) {\n      return fn(...args)\n    }\n    return compatibilityToken.then((token) => (fn as any)(...args, token))\n  }\n\nexport type WithOptionalRuntime<T, D, A extends any[]> = {\n  /**\n   * Returns the result after waiting for the runtime to load.\n   */\n  (...args: A): Promise<T>\n  /**\n   * Returns the result synchronously with the loaded runtime.\n   */\n  (...args: [...A, runtime: CompatibilityToken<D> | RuntimeToken<D>]): T\n}\n\nexport interface CompatibilityFunctions<D> {\n  /**\n   * Returns the `CompatibilityLevel` for this call comparing the descriptors\n   * generated on dev time with the current live metadata.\n   */\n  getCompatibilityLevel(): Promise<CompatibilityLevel>\n  /**\n   * Returns the `CompatibilityLevel` for this call comparing the descriptors\n   * generated on dev time with the current live metadata.\n   *\n   * @param compatibilityToken  CompatibilityToken awaited from\n   *                            typedApi.compatibilityToken.\n   */\n  getCompatibilityLevel(\n    compatibilityToken: CompatibilityToken<D>,\n  ): CompatibilityLevel\n\n  /**\n   * Returns whether this call is compatible based on the CompatibilityLevel\n   * threshold.\n   *\n   * @param threshold  CompatibilityLevel threshold to use, inclusive.\n   */\n  isCompatible(threshold: CompatibilityLevel): Promise<boolean>\n\n  /**\n   * Returns whether this call is compatible based on the CompatibilityLevel\n   * threshold.\n   *\n   * @param threshold           CompatibilityLevel threshold to use,\n   *                            inclusive.\n   * @param compatibilityToken  CompatibilityToken awaited from\n   *                            typedApi.compatibilityToken.\n   */\n  isCompatible(\n    threshold: CompatibilityLevel,\n    compatibilityToken: CompatibilityToken<D>,\n  ): boolean\n}\n","import { RuntimeContext } from \"@polkadot-api/observable-client\"\nimport {\n  CompatibilityFunctions,\n  CompatibilityHelper,\n  CompatibilityToken,\n  getCompatibilityApi,\n  RuntimeToken,\n} from \"./compatibility\"\n\nexport type ConstantEntry<Unsafe, D, T> = Unsafe extends true\n  ? {\n      /**\n       * Constants are simple key-value structures found in the runtime\n       * metadata.\n       *\n       * @returns Promise that will resolve in the value of the constant.\n       */\n      (): Promise<T>\n      /**\n       * @param runtimeToken  Token from got with `await\n       *                      typedApi.runtimeToken`\n       * @returns Synchronously returns value of the constant.\n       */\n      (runtimeToken: RuntimeToken): T\n    }\n  : {\n      /**\n       * Constants are simple key-value structures found in the runtime\n       * metadata.\n       *\n       * @returns Promise that will resolve in the value of the constant.\n       */\n      (): Promise<T>\n      /**\n       * @param compatibilityToken  Token from got with `await\n       *                            typedApi.compatibilityToken`\n       * @returns Synchronously returns value of the constant.\n       */\n      (compatibilityToken: CompatibilityToken): T\n    } & CompatibilityFunctions<D>\n\nexport const createConstantEntry = <D, T>(\n  palletName: string,\n  name: string,\n  {\n    valuesAreCompatible,\n    descriptors,\n    isCompatible,\n    getCompatibilityLevel,\n  }: CompatibilityHelper,\n): ConstantEntry<any, D, T> => {\n  const cachedResults = new WeakMap<RuntimeContext, T>()\n  const getValueWithContext = (ctx: RuntimeContext) => {\n    if (cachedResults.has(ctx)) {\n      return cachedResults.get(ctx)!\n    }\n\n    const pallet = ctx.lookup.metadata.pallets.find(\n      (p) => p.name === palletName,\n    )\n    const constant = pallet?.constants.find((c) => c.name === name)\n    if (constant == null)\n      throw new Error(`Runtime entry Constant(${palletName}.${name}) not found`)\n    const result = ctx.dynamicBuilder\n      .buildConstant(palletName, name)\n      .dec(constant.value)\n    cachedResults.set(ctx, result)\n    return result\n  }\n\n  const fn = (token?: CompatibilityToken | RuntimeToken): any => {\n    if (token) {\n      const ctx = getCompatibilityApi(token).runtime()\n      const value = getValueWithContext(ctx)\n      if (!valuesAreCompatible(token, ctx, value))\n        throw new Error(\n          `Incompatible runtime entry Constant(${palletName}.${name})`,\n        )\n      return value\n    }\n    return descriptors.then(fn)\n  }\n\n  return Object.assign(fn, { isCompatible, getCompatibilityLevel })\n}\n","import { Observable, ReplaySubject, share } from \"rxjs\"\n\nexport const shareLatest: <T>(base: Observable<T>) => Observable<T> = share({\n  connector: () => new ReplaySubject(1),\n  resetOnError: true,\n  resetOnComplete: true,\n  resetOnRefCountZero: true,\n})\n","import { AbortError } from \"@polkadot-api/utils\"\nimport { Observable, Subscription, noop } from \"rxjs\"\n\nexport function firstValueFromWithSignal<T>(\n  source: Observable<T>,\n  signal?: AbortSignal,\n): Promise<T> {\n  return new Promise((resolve, reject) => {\n    let subscription: Subscription | null = null\n    let isDone = false\n\n    const onAbort = signal\n      ? () => {\n          subscription?.unsubscribe()\n          reject(new AbortError())\n        }\n      : noop\n\n    subscription = source.subscribe({\n      next: (value) => {\n        resolve(value)\n        subscription?.unsubscribe()\n        isDone = true\n      },\n      error: (e) => {\n        signal?.removeEventListener(\"abort\", onAbort)\n        reject(e)\n        isDone = true\n      },\n      complete: () => {\n        signal?.removeEventListener(\"abort\", onAbort)\n        reject(new Error(\"Observable completed without emitting\"))\n        isDone = true\n      },\n    })\n\n    // the observable could have emitted synchronously\n    if (!isDone) signal?.addEventListener(\"abort\", onAbort)\n  })\n}\n","import { Observable, Subscription } from \"rxjs\"\n\nconst EMPTY_VALUE = Symbol(\"EMPTY_VALUE\")\ntype EMPTY_VALUE = typeof EMPTY_VALUE\n\nexport const lossLessExhaustMap =\n  <I, O>(mapper: (x: I, idx: number) => Observable<O>) =>\n  (source$: Observable<I>): Observable<O> =>\n    new Observable((observer) => {\n      let idx = 0\n      let innerSubscription: Subscription | null = null\n      let queuedValue: I | EMPTY_VALUE = EMPTY_VALUE\n      let isOutterDone = false\n\n      const setInnerSubscription = () => {\n        const observable = mapper(queuedValue as I, idx++)\n        queuedValue = EMPTY_VALUE\n        innerSubscription = observable.subscribe({\n          next(vv) {\n            observer.next(vv)\n          },\n          error(ee) {\n            observer.error(ee)\n          },\n          complete() {\n            if (queuedValue !== EMPTY_VALUE) setInnerSubscription()\n            else {\n              innerSubscription = null\n              if (isOutterDone) observer.complete()\n            }\n          },\n        })\n      }\n\n      const subscription = source$.subscribe({\n        next(v) {\n          queuedValue = v\n          if (!innerSubscription) setInnerSubscription()\n        },\n        error(e) {\n          observer.error(e)\n        },\n        complete() {\n          if (!innerSubscription) observer.complete()\n          isOutterDone = true\n        },\n      })\n\n      return () => {\n        innerSubscription?.unsubscribe()\n        subscription.unsubscribe()\n      }\n    })\n","import { Observable } from \"rxjs\"\n\nlet NOTIN = {}\nexport const continueWith =\n  <I, O>(\n    mapper: (input: I) => Observable<O>,\n  ): ((source: Observable<I>) => Observable<I | O>) =>\n  (source) =>\n    new Observable((observer) => {\n      let latestValue: I = NOTIN as I\n      let subscription = source.subscribe({\n        next(v) {\n          observer.next((latestValue = v))\n        },\n        error(e) {\n          observer.error(e)\n        },\n        complete() {\n          if (latestValue === NOTIN) observer.complete()\n          else subscription = mapper(latestValue).subscribe(observer)\n        },\n      })\n\n      return () => {\n        subscription.unsubscribe()\n      }\n    })\n","export const isOptionalArg = (lastArg: unknown) =>\n  typeof lastArg === \"object\" &&\n  lastArg !== null &&\n  Object.entries(lastArg).every(\n    ([k, v]) =>\n      (k === \"at\" && (v === undefined || typeof v === \"string\")) ||\n      (k === \"signal\" && (v === undefined || v instanceof AbortSignal)),\n  )\n","import {\n  Observable,\n  Subject,\n  MonoTypeOperatorFunction,\n  BehaviorSubject,\n} from \"rxjs\"\nimport { switchAll, tap } from \"rxjs/operators\"\n\n/**\n * A creation operator that helps at creating observables that have circular\n * dependencies.\n *\n * @returns\n */\nexport const selfDependent = <T>(): [\n  Observable<T>,\n  () => MonoTypeOperatorFunction<T>,\n] => {\n  const activeSubject: BehaviorSubject<Subject<T>> = new BehaviorSubject(\n    new Subject<T>(),\n  )\n  return [\n    activeSubject.pipe(switchAll()),\n    () =>\n      tap({\n        next: (v) => activeSubject.value.next(v),\n        error: (e) => {\n          activeSubject.value.error(e)\n          activeSubject.next(new Subject<T>())\n        },\n        complete: () => {\n          activeSubject.value.complete()\n          activeSubject.next(new Subject<T>())\n        },\n      }) as MonoTypeOperatorFunction<T>,\n  ]\n}\n","import { Observable, firstValueFrom, map, mergeMap } from \"rxjs\"\nimport { BlockInfo, ChainHead$ } from \"@polkadot-api/observable-client\"\nimport { CompatibilityFunctions, CompatibilityHelper } from \"./compatibility\"\nimport { concatMapEager, shareLatest } from \"./utils\"\n\nexport type EventPhase =\n  | { type: \"ApplyExtrinsic\"; value: number }\n  | { type: \"Finalization\" }\n  | { type: \"Initialization\" }\n\nexport type EvWatch<T> = (filter?: (value: T) => boolean) => Observable<{\n  meta: {\n    block: BlockInfo\n    phase: EventPhase\n  }\n  payload: T\n}>\n\nexport type EvPull<T> = () => Promise<\n  Array<{\n    meta: {\n      block: BlockInfo\n      phase: EventPhase\n    }\n    payload: T\n  }>\n>\n\nexport type EvFilter<T> = (collection: SystemEvent[\"event\"][]) => Array<T>\n\nexport type EvClient<Unsafe, D, T> = {\n  /**\n   * Multicast and stateful Observable watching for new events (matching the\n   * event kind chosen) in the latest known `finalized` block.\n   *\n   * @param filter  Optional filter function to only emit events complying\n   *                with the function.\n   */\n  watch: EvWatch<T>\n  /**\n   * Fetch (Promise-based) all events (matching the event kind chosen) available\n   * in the latest known `finalized` block.\n   */\n  pull: EvPull<T>\n  /**\n   * Filter a bunch of `SystemEvent` and return the decoded `payload` of every\n   * of them.\n   *\n   * @param collection  Array of `SystemEvent` to filter.\n   */\n  filter: EvFilter<T>\n} & (Unsafe extends true ? {} : CompatibilityFunctions<D>)\n\ntype SystemEvent = {\n  phase: EventPhase\n  event: {\n    type: string\n    value: {\n      type: string\n      value: any\n    }\n  }\n  topics: Array<any>\n}\n\nexport const createEventEntry = <D, T>(\n  pallet: string,\n  name: string,\n  chainHead: ChainHead$,\n  {\n    isCompatible,\n    getCompatibilityLevel,\n    withCompatibleRuntime,\n    argsAreCompatible,\n    valuesAreCompatible,\n  }: CompatibilityHelper,\n): EvClient<any, D, T> => {\n  const compatibilityError = () =>\n    new Error(`Incompatible runtime entry Event(${pallet}.${name})`)\n\n  const shared$ = chainHead.finalized$.pipe(\n    withCompatibleRuntime(chainHead, (x) => x.hash),\n    map(([block, runtime, ctx]) => {\n      const eventsIdx = ctx.lookup.metadata.pallets.find(\n        (p) => p.name === pallet,\n      )?.events\n      if (\n        eventsIdx == null ||\n        ctx.lookup.metadata.lookup[eventsIdx].def.tag !== \"variant\" ||\n        ctx.lookup.metadata.lookup[eventsIdx].def.value.find(\n          (ev) => ev.name === name,\n        ) == null\n      )\n        throw new Error(`Runtime entry Event(${pallet}.${name}) not found`)\n\n      if (!argsAreCompatible(runtime, ctx, null)) throw compatibilityError()\n      return [block, runtime, ctx] as const\n    }),\n    concatMapEager(([block, runtime, ctx]) =>\n      chainHead.eventsAt$(block.hash).pipe(\n        map((events) => {\n          const winners = events.filter(\n            (e) => e.event.type === pallet && e.event.value.type === name,\n          )\n          return winners.map((x) => {\n            if (!valuesAreCompatible(runtime, ctx, x.event.value.value))\n              throw compatibilityError()\n            return {\n              meta: {\n                phase: x.phase,\n                block,\n              },\n              payload: x.event.value.value,\n            }\n          })\n        }),\n      ),\n    ),\n    shareLatest,\n  )\n\n  const watch: EvWatch<T> = (f) =>\n    shared$.pipe(mergeMap((x) => (f ? x.filter((d) => f(d.payload)) : x)))\n\n  const pull: EvPull<T> = () => firstValueFrom(shared$)\n\n  const filter: EvFilter<T> = (events) =>\n    events\n      .filter((e) => e.type === pallet && e.value.type === name)\n      .map((x) => x.value.value)\n\n  return { watch, pull, filter, getCompatibilityLevel, isCompatible }\n}\n","import { firstValueFromWithSignal, isOptionalArg } from \"@/utils\"\nimport { ChainHead$ } from \"@polkadot-api/observable-client\"\nimport { toHex } from \"@polkadot-api/utils\"\nimport { map, mergeMap } from \"rxjs\"\nimport { CompatibilityFunctions, CompatibilityHelper } from \"./compatibility\"\n\ntype CallOptions = Partial<{\n  at: string\n  signal: AbortSignal\n}>\n\ntype WithCallOptions<Args extends Array<any>> = Args[\"length\"] extends 0\n  ? [options?: CallOptions]\n  : [...args: Args, options?: CallOptions]\n\nexport type RuntimeCall<Unsafe, D, Args extends Array<any>, Payload> = {\n  /**\n   * Get `Payload` (Promise-based) for the runtime call.\n   *\n   * @param args  All keys needed for that runtime call.\n   *              At the end, optionally set which block to target (latest\n   *              known finalized is the default) and an AbortSignal.\n   */\n  (...args: WithCallOptions<Args>): Promise<Payload>\n} & (Unsafe extends true ? {} : CompatibilityFunctions<D>)\n\nexport const createRuntimeCallEntry = (\n  api: string,\n  method: string,\n  chainHead: ChainHead$,\n  {\n    isCompatible,\n    getCompatibilityLevel,\n    compatibleRuntime$,\n    argsAreCompatible,\n    valuesAreCompatible,\n  }: CompatibilityHelper,\n): RuntimeCall<any, any, any, any> => {\n  const callName = `${api}_${method}`\n  const compatibilityError = () =>\n    new Error(`Incompatible runtime entry RuntimeCall(${callName})`)\n\n  const fn = (...args: Array<any>) => {\n    const lastArg = args[args.length - 1]\n    const isLastArgOptional = isOptionalArg(lastArg)\n    const { signal, at: _at }: CallOptions = isLastArgOptional ? lastArg : {}\n    const at = _at ?? null\n\n    const result$ = compatibleRuntime$(chainHead, at).pipe(\n      mergeMap(([runtime, ctx]) => {\n        let codecs\n        try {\n          codecs = ctx.dynamicBuilder.buildRuntimeCall(api, method)\n        } catch {\n          throw new Error(`Runtime entry RuntimeCall(${callName}) not found`)\n        }\n        if (!argsAreCompatible(runtime, ctx, args)) throw compatibilityError()\n        return chainHead.call$(at, callName, toHex(codecs.args.enc(args))).pipe(\n          map(codecs.value.dec),\n          map((value) => {\n            if (!valuesAreCompatible(runtime, ctx, value))\n              throw compatibilityError()\n            return value\n          }),\n        )\n      }),\n    )\n\n    return firstValueFromWithSignal(result$, signal)\n  }\n\n  return Object.assign(fn, { getCompatibilityLevel, isCompatible })\n}\n","import {\n  firstValueFromWithSignal,\n  isOptionalArg,\n  lossLessExhaustMap,\n} from \"@/utils\"\nimport { CompatibilityLevel } from \"@polkadot-api/metadata-compatibility\"\nimport {\n  BlockInfo,\n  ChainHead$,\n  NotBestBlockError,\n  RuntimeContext,\n} from \"@polkadot-api/observable-client\"\nimport { FixedSizeBinary } from \"@polkadot-api/substrate-bindings\"\nimport { StorageItemInput, StorageResult } from \"@polkadot-api/substrate-client\"\nimport {\n  Observable,\n  OperatorFunction,\n  combineLatestWith,\n  distinctUntilChanged,\n  filter,\n  from,\n  identity,\n  map,\n  mergeMap,\n  pipe,\n  shareReplay,\n  take,\n} from \"rxjs\"\nimport {\n  CompatibilityFunctions,\n  CompatibilityHelper,\n  minCompatLevel,\n} from \"./compatibility\"\nimport { createWatchEntries } from \"./watch-entries\"\n\ntype CallOptions = Partial<{\n  /**\n   * `at` could be a blockHash, `best`, or `finalized` (default)\n   */\n  at: string\n  /**\n   * `signal` allows you to abort an ongoing Promise. See [MDN\n   * docs](https://developer.mozilla.org/en-US/docs/Web/API/AbortSignal) for\n   * more information\n   */\n  signal: AbortSignal\n}>\n\ntype WithCallOptions<Args extends Array<any>> = [\n  ...args: Args,\n  options?: CallOptions,\n]\n\ntype WithWatchOptions<Args extends Array<any>> = [\n  ...args: Args,\n  options?: { at: \"best\" },\n]\n\ntype PossibleParents<A extends Array<any>> = A extends [...infer Left, any]\n  ? Left | PossibleParents<Left>\n  : ArrayPossibleParents<A>\n\n// Fixed-size arrays values can't be extracted one-by-one, so that's a specific case\ntype ArrayPossibleParents<\n  A extends Array<any>,\n  Count extends Array<any> = [],\n  R = [],\n> = A extends Array<infer T> & { length: infer L }\n  ? number extends L\n    ? Array<T> // Case variable-size array it's an unknown amount of entries\n    : L extends Count[\"length\"]\n      ? R\n      : ArrayPossibleParents<A, [...Count, T], R | Count>\n  : never\n\ntype StorageEntryWithoutKeys<Unsafe, D, Payload> = {\n  /**\n   * Get `Payload` (Promise-based) for the storage entry.\n   *\n   * @param options  Optionally set which block to target (latest known\n   *                 finalized is the default) and an AbortSignal.\n   */\n  getValue: (options?: CallOptions) => Promise<Payload>\n  /**\n   * Watch changes in `Payload` (observable-based) for the storage entry.\n   *\n   * @param bestOrFinalized  Optionally choose which block to query and watch\n   *                         changes, `best` or `finalized` (default)\n   */\n  watchValue: (bestOrFinalized?: \"best\" | \"finalized\") => Observable<Payload>\n} & (Unsafe extends true ? {} : CompatibilityFunctions<D>)\n\nexport type StorageEntryWithKeys<\n  Unsafe,\n  D,\n  Args extends Array<any>,\n  Payload,\n  ArgsOut extends Array<any>,\n> = {\n  /**\n   * Get `Payload` (Promise-based) for the storage entry with a specific set of\n   * `Args`.\n   *\n   * @param args  All keys needed for that storage entry.\n   *              At the end, optionally set which block to target (latest\n   *              known finalized is the default) and an AbortSignal.\n   */\n  getValue: (...args: [...WithCallOptions<Args>]) => Promise<Payload>\n  /**\n   * Watch changes in `Payload` (observable-based) for the storage entry.\n   *\n   * @param args  All keys needed for that storage entry.\n   *              At the end, optionally choose which block to query and\n   *              watch changes, `best` or `finalized` (default)\n   */\n  watchValue: (\n    ...args: [...Args, bestOrFinalized?: \"best\" | \"finalized\"]\n  ) => Observable<Payload>\n  /**\n   * Get an Array of `Payload` (Promise-based) for the storage entry with\n   * several sets of `Args`.\n   *\n   * @param keys     Array of sets of keys needed for the storage entry.\n   * @param options  Optionally set which block to target (latest known\n   *                 finalized is the default) and an AbortSignal.\n   */\n  getValues: (\n    keys: Array<[...Args]>,\n    options?: CallOptions,\n  ) => Promise<Array<Payload>>\n  /**\n   * Get an Array of `Payload` (Promise-based) for the storage entry with a\n   * subset of `Args`.\n   *\n   * @param args  Subset of keys needed for the storage entry.\n   *              At the end, optionally set which block to target (latest\n   *              known finalized is the default) and an AbortSignal.\n   * @example\n   *\n   *   // this is a query with 3 keys\n   *   typedApi.query.Pallet.Query.getEntries({ at: \"best\" }) // no keys\n   *   typedApi.query.Pallet.Query.getEntries(arg1, { at: \"finalized\" }) // 1/3 keys\n   *   typedApi.query.Pallet.Query.getEntries(arg1, arg2, { at: \"0x12345678\" }) // 2/3 keys\n   *\n   */\n  getEntries: (\n    ...args: WithCallOptions<PossibleParents<Args>>\n  ) => Promise<Array<{ keyArgs: ArgsOut; value: NonNullable<Payload> }>>\n  /**\n   * Watch changes (Observable-based) for the storage entries with a subset of\n   * `Args`.\n   *\n   * @param args  Subset of keys needed for the storage entry.\n   *              At the end, optionally set whether to watch against the\n   *              `best` block.\n   *              By default watches changes against the finalized block.\n   *              When watching changes against the \"best\" block, this API\n   *              gratiously handles the re-orgs and provides the deltas\n   *              based on the latest emission.\n   *              The observed value contains the following properties:\n   *              - `block`: the block in where the `deltas` took place -\n   *              `deltas`: `null` indicates that nothing has changed from\n   *              the latest emission.\n   *              If the value is not `null` then the `deleted` and `upsrted`\n   *              properties indicate the entries that have changed.\n   *              - `entries`: it's an immutable data-structure with the\n   *              latest entries.\n   * @example\n   *\n   *   typedApi.query.Staking.Nominators.watchEntries()\n   *   typedApi.query.Staking.Nominators.watchEntries({ at: \"best\" })\n   *\n   */\n  watchEntries: (\n    ...args: WithWatchOptions<PossibleParents<Args>>\n  ) => Observable<{\n    block: BlockInfo\n    deltas: null | {\n      deleted: Array<{ args: ArgsOut; value: NonNullable<Payload> }>\n      upserted: Array<{ args: ArgsOut; value: NonNullable<Payload> }>\n    }\n    entries: Array<{ args: ArgsOut; value: NonNullable<Payload> }>\n  }>\n} & (Unsafe extends true ? {} : CompatibilityFunctions<D>)\n\nexport type StorageEntry<\n  Unsafe,\n  D,\n  Args extends Array<any>,\n  ArgsOut extends Array<any>,\n  Payload,\n> = Args extends []\n  ? StorageEntryWithoutKeys<Unsafe, D, Payload>\n  : StorageEntryWithKeys<Unsafe, D, Args, Payload, ArgsOut>\n\nexport type Storage$ = <Type extends StorageItemInput[\"type\"]>(\n  hash: string | null,\n  type: Type,\n  key: string,\n  childTrie: string | null,\n) => Observable<StorageResult<Type>>\n\nconst toMapped = map(<T>(x: { mapped: T }) => x.mapped)\nexport const createStorageEntry = (\n  pallet: string,\n  name: string,\n  chainHead: ChainHead$,\n  getWatchEntries: ReturnType<typeof createWatchEntries>,\n  {\n    isCompatible,\n    getCompatibilityLevel,\n    getCompatibilityLevels,\n    descriptors: descriptorsPromise,\n    argsAreCompatible,\n    valuesAreCompatible,\n  }: CompatibilityHelper,\n): StorageEntry<any, any, any, any, any> => {\n  const isSystemNumber = pallet === \"System\" && name === \"Number\"\n  const isBlockHash = pallet === \"System\" && name === \"BlockHash\"\n  const sysNumberMapper$ = chainHead.runtime$.pipe(\n    filter(Boolean),\n    take(1),\n    map(({ dynamicBuilder }) =>\n      typeof dynamicBuilder\n        .buildStorage(\"System\", \"Number\")\n        .value.dec(new Uint8Array(32)) === \"bigint\"\n        ? BigInt\n        : identity,\n    ),\n    shareReplay(),\n  )\n  const bigIntOrNumber: OperatorFunction<number, number | bigint> = pipe(\n    combineLatestWith(sysNumberMapper$),\n    map(([input, mapper]) => mapper(input)),\n  )\n\n  const incompatibleError = () =>\n    new Error(`Incompatible runtime entry Storage(${pallet}.${name})`)\n  const invalidArgs = (args: Array<any>) =>\n    new Error(`Invalid Arguments calling ${pallet}.${name}(${args})`)\n\n  const getCodec = (ctx: RuntimeContext) => {\n    try {\n      return ctx.dynamicBuilder.buildStorage(pallet, name)\n    } catch (e: any) {\n      throw new Error(`Runtime entry Storage(${pallet}.${name}) not found`)\n    }\n  }\n\n  const watchValue = (...args: Array<any>) => {\n    const target = args[args.length - 1]\n    const isBest = target === \"best\"\n    const actualArgs =\n      isBest || target === \"finalized\" ? args.slice(0, -1) : args\n\n    return chainHead[isBest ? \"best$\" : \"finalized$\"].pipe(\n      lossLessExhaustMap(() =>\n        getRawValue$(...actualArgs, isBest ? { at: \"best\" } : {}),\n      ),\n      distinctUntilChanged((a, b) => a.raw === b.raw),\n      toMapped,\n    )\n  }\n\n  const getRawValue$ = (...args: Array<any>) => {\n    const lastArg = args[args.length - 1]\n    const isLastArgOptional = isOptionalArg(lastArg)\n    const { at: _at }: CallOptions = isLastArgOptional ? lastArg : {}\n    const at = _at ?? null\n\n    if (isSystemNumber)\n      return chainHead.bestBlocks$.pipe(\n        map((blocks) => {\n          if (at === \"finalized\" || !at) return blocks.at(-1)\n          if (at === \"best\") return blocks.at(0)\n          return blocks.find((block) => block.hash === at)\n        }),\n        map((block) => {\n          if (!block) throw new NotBestBlockError()\n          return block.number\n        }),\n        distinctUntilChanged(),\n        bigIntOrNumber,\n        map((mapped) => ({ raw: mapped, mapped })),\n      )\n\n    if (isBlockHash && Number(args[0]) === 0) {\n      return chainHead.genesis$.pipe(\n        map((raw) => ({ raw, mapped: FixedSizeBinary.fromHex(raw) })),\n      ) as Observable<any>\n    }\n\n    return from(descriptorsPromise).pipe(\n      mergeMap((descriptors) =>\n        chainHead.storage$(\n          at,\n          \"value\",\n          (ctx) => {\n            const codecs = getCodec(ctx)\n            const actualArgs =\n              args.length === codecs.len ? args : args.slice(0, -1)\n            if (args !== actualArgs && !isLastArgOptional)\n              throw invalidArgs(args)\n            if (!argsAreCompatible(descriptors, ctx, actualArgs))\n              throw incompatibleError()\n            return codecs.keys.enc(...actualArgs)\n          },\n          null,\n          (data, ctx) => {\n            const codecs = getCodec(ctx)\n            const value =\n              data === null ? codecs.fallback : codecs.value.dec(data)\n            if (!valuesAreCompatible(descriptors, ctx, value))\n              throw incompatibleError()\n            return value\n          },\n        ),\n      ),\n    )\n  }\n\n  const getValue = async (...args: Array<any>) => {\n    const lastArg = args[args.length - 1]\n    const isLastArgOptional = isOptionalArg(lastArg)\n    const { signal }: CallOptions = isLastArgOptional ? lastArg : {}\n\n    return firstValueFromWithSignal(\n      getRawValue$(...args).pipe(toMapped),\n      signal,\n    )\n  }\n\n  const getEntries = async (...args: Array<any>) => {\n    const lastArg = args[args.length - 1]\n    const isLastArgOptional = isOptionalArg(lastArg)\n    const { signal, at: _at }: CallOptions = isLastArgOptional ? lastArg : {}\n    const at = _at ?? null\n\n    const descriptors = await descriptorsPromise\n    const result$ = chainHead\n      .storage$(\n        at,\n        \"descendantsValues\",\n        (ctx) => {\n          const codecs = getCodec(ctx)\n          // TODO partial compatibility check for args that become optional\n          if (\n            minCompatLevel(getCompatibilityLevels(descriptors, ctx)) ===\n            CompatibilityLevel.Incompatible\n          )\n            throw incompatibleError()\n\n          if (args.length > codecs.len) throw invalidArgs(args)\n          const actualArgs =\n            args.length > 0 && isLastArgOptional ? args.slice(0, -1) : args\n          if (args.length === codecs.len && actualArgs === args)\n            throw invalidArgs(args)\n          return codecs.keys.enc(...actualArgs)\n        },\n        null,\n        (values, ctx) => {\n          const codecs = getCodec(ctx)\n          const decodedValues = values.map(({ key, value }) => ({\n            keyArgs: codecs.keys.dec(key),\n            value: codecs.value.dec(value),\n          }))\n          if (\n            decodedValues.some(\n              ({ value }) => !valuesAreCompatible(descriptors, ctx, value),\n            )\n          )\n            throw incompatibleError()\n          return decodedValues\n        },\n      )\n      .pipe(toMapped)\n    return firstValueFromWithSignal(result$, signal)\n  }\n\n  const getValues = (keyArgs: Array<Array<any>>, options?: CallOptions) =>\n    Promise.all(\n      keyArgs.map((args) => getValue(...(options ? [...args, options] : args))),\n    )\n\n  const watchEntries: any = (...args: Array<any>) => {\n    const lastArg = args.at(-1)\n    const isLastArgOptional = isOptionalArg(lastArg)\n\n    return getWatchEntries(\n      pallet,\n      name,\n      isLastArgOptional ? args.slice(0, -1) : args,\n      isLastArgOptional && lastArg.at === \"best\",\n    )\n  }\n\n  return {\n    isCompatible,\n    getCompatibilityLevel,\n    getValue,\n    getValues,\n    getEntries,\n    watchValue,\n    watchEntries,\n  }\n}\n","import {\n  getDynamicBuilder,\n  MetadataLookup,\n} from \"@polkadot-api/metadata-builders\"\n\ntype DynamicBuilder = ReturnType<typeof getDynamicBuilder>\nexport const getSystemVersionStruct = (\n  lookupFn: MetadataLookup,\n  dynamicBuilder: DynamicBuilder,\n): Record<string, any> => {\n  const constant = lookupFn.metadata.pallets\n    .find((x) => x.name === \"System\")!\n    .constants!.find((s) => s.name === \"Version\")!\n\n  const systemVersion = lookupFn(constant.type)\n  const systemVersionDec = dynamicBuilder.buildDefinition(constant.type).dec\n\n  if (systemVersion.type !== \"struct\") throw new Error(\"not a struct\")\n  return systemVersionDec(constant.value)\n}\n","import { Bytes, enhanceEncoder, u16 } from \"@polkadot-api/substrate-bindings\"\n\nfunction trailingZeroes(n: number) {\n  let i = 0\n  while (!(n & 1)) {\n    i++\n    n >>= 1\n  }\n  return i\n}\n\nexport const mortal = enhanceEncoder(\n  Bytes(2)[0],\n  (value: { period: number; phase: number }) => {\n    const factor = Math.max(value.period >> 12, 1)\n    const left = Math.min(Math.max(trailingZeroes(value.period) - 1, 1), 15)\n    const right = (value.phase / factor) << 4\n    return u16[0](left | right)\n  },\n)\n","import {\n  Bytes,\n  compact,\n  Option,\n  Struct,\n} from \"@polkadot-api/substrate-bindings\"\n\nexport const [ChargeAssetTxPaymentEnc] = Struct({\n  tip: compact,\n  asset: Option(Bytes(Infinity)),\n})\n","import {\n  getDynamicBuilder,\n  MetadataLookup,\n} from \"@polkadot-api/metadata-builders\"\nimport { Encoder } from \"@polkadot-api/substrate-bindings\"\nimport { OfflineTxExtensions } from \"../types\"\nimport { fromHex, mapObject } from \"@polkadot-api/utils\"\nimport { getSystemVersionStruct } from \"./system-version\"\nimport { mortal } from \"./mortal-enc\"\nimport { ChargeAssetTxPaymentEnc } from \"./charge-asset-tx-enc\"\n\nconst empty = new Uint8Array()\nconst zero = Uint8Array.from([0])\ntype DynamicBuilder = ReturnType<typeof getDynamicBuilder>\n\nconst value = (value: Uint8Array) => ({\n  value,\n  additionalSigned: empty,\n})\nconst additionalSigned = (additionalSigned: Uint8Array) => ({\n  value: empty,\n  additionalSigned,\n})\nconst both = (value: Uint8Array, additionalSigned: Uint8Array) => ({\n  value,\n  additionalSigned,\n})\n\nexport const getSignExtensionsCreator = (\n  genesis: Uint8Array,\n  lookupFn: MetadataLookup,\n  dynamicBuilder: DynamicBuilder,\n) => {\n  const signedExtensionsEncoders: Record<string, [Encoder<any>, Encoder<any>]> =\n    {}\n  lookupFn.metadata.extrinsic.signedExtensions.forEach(\n    ({ identifier, type, additionalSigned }) => {\n      signedExtensionsEncoders[identifier] = [type, additionalSigned].map(\n        (x) => dynamicBuilder.buildDefinition(x)[0],\n      ) as [Encoder<any>, Encoder<any>]\n    },\n  )\n\n  return <Asset>({\n    mortality,\n    tip = 0n,\n    nonce,\n    customSignedExtensions = {},\n    ...rest\n  }: OfflineTxExtensions<Asset>): Record<\n    string,\n    { identifier: string; value: Uint8Array; additionalSigned: Uint8Array }\n  > => {\n    const invalidKeys: string[] = []\n    const systemVersion = getSystemVersionStruct(lookupFn, dynamicBuilder)\n    const getFromCustomEntry = (key: string) => {\n      const [valueEnc, additionalEnc] = signedExtensionsEncoders[key]\n      const customEntry = customSignedExtensions[key] as any\n      try {\n        return mapObject(\n          {\n            value: valueEnc,\n            additionalSigned: additionalEnc,\n          },\n          (encoder, key) => {\n            const input = customEntry?.[key]\n            // if the encoder is _void, then the input value is ignored, so no harm in passing `undefined`\n            // only an `Option` encoder will accept `undefined` as an input without crashing\n            return input instanceof Uint8Array ? input : encoder(input)\n          },\n        )\n      } catch {\n        // this means that a non optional custom signed-extension has not received its value\n        invalidKeys.push(key)\n        return null\n      }\n    }\n\n    const result = mapObject(\n      signedExtensionsEncoders,\n      ([valueEnc, additionalEnc], key) => {\n        if (customSignedExtensions[key]) return getFromCustomEntry(key)\n\n        switch (key) {\n          case \"CheckNonce\":\n            return value(valueEnc(nonce))\n\n          case \"CheckMortality\":\n            return mortality.mortal\n              ? both(\n                  mortal({\n                    period: mortality.period,\n                    phase: mortality.startAtBlock.height % mortality.period,\n                  }),\n                  fromHex(mortality.startAtBlock.hash),\n                )\n              : both(zero, genesis)\n\n          case \"ChargeTransactionPayment\":\n            return value(valueEnc(tip))\n\n          case \"ChargeAssetTxPayment\":\n            return value(\n              ChargeAssetTxPaymentEnc({\n                tip,\n                asset: (rest as any).asset,\n              }),\n            )\n\n          case \"CheckGenesis\":\n            return additionalSigned(genesis)\n\n          case \"CheckMetadataHash\":\n            return both(zero, zero)\n\n          case \"CheckSpecVersion\":\n            return additionalSigned(\n              additionalEnc(systemVersion[\"spec_version\"]),\n            )\n\n          case \"CheckTxVersion\":\n            return additionalSigned(\n              additionalEnc(systemVersion[\"transaction_version\"]),\n            )\n\n          default:\n            return getFromCustomEntry(key)\n        }\n      },\n    )\n\n    invalidKeys.forEach((key) => {\n      delete result[key]\n    })\n    return mapObject(result, (x, identifier) => ({ ...x, identifier })) as any\n  }\n}\n","import { HexString, u16, u32, u64, u8 } from \"@polkadot-api/substrate-bindings\"\nimport { Observable, combineLatest, map, mergeMap, of, take } from \"rxjs\"\nimport { BlockInfo, ChainHead$ } from \"@polkadot-api/observable-client\"\nimport type { PolkadotSigner } from \"@polkadot-api/polkadot-signer\"\nimport { _void } from \"@polkadot-api/substrate-bindings\"\nimport { CustomSignedExtensionValues } from \"./types\"\nimport { fromHex, toHex } from \"@polkadot-api/utils\"\nimport { getSignExtensionsCreator } from \"./signed-extensions\"\n\ntype HintedSignedExtensions = Partial<{\n  tip: bigint\n  mortality: { mortal: false } | { mortal: true; period: number }\n  asset: Uint8Array\n  nonce: number\n}>\n\nconst NONCE_RUNTIME_CALL = \"AccountNonceApi_account_nonce\"\nconst lenToDecoder = {\n  1: u8.dec,\n  2: u16.dec,\n  4: u32.dec,\n  8: u64.dec,\n}\n\nexport const getNonce$ = (\n  call$: ChainHead$[\"call$\"],\n  from: HexString,\n  at: string,\n) =>\n  call$(at, NONCE_RUNTIME_CALL, from).pipe(\n    map((result) => {\n      const bytes = fromHex(result)\n      const decoder = lenToDecoder[bytes.length as 2 | 4 | 8]\n      if (!decoder)\n        throw new Error(`${NONCE_RUNTIME_CALL} retrieved wrong data`)\n      return decoder(bytes)\n    }),\n  )\n\nexport const createTx: (\n  chainHead: ChainHead$,\n  signer: PolkadotSigner,\n  callData: Uint8Array,\n  atBlock: BlockInfo,\n  customSignExt: Record<string, CustomSignedExtensionValues>,\n  hinted?: HintedSignedExtensions,\n) => Observable<Uint8Array> = (\n  chainHead,\n  signer,\n  callData,\n  atBlock,\n  customSignedExtensions,\n  hinted = {},\n) =>\n  combineLatest([\n    hinted.nonce\n      ? of(hinted.nonce)\n      : getNonce$(chainHead.call$, toHex(signer.publicKey), atBlock.hash),\n    chainHead.getRuntimeContext$(atBlock.hash),\n    chainHead.genesis$,\n  ]).pipe(\n    take(1),\n    mergeMap(([nonce, ctx, genesis]) => {\n      const signExtCreator = getSignExtensionsCreator(\n        fromHex(genesis),\n        ctx.lookup,\n        ctx.dynamicBuilder,\n      )\n\n      const mortality: HintedSignedExtensions[\"mortality\"] =\n        hinted.mortality ?? { period: 64, mortal: true }\n\n      const signExtensions = signExtCreator({\n        nonce: nonce as number,\n        tip: hinted.tip ?? 0n,\n        mortality: mortality.mortal\n          ? {\n              mortal: true,\n              period: mortality.period,\n              startAtBlock: {\n                height: atBlock.number,\n                hash: atBlock.hash,\n              },\n            }\n          : { mortal: false },\n        customSignedExtensions,\n      })\n\n      return signer.signTx(\n        callData,\n        signExtensions,\n        ctx.metadataRaw,\n        atBlock.number,\n      )\n    }),\n  )\n","import {\n  Binary,\n  Blake2256,\n  HexString,\n  ResultPayload,\n} from \"@polkadot-api/substrate-bindings\"\nimport {\n  EMPTY,\n  Observable,\n  concat,\n  distinctUntilChanged,\n  filter,\n  lastValueFrom,\n  map,\n  mergeMap,\n  of,\n  take,\n} from \"rxjs\"\nimport {\n  ChainHead$,\n  PinnedBlocks,\n  SystemEvent,\n} from \"@polkadot-api/observable-client\"\nimport { AnalyzedBlock } from \"@polkadot-api/observable-client\"\nimport { TxEvent, TxEventsPayload, TxFinalizedPayload } from \"./types\"\nimport { continueWith } from \"@/utils\"\nimport { fromHex, toHex } from \"@polkadot-api/utils\"\n\n// TODO: make it dynamic based on the tx-function of the client\nconst hashFromTx = (tx: HexString) => toHex(Blake2256(fromHex(tx)))\n\nconst computeState = (\n  analized$: Observable<AnalyzedBlock>,\n  blocks$: Observable<PinnedBlocks>,\n) =>\n  new Observable<\n    | {\n        found: true\n        hash: string\n        number: number\n        index: number\n        events: any\n      }\n    | { found: false; validity: ResultPayload<any, any> | null }\n  >((observer) => {\n    const analyzedBlocks = new Map<string, AnalyzedBlock>()\n    let pinnedBlocks: PinnedBlocks\n    let latestState:\n      | {\n          found: true\n          hash: string\n          number: number\n          index: number\n          events: any\n        }\n      | { found: false; validity: ResultPayload<any, any> | null }\n\n    const computeNextState = () => {\n      let current: string = pinnedBlocks.best\n      let analyzed: AnalyzedBlock | undefined = analyzedBlocks.get(current)\n      let analyzedNumber = pinnedBlocks.blocks.get(current)!.number\n\n      while (!analyzed) {\n        const block = pinnedBlocks.blocks.get(current)\n        if (!block) break\n        analyzed = analyzedBlocks.get((current = block.parent))\n        analyzedNumber--\n      }\n\n      if (!analyzed) return // this shouldn't happen, though\n\n      const isFinalized =\n        analyzedNumber <=\n        pinnedBlocks.blocks.get(pinnedBlocks.finalized)!.number\n\n      const found = analyzed.found.type\n      if (found && latestState?.found && latestState.hash === analyzed.hash) {\n        if (isFinalized) observer.complete()\n        return\n      }\n\n      observer.next(\n        (latestState = analyzed.found.type\n          ? {\n              found: found as true,\n              hash: analyzed.hash,\n              number: analyzedNumber,\n              index: analyzed.found.index,\n              events: analyzed.found.events,\n            }\n          : {\n              found: found as false,\n              validity: analyzed.found.validity,\n            }),\n      )\n\n      if (isFinalized) {\n        if (found) observer.complete()\n        else if (analyzed.found.validity?.success === false)\n          observer.error(new InvalidTxError(analyzed.found.validity.value))\n      }\n    }\n\n    const subscription = blocks$\n      .pipe(\n        distinctUntilChanged(\n          (a, b) => a.finalized === b.finalized && a.best === b.best,\n        ),\n      )\n      .subscribe({\n        next: (pinned: PinnedBlocks) => {\n          pinnedBlocks = pinned\n          if (analyzedBlocks.size === 0) return\n          computeNextState()\n        },\n        error(e) {\n          observer.error(e)\n        },\n      })\n\n    subscription.add(\n      analized$.subscribe({\n        next: (block) => {\n          analyzedBlocks.set(block.hash, block)\n          computeNextState()\n        },\n        error(e) {\n          observer.error(e)\n        },\n      }),\n    )\n\n    return subscription\n  }).pipe(distinctUntilChanged((a, b) => a === b))\n\nconst getTxSuccessFromSystemEvents = (\n  systemEvents: Array<SystemEvent>,\n  txIdx: number,\n): Omit<TxEventsPayload, \"block\"> => {\n  const events = systemEvents\n    .filter((x) => x.phase.type === \"ApplyExtrinsic\" && x.phase.value === txIdx)\n    .map((x) => ({ ...x.event, topics: x.topics }))\n\n  const lastEvent = events[events.length - 1]\n  if (\n    lastEvent.type === \"System\" &&\n    lastEvent.value.type === \"ExtrinsicFailed\"\n  ) {\n    return {\n      ok: false,\n      events,\n      dispatchError: lastEvent.value.value.dispatch_error,\n    }\n  }\n\n  return { ok: true, events }\n}\n\n/*\ntype TransactionValidityError = Enum<{\n  Invalid: Enum<{\n    Call: undefined\n    Payment: undefined\n    Future: undefined\n    Stale: undefined\n    BadProof: undefined\n    AncientBirthBlock: undefined\n    ExhaustsResources: undefined\n    Custom: number\n    BadMandatory: undefined\n    MandatoryValidation: undefined\n    BadSigner: undefined\n  }>\n  Unknown: Enum<{\n    CannotLookup: undefined\n    NoUnsignedValidator: undefined\n    Custom: number\n  }>\n}>\n*/\n\nexport class InvalidTxError extends Error {\n  error: any // likely to be a `TransactionValidityError`\n  constructor(e: any) {\n    super(\n      JSON.stringify(\n        e,\n        (_, value) => {\n          if (typeof value === \"bigint\") return value.toString()\n          return value instanceof Binary ? value.asHex() : value\n        },\n        2,\n      ),\n    )\n    this.name = \"InvalidTxError\"\n    this.error = e\n  }\n}\n\nexport const submit$ = (\n  chainHead: ChainHead$,\n  broadcastTx$: (tx: string) => Observable<never>,\n  tx: HexString,\n  at?: HexString,\n  emitSign = false,\n): Observable<TxEvent> => {\n  const txHash = hashFromTx(tx)\n  const getTxEvent = <\n    Type extends TxEvent[\"type\"],\n    Rest extends Omit<TxEvent & { type: Type }, \"type\" | \"txHash\">,\n  >(\n    type: Type,\n    rest: Rest,\n  ): TxEvent & { type: Type } =>\n    ({\n      type,\n      txHash,\n      ...rest,\n    }) as any\n\n  const at$ = chainHead.pinnedBlocks$.pipe(\n    take(1),\n    map((blocks) => {\n      const block = blocks.blocks.get(at!)\n      return block && !block.unpinned ? block.hash : blocks.finalized\n    }),\n  )\n\n  const validate$: Observable<never> = at$.pipe(\n    mergeMap((at) =>\n      chainHead.validateTx$(at, tx).pipe(\n        filter((x) => !x.success),\n        map((x) => {\n          throw new InvalidTxError(x.value)\n        }),\n      ),\n    ),\n  )\n\n  const track$ = new Observable<AnalyzedBlock>((observer) => {\n    const subscription = chainHead.trackTx$(tx).subscribe(observer)\n    subscription.add(\n      broadcastTx$(tx).subscribe({\n        error(e) {\n          observer.error(e)\n        },\n      }),\n    )\n    return subscription\n  })\n\n  const bestBlockState$ = computeState(track$, chainHead.pinnedBlocks$).pipe(\n    map((x) => {\n      if (!x.found)\n        return getTxEvent(\"txBestBlocksState\", {\n          found: false,\n          isValid: x.validity?.success !== false,\n        })\n\n      return getTxEvent(\"txBestBlocksState\", {\n        found: true,\n        block: {\n          index: x.index,\n          number: x.number,\n          hash: x.hash,\n        },\n        ...getTxSuccessFromSystemEvents(x.events, x.index),\n      })\n    }),\n  )\n\n  return concat(\n    emitSign ? of(getTxEvent(\"signed\", {})) : EMPTY,\n    validate$,\n    of(getTxEvent(\"broadcasted\", {})),\n    bestBlockState$.pipe(\n      continueWith(({ found, type, ...rest }) =>\n        found ? of(getTxEvent(\"finalized\", rest as any)) : EMPTY,\n      ),\n    ),\n  )\n}\n\nexport const submit = async (\n  chainHead: ChainHead$,\n  broadcastTx$: (tx: string) => Observable<never>,\n  transaction: HexString,\n  at?: HexString,\n): Promise<TxFinalizedPayload> =>\n  lastValueFrom(submit$(chainHead, broadcastTx$, transaction, at)).then((x) => {\n    if (x.type !== \"finalized\") throw null\n    const result: TxFinalizedPayload = { ...x }\n    delete (result as any).type\n    return result\n  })\n","import type { BlockInfo, ChainHead$ } from \"@polkadot-api/observable-client\"\nimport { PolkadotSigner } from \"@polkadot-api/polkadot-signer\"\nimport { getPolkadotSigner } from \"@polkadot-api/signer\"\nimport {\n  _void,\n  AccountId,\n  Binary,\n  compactBn,\n  Decoder,\n  Enum,\n  Struct,\n  u128,\n  u32,\n  Variant,\n} from \"@polkadot-api/substrate-bindings\"\nimport { fromHex, mergeUint8, toHex } from \"@polkadot-api/utils\"\nimport {\n  Observable,\n  combineLatest,\n  firstValueFrom,\n  map,\n  mergeMap,\n  take,\n  throwError,\n} from \"rxjs\"\nimport { PlainDescriptor } from \"@/descriptors\"\nimport {\n  CompatibilityHelper,\n  CompatibilityToken,\n  getCompatibilityApi,\n  RuntimeToken,\n} from \"../compatibility\"\nimport { createTx } from \"./create-tx\"\nimport { InvalidTxError, submit, submit$ } from \"./submit-fns\"\nimport {\n  PaymentInfo,\n  TxCall,\n  TxEntry,\n  TxObservable,\n  TxOptions,\n  TxPromise,\n  TxSignFn,\n} from \"./types\"\nimport {\n  isCompatible,\n  mapLookupToTypedef,\n} from \"@polkadot-api/metadata-compatibility\"\n\nexport { submit, submit$, InvalidTxError }\n\nconst accountIdEnc = AccountId().enc\nconst fakeSignature = new Uint8Array(64)\nconst fakeSignatureEth = new Uint8Array(65)\nconst getFakeSignature = (isEth: boolean) => () =>\n  isEth ? fakeSignatureEth : fakeSignature\n\nconst [, queryInfoDecFallback] = Struct({\n  weight: Struct({\n    ref_time: compactBn,\n    proof_size: compactBn,\n  }),\n  class: Variant({\n    Normal: _void,\n    Operational: _void,\n    Mandatory: _void,\n  }),\n  partial_fee: u128,\n})\n\nexport const createTxEntry = <\n  D,\n  Arg extends {} | undefined,\n  Pallet extends string,\n  Name extends string,\n  Asset extends PlainDescriptor<any>,\n>(\n  pallet: Pallet,\n  name: Name,\n  chainHead: ChainHead$,\n  broadcast: (tx: string) => Observable<never>,\n  {\n    isCompatible: isCompatibleHelper,\n    getCompatibilityLevel,\n    compatibleRuntime$,\n    argsAreCompatible,\n    getRuntimeTypedef,\n  }: CompatibilityHelper,\n  checkCompatibility: boolean,\n): TxEntry<D, Arg, Pallet, Name, Asset> => {\n  const fn = (arg?: Arg): any => {\n    const getCallDataWithContext = (\n      runtime: CompatibilityToken | RuntimeToken,\n      arg: any,\n      txOptions: Partial<{ asset: any }> = {},\n    ) => {\n      const ctx = getCompatibilityApi(runtime).runtime()\n      const { dynamicBuilder, assetId, lookup } = ctx\n      let codecs\n      try {\n        codecs = dynamicBuilder.buildCall(pallet, name)\n      } catch {\n        throw new Error(`Runtime entry Tx(${pallet}.${name}) not found`)\n      }\n      if (checkCompatibility && !argsAreCompatible(runtime, ctx, arg))\n        throw new Error(`Incompatible runtime entry Tx(${pallet}.${name})`)\n\n      let returnOptions = txOptions\n      if (txOptions.asset) {\n        if (\n          assetId == null ||\n          !isCompatible(\n            txOptions.asset,\n            mapLookupToTypedef(lookup(assetId)),\n            (id) => getRuntimeTypedef(ctx, id),\n          )\n        )\n          throw new Error(`Incompatible runtime asset`)\n        returnOptions = {\n          ...txOptions,\n          asset: dynamicBuilder.buildDefinition(assetId).enc(txOptions.asset),\n        }\n      }\n\n      const { location, codec } = codecs\n      return {\n        callData: Binary.fromBytes(\n          mergeUint8(new Uint8Array(location), codec.enc(arg)),\n        ),\n        options: returnOptions,\n      }\n    }\n\n    const getCallData$ = (arg: any, options: Partial<{ asset: any }> = {}) =>\n      compatibleRuntime$(chainHead, null).pipe(\n        map(([runtime]) => getCallDataWithContext(runtime, arg, options)),\n      )\n\n    const getEncodedData: TxCall = (\n      token?: CompatibilityToken | RuntimeToken,\n    ): any => {\n      if (!token)\n        return firstValueFrom(getCallData$(arg).pipe(map((x) => x.callData)))\n\n      return getCallDataWithContext(token, arg).callData\n    }\n\n    const sign$ = (\n      from: PolkadotSigner,\n      { ..._options }: Omit<TxOptions<{}>, \"at\">,\n      atBlock: BlockInfo,\n    ) =>\n      getCallData$(arg, _options).pipe(\n        mergeMap(({ callData, options }) =>\n          createTx(\n            chainHead,\n            from,\n            callData.asBytes(),\n            atBlock,\n            _options.customSignedExtensions || {},\n            options,\n          ),\n        ),\n      )\n\n    const _sign = (\n      from: PolkadotSigner,\n      { at, ..._options }: TxOptions<{}> = {},\n    ) => {\n      return (\n        !at || at === \"finalized\"\n          ? chainHead.finalized$\n          : at === \"best\"\n            ? chainHead.best$\n            : chainHead.bestBlocks$.pipe(\n                map((x) => x.find((b) => b.hash === at)),\n              )\n      ).pipe(\n        take(1),\n        mergeMap((atBlock) =>\n          atBlock\n            ? sign$(from, _options, atBlock).pipe(\n                map((signed) => ({\n                  tx: toHex(signed),\n                  block: atBlock,\n                })),\n              )\n            : throwError(() => new Error(`Uknown block ${at}`)),\n        ),\n      )\n    }\n\n    const sign: TxSignFn<Asset> = (from, options) =>\n      firstValueFrom(_sign(from, options)).then((x) => x.tx)\n\n    const signAndSubmit: TxPromise<Asset> = (from, _options) =>\n      firstValueFrom(_sign(from, _options)).then(({ tx, block }) =>\n        submit(chainHead, broadcast, tx, block.hash),\n      )\n\n    const signSubmitAndWatch: TxObservable<Asset> = (from, _options) =>\n      _sign(from, _options).pipe(\n        mergeMap(({ tx, block }) =>\n          submit$(chainHead, broadcast, tx, block.hash, true),\n        ),\n      )\n\n    const getPaymentInfo = async (\n      from: Uint8Array | string,\n      _options?: any,\n    ) => {\n      if (typeof from === \"string\")\n        from = from.startsWith(\"0x\") ? fromHex(from) : accountIdEnc(from)\n      const isEth = from.length === 20\n      const fakeSigner = getPolkadotSigner(\n        from,\n        isEth ? \"Ecdsa\" : \"Sr25519\",\n        getFakeSignature(isEth),\n      )\n      const encoded = fromHex(await sign(fakeSigner, _options))\n      const args = toHex(mergeUint8(encoded, u32.enc(encoded.length)))\n\n      const decoder$: Observable<Decoder<PaymentInfo>> = chainHead\n        .getRuntimeContext$(null)\n        .pipe(\n          map((ctx) => {\n            try {\n              return ctx.dynamicBuilder.buildRuntimeCall(\n                \"TransactionPaymentApi\",\n                \"query_info\",\n              ).value[1]\n            } catch {\n              return queryInfoDecFallback\n            }\n          }),\n        )\n\n      const call$ = chainHead.call$(\n        null,\n        \"TransactionPaymentApi_query_info\",\n        args,\n      )\n\n      return firstValueFrom(\n        combineLatest([call$, decoder$]).pipe(\n          map(([result, decoder]) => decoder(result)),\n        ),\n      )\n    }\n\n    const getEstimatedFees = async (\n      from: Uint8Array | string,\n      _options?: any,\n    ) => (await getPaymentInfo(from, _options)).partial_fee\n\n    return {\n      getPaymentInfo,\n      getEstimatedFees,\n      decodedCall: {\n        type: pallet,\n        value: Enum(name, arg as any),\n      },\n      getEncodedData,\n      sign,\n      signSubmitAndWatch,\n      signAndSubmit,\n    }\n  }\n\n  return Object.assign(fn, {\n    getCompatibilityLevel,\n    isCompatible: isCompatibleHelper,\n  })\n}\n","import { HexString } from \"@polkadot-api/substrate-bindings\"\nimport type {\n  PinnedBlocks,\n  BlockInfo,\n  ChainHead$,\n  RuntimeContext,\n} from \"@polkadot-api/observable-client\"\nimport {\n  BlockNotPinnedError,\n  isBestOrFinalizedBlock,\n} from \"@polkadot-api/observable-client\"\nimport {\n  catchError,\n  combineLatest,\n  delay,\n  distinctUntilChanged,\n  EMPTY,\n  filter,\n  map,\n  merge,\n  mergeMap,\n  Observable,\n  of,\n  pairwise,\n  startWith,\n  take,\n  takeUntil,\n  throwError,\n  withLatestFrom,\n} from \"rxjs\"\nimport { selfDependent, lossLessExhaustMap } from \"@/utils\"\nimport { state } from \"@rx-state/core\"\n\ninterface StorageEntry {\n  key: HexString\n  value: HexString\n  dec: {\n    args: Array<any>\n    value: any\n  }\n}\n\ntype Deltas = {\n  upserted: Array<StorageEntry>\n  deleted: Array<StorageEntry>\n}\n\ninterface MemoryBlock {\n  prev: HexString | null\n  block: BlockInfo\n  rootHash: string\n  entries: Array<StorageEntry>\n  deltas: Deltas | null\n}\n\ntype MemoryBlocks = {\n  blocks: Record<HexString, MemoryBlock>\n  finalized: HexString\n}\n\nconst getDiff = (\n  _prev: Array<StorageEntry>,\n  _current: Array<StorageEntry>,\n  patch: (input: StorageEntry) => StorageEntry,\n): Pick<MemoryBlock, \"entries\" | \"deltas\"> => {\n  const current = new Map(_current.map((x) => [x.key, x]))\n  const prev = new Map(_prev.map((x) => [x.key, x]))\n\n  const upserted: Map<string, StorageEntry> = new Map()\n  const deleted: Array<StorageEntry> = []\n\n  _current.forEach((value) => {\n    const { key } = value\n    const prevVal = prev.get(key)\n    if (!prevVal || prevVal.value !== value.value)\n      upserted.set(key, patch(value))\n  })\n\n  _prev.forEach((x) => {\n    if (!current.has(x.key)) deleted.push(x)\n  })\n\n  return {\n    deltas: {\n      deleted,\n      upserted: [...upserted.values()],\n    },\n    entries: _current.map(({ key }) => upserted.get(key) ?? prev.get(key)!),\n  }\n}\n\nconst findPrevious = (\n  start: HexString,\n  state: MemoryBlocks[\"blocks\"],\n  pinned: PinnedBlocks,\n  includeStart = false,\n) => {\n  try {\n    let target = includeStart ? start : pinned.blocks.get(start)!.parent\n    while (target && !state[target]) target = pinned.blocks.get(target)!.parent!\n\n    if (!target) return null\n    return state[target]\n  } catch {\n    return null\n  }\n}\n\nconst getPatcherFromRuntime =\n  (pallet: string, entry: string) => (runtime: RuntimeContext) => {\n    const { keys, value } = runtime.dynamicBuilder.buildStorage(pallet, entry)\n    return (x: StorageEntry) => {\n      x.dec = {\n        value: value.dec(x.value),\n        args: keys.dec(x.key),\n      }\n      return x\n    }\n  }\n\nexport const createWatchEntries = (\n  blocks$: Observable<PinnedBlocks>,\n  storage: ChainHead$[\"storage$\"],\n  withRuntime: ChainHead$[\"withRuntime\"],\n) => {\n  const getMemoryBlocks$ = state(\n    (pallet: string, entry: string, storageKey: string) => {\n      const getPatcher = getPatcherFromRuntime(pallet, entry)\n      const getNextMemoryBlock$ = (\n        prev: MemoryBlock | null,\n        block: BlockInfo,\n      ): Observable<MemoryBlock> => {\n        const isNotCanonical$ = isBestOrFinalizedBlock(\n          blocks$,\n          block.hash,\n        ).pipe(\n          filter((x) => !x),\n          take(1),\n        )\n\n        return storage(\n          block.hash,\n          \"closestDescendantMerkleValue\",\n          () => storageKey,\n        ).pipe(\n          mergeMap((rootHash) => {\n            if (rootHash === prev?.rootHash)\n              return of({\n                ...prev,\n                block,\n                deltas: null,\n                prev: prev.block.hash,\n              })\n\n            return storage(\n              block.hash,\n              \"descendantsValues\",\n              () => storageKey,\n            ).pipe(\n              withRuntime(() => block.hash),\n              map(\n                ([entries, runtimeCtx]) =>\n                  [entries, getPatcher(runtimeCtx)] as const,\n              ),\n              map(\n                ([entries, patcher]): MemoryBlock => ({\n                  prev: prev && prev.block.hash,\n                  rootHash: rootHash!,\n                  block,\n                  ...getDiff(\n                    prev?.entries ?? [],\n                    entries as StorageEntry[],\n                    patcher,\n                  ),\n                }),\n              ),\n            )\n          }),\n          takeUntil(isNotCanonical$),\n          catchError((e) =>\n            e instanceof BlockNotPinnedError ? EMPTY : throwError(() => e),\n          ),\n        )\n      }\n\n      const initial$ = blocks$.pipe(\n        distinctUntilChanged((a, b) => a.finalized === b.finalized),\n        lossLessExhaustMap(({ blocks, finalized }) =>\n          getNextMemoryBlock$(null, blocks.get(finalized)!),\n        ),\n        take(1),\n        map(\n          (x): MemoryBlocks => ({\n            blocks: { [x.block.hash]: x },\n            finalized: x.block.hash,\n          }),\n        ),\n      )\n\n      const [_memoryBlocks$, connectMemoryBlocks] =\n        selfDependent<MemoryBlocks>()\n      const updates$ = blocks$.pipe(\n        distinctUntilChanged((a, b) => a.best === b.best),\n        withLatestFrom(_memoryBlocks$),\n        lossLessExhaustMap(([pinned, memoryBlocks]) => {\n          const { best } = pinned\n          const { blocks } = memoryBlocks\n          let target = !blocks[best] ? best : null\n          if (!target) return EMPTY\n\n          const previous = findPrevious(target, blocks, pinned)\n          if (previous)\n            return getNextMemoryBlock$(\n              previous,\n              pinned.blocks.get(target)!,\n            ).pipe(\n              map((x) => {\n                blocks[target!] = x\n                return memoryBlocks\n              }),\n            )\n\n          // This means that there has been a stop event that the pinned-blocks\n          // couldn't recover from. Therefore, we must \"start over\"\n          target = pinned.finalized\n          return getNextMemoryBlock$(\n            blocks[memoryBlocks.finalized],\n            pinned.blocks.get(target)!,\n          ).pipe(\n            map((x) => {\n              x.prev = null\n              return {\n                blocks: { [target]: x },\n                finalized: target,\n              }\n            }),\n          )\n        }),\n      )\n\n      return merge(initial$, updates$).pipe(connectMemoryBlocks())\n    },\n  )\n\n  const getBestOrFinalized =\n    (isFinalized: boolean) =>\n    (pallet: string, entry: string, storageKey: string) => {\n      const memoryBlocks$ = getMemoryBlocks$(pallet, entry, storageKey)\n      const getPatcher = getPatcherFromRuntime(pallet, entry)\n\n      const prop = isFinalized ? \"finalized\" : \"best\"\n\n      return combineLatest([\n        memoryBlocks$.pipe(delay(0)),\n        blocks$.pipe(distinctUntilChanged((a, b) => a[prop] === b[prop])),\n      ]).pipe(\n        map(([state, blocks]) =>\n          findPrevious(blocks[prop], state.blocks, blocks, true),\n        ),\n        filter(Boolean),\n        distinctUntilChanged(),\n        startWith(null),\n        pairwise(),\n        withLatestFrom(memoryBlocks$),\n        withRuntime(([[, _latest]]) => _latest!.block.hash),\n        map(\n          ([[[prevUpdate, latest], memoryBlocks], runtimeCtx]) =>\n            [\n              prevUpdate,\n              latest!,\n              memoryBlocks,\n              getPatcher(runtimeCtx),\n            ] as const,\n        ),\n        mergeMap(([prevUpdate, latest, memoryBlocks, patcher]) => {\n          if (!prevUpdate) return [latest]\n\n          let ancestor: MemoryBlock | null = latest\n          const updates: Array<MemoryBlock> = []\n          while (ancestor && ancestor.block.number > prevUpdate.block.number) {\n            updates.unshift(ancestor)\n            ancestor = ancestor.prev ? memoryBlocks.blocks[ancestor.prev] : null\n          }\n\n          if (isFinalized) {\n            memoryBlocks.finalized = latest.block.hash\n            if (updates.length) {\n              const { blocks } = memoryBlocks\n              Object.keys(blocks).forEach((key) => {\n                if (blocks[key].block.number < updates[0].block.number)\n                  delete blocks[key]\n              })\n            }\n          }\n\n          if (prevUpdate === ancestor) return updates\n\n          // It's a re-org\n          return [\n            {\n              ...latest,\n              ...(prevUpdate.rootHash === latest.rootHash\n                ? {\n                    entries: prevUpdate.entries,\n                    deltas: null,\n                  }\n                : getDiff(prevUpdate.entries, latest.entries, patcher)),\n            },\n          ]\n        }),\n      )\n    }\n\n  const getFinalized$ = state(getBestOrFinalized(true))\n  const getBest$ = state(getBestOrFinalized(false))\n\n  return (pallet: string, entry: string, args: Array<any>, atBest: boolean) => {\n    const fn = atBest ? getBest$ : getFinalized$\n    const storageKey$ = blocks$.pipe(\n      take(1),\n      mergeMap(\n        (b) =>\n          b.runtimes[b.blocks.get(b[atBest ? \"best\" : \"finalized\"])!.runtime]\n            .runtime,\n      ),\n      map((runtime) =>\n        runtime.dynamicBuilder.buildStorage(pallet, entry).keys.enc(...args),\n      ),\n    )\n    return storageKey$.pipe(\n      take(1),\n      mergeMap((storageKey) => fn(pallet, entry, storageKey)),\n      map(({ block: { hash, number, parent }, deltas, entries }, idx) => {\n        const actualDeltas =\n          idx > 0 ? deltas : { deleted: [], upserted: entries }\n\n        return {\n          block: { hash, number, parent },\n          entries: entries.map(toDec),\n          deltas: actualDeltas && {\n            deleted: actualDeltas.deleted.map(toDec),\n            upserted: actualDeltas.upserted.map(toDec),\n          },\n        }\n      }),\n    )\n  }\n}\n\nconst toDec = <T>(x: { dec: T }): T => x.dec\n","import { JsonRpcProvider } from \"@polkadot-api/json-rpc-provider\"\nimport {\n  enumValueEntryPointNode,\n  runtimeCallEntryPoint,\n  singleValueEntryPoint,\n  storageEntryPoint,\n  voidEntryPointNode,\n} from \"@polkadot-api/metadata-compatibility\"\nimport {\n  ChainHead$,\n  RuntimeContext,\n  getObservableClient,\n} from \"@polkadot-api/observable-client\"\nimport {\n  SubstrateClient,\n  createClient as createRawClient,\n} from \"@polkadot-api/substrate-client\"\nimport { Observable, firstValueFrom } from \"rxjs\"\nimport {\n  CompatibilityToken,\n  OpType,\n  RuntimeToken,\n  compatibilityHelper,\n  createCompatibilityToken,\n  createRuntimeToken,\n  getCompatibilityApi,\n} from \"./compatibility\"\nimport { createConstantEntry } from \"./constants\"\nimport { ChainDefinition } from \"./descriptors\"\nimport { createEventEntry } from \"./event\"\nimport { createRuntimeCallEntry } from \"./runtime-call\"\nimport { createStorageEntry } from \"./storage\"\nimport { createTxEntry, submit, submit$ } from \"./tx\"\nimport type { AnyApi, PolkadotClient } from \"./types\"\nimport { Binary } from \"@polkadot-api/substrate-bindings\"\nimport { createWatchEntries } from \"./watch-entries\"\n\nconst createApi = <Unsafe extends true | false, D>(\n  compatibilityToken: Promise<CompatibilityToken | RuntimeToken>,\n  chainHead: ChainHead$,\n  broadcast$: (tx: string) => Observable<never>,\n): AnyApi<Unsafe, D> => {\n  const target = {}\n  const createProxy = (propCall: (prop: string) => unknown) =>\n    new Proxy(target, {\n      get(_, prop) {\n        return propCall(prop as string)\n      },\n    })\n  const createProxyPath = <T>(pathCall: (a: string, b: string) => T) => {\n    const cache: Record<string, Record<string, T>> = {}\n    return createProxy((a) => {\n      if (!cache[a]) cache[a] = {}\n      return createProxy((b) => {\n        if (!cache[a][b]) cache[a][b] = pathCall(a, b)\n        return cache[a][b]\n      })\n    }) as Record<string, Record<string, T>>\n  }\n\n  const getPallet = (ctx: RuntimeContext, name: string) =>\n    ctx.lookup.metadata.pallets.find((p) => p.name === name)\n\n  const getWatchEntries = createWatchEntries(\n    chainHead.pinnedBlocks$,\n    chainHead.storage$,\n    chainHead.withRuntime,\n  )\n  const query = createProxyPath((pallet, name) =>\n    createStorageEntry(\n      pallet,\n      name,\n      chainHead,\n      getWatchEntries,\n      compatibilityHelper(\n        compatibilityToken,\n        (r) => r.getPalletEntryPoint(OpType.Storage, pallet, name),\n        // TODO this is way sub-optimal. Needs some rethought - maybe a builder for entry points?.\n        (ctx) => {\n          const item = getPallet(ctx, pallet)?.storage?.items.find(\n            (s) => s.name === name,\n          )\n          return item == null ? null : storageEntryPoint(item)\n        },\n      ),\n    ),\n  )\n\n  const getEnumEntry = (\n    ctx: RuntimeContext,\n    side: \"args\" | \"values\",\n    id: number | undefined,\n    name: string,\n  ) => {\n    if (id == null) return null\n    const entry = ctx.lookup(id)\n    if (entry.type !== \"enum\") throw new Error(\"Expected enum\")\n\n    if (entry.value[name] == null) return null\n    const node = enumValueEntryPointNode(entry.value[name])\n    return {\n      args: side === \"args\" ? node : voidEntryPointNode,\n      values: side === \"args\" ? voidEntryPointNode : node,\n    }\n  }\n  const tx = createProxyPath((pallet, name) =>\n    createTxEntry(\n      pallet,\n      name,\n      chainHead,\n      broadcast$,\n      compatibilityHelper(\n        compatibilityToken,\n        (r) => r.getPalletEntryPoint(OpType.Tx, pallet, name),\n        (ctx) => getEnumEntry(ctx, \"args\", getPallet(ctx, pallet)?.calls, name),\n      ),\n      true,\n    ),\n  )\n\n  const event = createProxyPath((pallet, name) =>\n    createEventEntry(\n      pallet,\n      name,\n      chainHead,\n      compatibilityHelper(\n        compatibilityToken,\n        (r) => r.getPalletEntryPoint(OpType.Event, pallet, name),\n        (ctx) =>\n          getEnumEntry(ctx, \"values\", getPallet(ctx, pallet)?.events, name),\n      ),\n    ),\n  )\n\n  const constants = createProxyPath((pallet, name) =>\n    createConstantEntry(\n      pallet,\n      name,\n      compatibilityHelper(\n        compatibilityToken,\n        (r) => r.getPalletEntryPoint(OpType.Const, pallet, name),\n        (ctx) => {\n          const item = getPallet(ctx, pallet)?.constants.find(\n            (c) => c.name === name,\n          )?.type\n          return item == null ? null : singleValueEntryPoint(item)\n        },\n      ),\n    ),\n  )\n\n  const apis = createProxyPath((api, method) =>\n    createRuntimeCallEntry(\n      api,\n      method,\n      chainHead,\n      compatibilityHelper(\n        compatibilityToken,\n        (r) => r.getApiEntryPoint(api, method),\n        (ctx) =>\n          runtimeCallEntryPoint(\n            ctx.lookup.metadata.apis\n              .find((a) => a.name === api)!\n              .methods.find((m) => m.name === method)!,\n          ),\n      ),\n    ),\n  )\n\n  const _callDataTx = (\n    callData: Binary,\n    token: CompatibilityToken | RuntimeToken,\n  ) => {\n    const { lookup, dynamicBuilder } = getCompatibilityApi(token).runtime()\n    try {\n      const decoded = dynamicBuilder\n        .buildDefinition(lookup.call!)\n        .dec(callData.asBytes())\n      const pallet = decoded.type\n      const call = decoded.value.type\n      const args = decoded.value.value\n\n      return createTxEntry(\n        pallet,\n        call,\n        chainHead,\n        broadcast$,\n        compatibilityHelper(\n          compatibilityToken,\n          (r) => r.getPalletEntryPoint(OpType.Tx, pallet, call),\n          (ctx) =>\n            getEnumEntry(ctx, \"args\", getPallet(ctx, pallet)?.calls, call),\n        ),\n        false,\n      )(args)\n    } catch {\n      throw new Error(\"createTx: invalid call data\")\n    }\n  }\n\n  return {\n    query,\n    txFromCallData: (\n      callData: Binary,\n      token?: CompatibilityToken | RuntimeToken,\n    ) =>\n      token\n        ? _callDataTx(callData, token)\n        : compatibilityToken.then((t) => _callDataTx(callData, t)),\n    tx,\n    event,\n    apis,\n    constants,\n  } as any\n}\n\n/**\n * This is the top-level export for `polkadot-api`.\n *\n * @param provider  A `JsonRpcProvider` compliant with the [JSON-RPC\n *                  spec](https://paritytech.github.io/json-rpc-interface-spec/),\n *                  which must support the `chainHead`, `transaction` and\n *                  `chainSpec` groups.\n * @example\n *\n *   import { createClient } from \"polkadot-api\"\n *   import { getSmProvider } from \"polkadot-api/sm-provider\"\n *   import { chainSpec } from \"polkadot-api/chains/polkadot\"\n *   import { start } from \"polkadot-api/smoldot\"\n *\n *   const smoldot = start()\n *   const chain = await smoldot.addChain({ chainSpec })\n *\n *   // Connect to the polkadot relay chain.\n *   const client = createClient(getSmProvider(chain))\n *\n */\nexport function createClient(provider: JsonRpcProvider): PolkadotClient {\n  const rawClient: SubstrateClient = createRawClient(provider)\n  const client = getObservableClient(rawClient)\n  const chainHead = client.chainHead$()\n\n  const { getChainSpecData } = rawClient\n\n  const _request: <Reply = any, Params extends Array<any> = any[]>(\n    method: string,\n    params: Params,\n  ) => Promise<Reply> = rawClient.request\n\n  let runtimeToken: Promise<RuntimeToken>\n  const compatibilityToken = new WeakMap<\n    ChainDefinition,\n    Promise<CompatibilityToken<any>>\n  >()\n  const getChainToken = (chainDefinition: ChainDefinition) => {\n    const result =\n      compatibilityToken.get(chainDefinition) ||\n      createCompatibilityToken(chainDefinition, chainHead)\n    compatibilityToken.set(chainDefinition, result)\n    return result\n  }\n  const getRuntimeToken = <D>(): Promise<RuntimeToken<D>> =>\n    (runtimeToken ??= createRuntimeToken(chainHead))\n  const { broadcastTx$ } = client\n  return {\n    getChainSpecData,\n\n    finalizedBlock$: chainHead.finalized$,\n    getFinalizedBlock: () => firstValueFrom(chainHead.finalized$),\n\n    bestBlocks$: chainHead.bestBlocks$,\n    getBestBlocks: () => firstValueFrom(chainHead.bestBlocks$),\n\n    watchBlockBody: chainHead.body$,\n    getBlockBody: (hash: string) => firstValueFrom(chainHead.body$(hash)),\n\n    getBlockHeader: (hash?: string) =>\n      firstValueFrom(chainHead.header$(hash ?? null)),\n\n    submit: (...args) => submit(chainHead, broadcastTx$, ...args),\n    submitAndWatch: (...args) => submit$(chainHead, broadcastTx$, ...args),\n\n    getTypedApi: <D extends ChainDefinition>(chainDefinition: D) => {\n      const token = getChainToken(chainDefinition)\n      return Object.assign(\n        createApi<false, D>(token, chainHead, broadcastTx$),\n        { compatibilityToken: token },\n      )\n    },\n\n    getUnsafeApi: <D>() => {\n      const token = getRuntimeToken()\n      return Object.assign(createApi<true, D>(token, chainHead, broadcastTx$), {\n        runtimeToken: token,\n      })\n    },\n\n    destroy: () => {\n      chainHead.unfollow()\n      client.destroy()\n    },\n\n    _request,\n  }\n}\n","import { getDynamicBuilder, getLookupFn } from \"@polkadot-api/metadata-builders\"\nimport { ChainDefinition, PlainDescriptor } from \"./descriptors\"\nimport { OfflineTxEntry } from \"./tx\"\nimport {\n  Binary,\n  Enum,\n  metadata as metadataCodec,\n  V14,\n  V15,\n} from \"@polkadot-api/substrate-bindings\"\nimport { fromHex, mergeUint8, toHex } from \"@polkadot-api/utils\"\nimport { OfflineApi } from \"./types\"\nimport { getSignExtensionsCreator } from \"./tx/signed-extensions\"\n\nconst createOfflineTxEntry = <\n  Arg extends {} | undefined,\n  Pallet extends string,\n  Name extends string,\n  Asset extends PlainDescriptor<any>,\n>(\n  pallet: Pallet,\n  name: Name,\n  metadataRaw: Uint8Array,\n  dynamicBuilder: ReturnType<typeof getDynamicBuilder>,\n  signExtensionCreator: ReturnType<typeof getSignExtensionsCreator>,\n): OfflineTxEntry<Arg, Pallet, Name, Asset> => {\n  let codecs\n  try {\n    codecs = dynamicBuilder.buildCall(pallet, name)\n  } catch {\n    throw new Error(`Runtime entry Tx(${pallet}.${name}) not found`)\n  }\n  const { location, codec } = codecs\n  const locationBytes = new Uint8Array(location)\n\n  return (arg: Arg) => {\n    const encodedData = Binary.fromBytes(\n      mergeUint8(locationBytes, codec.enc(arg)),\n    )\n\n    return {\n      encodedData,\n      decodedCall: Enum(pallet, Enum(name, arg as any) as any),\n      sign: async (from, extensions) =>\n        toHex(\n          await from.signTx(\n            encodedData.asBytes(),\n            signExtensionCreator(extensions),\n            metadataRaw,\n            extensions.mortality.mortal\n              ? extensions.mortality.startAtBlock.height\n              : 0,\n          ),\n        ),\n    }\n  }\n}\n\n/**\n * Returns an async instance of a `OfflineApi`\n *\n * @param descriptors  Pass descriptors from `@polkadot-api/descriptors`\n *                     generated by `papi` CLI.\n */\nexport const getOfflineApi = async <D extends ChainDefinition>({\n  genesis: genesisHex,\n  getMetadata,\n}: D): Promise<OfflineApi<D>> => {\n  if (!genesisHex) throw new Error(\"Missing genesis hash\")\n  const genesis = fromHex(genesisHex)\n  const metadataRaw = await getMetadata()\n  const metadata = metadataCodec.dec(metadataRaw).metadata.value as V14 | V15\n  const lookupFn = getLookupFn(metadata)\n  const dynamicBuilder = getDynamicBuilder(lookupFn)\n  const signExtensionCreator = getSignExtensionsCreator(\n    genesis,\n    lookupFn,\n    dynamicBuilder,\n  )\n\n  const getPallet = (name: string) =>\n    metadata.pallets.find((p) => p.name === name)\n\n  const target = {}\n  const createProxy = (propCall: (prop: string) => unknown) =>\n    new Proxy(target, {\n      get(_, prop) {\n        return propCall(prop as string)\n      },\n    })\n\n  const createProxyPath = <T>(pathCall: (a: string, b: string) => T) => {\n    const cache: Record<string, Record<string, T>> = {}\n    return createProxy((a) => {\n      if (!cache[a]) cache[a] = {}\n      return createProxy((b) => {\n        if (!cache[a][b]) cache[a][b] = pathCall(a, b)\n        return cache[a][b]\n      })\n    }) as Record<string, Record<string, T>>\n  }\n\n  const constants = createProxyPath((pallet, name) => {\n    const constant = getPallet(pallet)?.constants.find((c) => c.name === name)\n    if (!constant)\n      throw new Error(`Runtime entry Constant(${pallet}.${name}) not found`)\n    return dynamicBuilder.buildConstant(pallet, name).dec(constant.value)\n  })\n\n  const tx = createProxyPath((pallet, name) =>\n    createOfflineTxEntry(\n      pallet,\n      name,\n      metadataRaw,\n      dynamicBuilder,\n      signExtensionCreator,\n    ),\n  )\n\n  return { constants, tx } as any\n}\n"],"names":["OpType","Vector","EntryPointCodec","TypedefCodec","Tuple","filter","firstValueFrom","mapLookupToTypedef","descriptors","CompatibilityLevel","entryPointsAreCompatible","combineLatest","map","valueIsCompatibleWithDest","share","ReplaySubject","AbortError","noop","Observable","BehaviorSubject","Subject","switchAll","tap","concatMapEager","mergeMap","toHex","take","identity","shareReplay","pipe","combineLatestWith","distinctUntilChanged","NotBestBlockError","FixedSizeBinary","from","enhanceEncoder","Bytes","u16","Struct","compact","Option","value","additionalSigned","mapObject","key","fromHex","u8","u32","u64","of","Blake2256","Binary","at","concat","EMPTY","lastValueFrom","AccountId","compactBn","Variant","_void","u128","arg","isCompatible","mergeUint8","throwError","getPolkadotSigner","Enum","state","isBestOrFinalizedBlock","takeUntil","catchError","BlockNotPinnedError","withLatestFrom","merge","delay","startWith","pairwise","storageEntryPoint","enumValueEntryPointNode","voidEntryPointNode","singleValueEntryPoint","runtimeCallEntryPoint","createRawClient","getObservableClient","metadataCodec","getLookupFn","getDynamicBuilder"],"mappings":"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"}