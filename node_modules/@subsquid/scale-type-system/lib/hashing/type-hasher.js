"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.computeHash = exports.TypeHasher = void 0;
const scale_codec_1 = require("@subsquid/scale-codec");
const util_internal_1 = require("@subsquid/util-internal");
const assert_1 = __importDefault(require("assert"));
const dcg_hasher_1 = require("./dcg-hasher");
class TypeHasher {
    constructor(types) {
        this.dcg = new dcg_hasher_1.DCGHasher(types, computeHash);
    }
    getHash(ti) {
        return this.dcg.getHash(ti);
    }
}
exports.TypeHasher = TypeHasher;
function computeHash(types, hasher, ty) {
    switch (ty.kind) {
        case scale_codec_1.TypeKind.Primitive:
            return { primitive: toJsPrimitive(ty.primitive) };
        case scale_codec_1.TypeKind.Compact: {
            let composite = types[ty.type];
            (0, assert_1.default)(composite.kind == scale_codec_1.TypeKind.Primitive);
            return { primitive: toJsPrimitive(composite.primitive) };
        }
        case scale_codec_1.TypeKind.HexBytesArray:
        case scale_codec_1.TypeKind.HexBytes:
            return { bytes: true };
        case scale_codec_1.TypeKind.BitSequence:
        case scale_codec_1.TypeKind.Bytes:
        case scale_codec_1.TypeKind.BytesArray:
            return { binary: true };
        case scale_codec_1.TypeKind.Array:
        case scale_codec_1.TypeKind.Sequence:
            return { array: hasher.getHash(ty.type) };
        case scale_codec_1.TypeKind.Tuple:
            return { tuple: ty.tuple.map(ti => hasher.getHash(ti)) };
        case scale_codec_1.TypeKind.Composite:
            if (ty.fields.length == 0 || ty.fields[0].name == null) {
                return { tuple: ty.fields.map(f => hasher.getHash(f.type)) };
            }
            else {
                let fields = ty.fields.slice().sort(byName);
                return { struct: fields.map(f => {
                        return { name: f.name, type: hasher.getHash(f.type) };
                    }) };
            }
        case scale_codec_1.TypeKind.Variant:
            return {
                variant: ty.variants.sort(byName).map(v => {
                    if (v.fields.length == 0 || v.fields[0].name == null) {
                        if (v.fields.length == 1) {
                            return {
                                name: v.name,
                                type: hasher.getHash(v.fields[0].type)
                            };
                        }
                        else {
                            return {
                                name: v.name,
                                type: computeHash(types, hasher, {
                                    kind: scale_codec_1.TypeKind.Tuple,
                                    tuple: v.fields.map(f => f.type)
                                })
                            };
                        }
                    }
                    else {
                        let fields = v.fields.slice().sort(byName);
                        return {
                            name: v.name,
                            type: fields.map(f => ({ name: f.name, type: hasher.getHash(f.type) }))
                        };
                    }
                })
            };
        case scale_codec_1.TypeKind.Option:
            return { option: hasher.getHash(ty.type) };
        case scale_codec_1.TypeKind.DoNotConstruct:
            return { doNotConstruct: true };
        default:
            throw (0, util_internal_1.unexpectedCase)();
    }
}
exports.computeHash = computeHash;
function toJsPrimitive(primitive) {
    switch (primitive) {
        case 'I8':
        case 'U8':
        case 'I16':
        case 'U16':
        case 'I32':
        case 'U32':
            return 'number';
        case 'I64':
        case 'U64':
        case 'I128':
        case 'U128':
        case 'I256':
        case 'U256':
            return 'bigint';
        case 'Bool':
            return 'boolean';
        case 'Str':
            return 'string';
        default:
            throw (0, util_internal_1.unexpectedCase)(primitive);
    }
}
function byName(a, b) {
    let an = (0, util_internal_1.assertNotNull)(a.name);
    let bn = (0, util_internal_1.assertNotNull)(b.name);
    if (an < bn) {
        return -1;
    }
    else if (an == bn) {
        return 0;
    }
    else {
        return 1;
    }
}
//# sourceMappingURL=type-hasher.js.map