type Ni = number;
type Hash = string;
export interface Hasher {
    getHash(nodeIndex: Ni): Hash;
}
/**
 * Computes hashes of substrate types for the purpose of equality derivation.
 *
 * Substrate types form a cyclic directed graph with labeled edges.
 * Two types are equal when their depth-first traversal trees are equal.
 * Inline with equality, we define a type hash to be a merkel hash of it's depth-first traversal.
 *
 * Note, that unlike a classic tree case we might need
 * to visit mutually recursive type nodes more than once.
 *
 * Naive approach of performing a depth-first traversal for each node might be slow.
 *
 * Hence, the following procedure:
 *  1. We embed Tarjan's strongly connected components algorithm in our hash computation to discover and
 *  persist information about strongly connected components.
 *  2. For each strongly connected component, we cache the resulting hash per entry point.
 *
 * This allows us to visit non-mutually recursive types only once and makes the overall procedure
 * quadratic only on the size of a maximal strongly connected component, which practically should not be large.
 */
export declare class DCGHasher<N> implements Hasher {
    private graph;
    private computeHash;
    private cache;
    private index;
    private nodes;
    private stack;
    private parentNode;
    constructor(graph: N[], computeHash: (graph: N[], hasher: DCGHasher<N>, type: N) => object);
    getHash(ni: Ni): Hash;
    private traverse;
    private visit;
}
export declare function sha(obj: object): Hash;
export {};
//# sourceMappingURL=dcg-hasher.d.ts.map