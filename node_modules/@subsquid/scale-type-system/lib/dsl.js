"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.union = exports.result = exports.enumOption = exports.externalEnum = exports.enumStruct = exports.closedEnum = exports.openEnum = exports.option = exports.struct = exports.tuple = exports.array = exports.unit = exports.unknown = exports.any = exports.boolean = exports.bitseq = exports.bytes = exports.string = exports.numeric = exports.bigint = exports.number = void 0;
const array_1 = require("./types/array");
const enum_1 = require("./types/enum");
const externalEnum_1 = require("./types/externalEnum");
const option_1 = require("./types/option");
const primitives_1 = require("./types/primitives");
const struct_1 = require("./types/struct");
const tuple_1 = require("./types/tuple");
const union_1 = require("./types/union");
const numberType = new primitives_1.NumberType();
const bigintType = new primitives_1.BigIntType();
const numericType = new primitives_1.NumericType();
const stringType = new primitives_1.StringType();
const bytesType = new primitives_1.BytesType();
const bitSequenceType = new primitives_1.BitSequenceType();
const booleanType = new primitives_1.BooleanType();
const anyType = new primitives_1.AnyType();
const unknownType = new primitives_1.UnknownType();
const unitType = new primitives_1.UnitType();
const externalEnumType = new externalEnum_1.ExternalEnumType();
function number() {
    return numberType;
}
exports.number = number;
function bigint() {
    return bigintType;
}
exports.bigint = bigint;
function numeric() {
    return numericType;
}
exports.numeric = numeric;
function string() {
    return stringType;
}
exports.string = string;
function bytes() {
    return bytesType;
}
exports.bytes = bytes;
function bitseq() {
    return bitSequenceType;
}
exports.bitseq = bitseq;
function boolean() {
    return booleanType;
}
exports.boolean = boolean;
function any() {
    return anyType;
}
exports.any = any;
function unknown() {
    return unknownType;
}
exports.unknown = unknown;
function unit() {
    return unitType;
}
exports.unit = unit;
function array(def) {
    return new array_1.ArrayType(getter(def));
}
exports.array = array;
function tuple(def) {
    if (def == null) {
        return unit();
    }
    else {
        return new tuple_1.TupleType(getter(def));
    }
}
exports.tuple = tuple;
function struct(def) {
    return new struct_1.StructType(getter(def));
}
exports.struct = struct;
function option(type) {
    return new option_1.OptionType(getter(type));
}
exports.option = option;
function openEnum(variants) {
    return new enum_1.EnumType(getter(variants), true);
}
exports.openEnum = openEnum;
function closedEnum(variants) {
    return new enum_1.EnumType(getter(variants), false);
}
exports.closedEnum = closedEnum;
function enumStruct(def) {
    return new enum_1.EnumStruct(struct(def));
}
exports.enumStruct = enumStruct;
function externalEnum(variants) {
    if (variants == null) {
        return externalEnumType;
    }
    else {
        return new enum_1.EnumType(getter(variants), 'external');
    }
}
exports.externalEnum = externalEnum;
function enumOption(some) {
    return makeEnumOption(some);
}
exports.enumOption = enumOption;
function makeEnumOption(some) {
    let getType = getter(some);
    return closedEnum(() => {
        return {
            Some: getType(),
            None: unit()
        };
    });
}
function result(ok, err) {
    return makeResult(ok, err);
}
exports.result = result;
function makeResult(ok, err) {
    let getOk = getter(ok);
    let getErr = getter(err);
    return closedEnum(() => {
        return {
            Ok: getOk(),
            Err: getErr()
        };
    });
}
function union(...types) {
    return new union_1.UnionType(types);
}
exports.union = union;
function getter(get) {
    if (typeof get == 'function') {
        return get;
    }
    else {
        return () => get;
    }
}
//# sourceMappingURL=dsl.js.map