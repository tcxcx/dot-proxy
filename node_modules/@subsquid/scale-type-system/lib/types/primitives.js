"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.UnknownType = exports.AnyType = exports.UnitType = exports.BitSequenceType = exports.BytesType = exports.StringType = exports.BooleanType = exports.NumericType = exports.BigIntType = exports.NumberType = void 0;
const scale_codec_1 = require("@subsquid/scale-codec");
const assert_1 = __importDefault(require("assert"));
const type_checker_1 = require("../type-checker");
function asPrimitive(typeChecker, ty) {
    switch (ty.kind) {
        case scale_codec_1.TypeKind.Primitive:
            return ty.primitive;
        case scale_codec_1.TypeKind.Compact: {
            let item = typeChecker.getScaleType(ty.type);
            (0, assert_1.default)(item.kind == scale_codec_1.TypeKind.Primitive);
            return item.primitive;
        }
    }
}
class NumberType extends type_checker_1.BaseType {
    match(typeChecker, ty) {
        switch (asPrimitive(typeChecker, ty)) {
            case 'I8':
            case 'U8':
            case 'I16':
            case 'U16':
            case 'I32':
            case 'U32':
                return true;
            default:
                return false;
        }
    }
}
exports.NumberType = NumberType;
class BigIntType extends type_checker_1.BaseType {
    match(typeChecker, ty) {
        switch (asPrimitive(typeChecker, ty)) {
            case 'I64':
            case 'U64':
            case 'I128':
            case 'U128':
            case 'I256':
            case 'U256':
                return true;
            default:
                return false;
        }
    }
}
exports.BigIntType = BigIntType;
class NumericType extends type_checker_1.BaseType {
    match(typeChecker, ty) {
        switch (asPrimitive(typeChecker, ty)) {
            case 'I8':
            case 'U8':
            case 'I16':
            case 'U16':
            case 'I32':
            case 'U32':
            case 'I64':
            case 'U64':
            case 'I128':
            case 'U128':
            case 'I256':
            case 'U256':
                return true;
            default:
                return false;
        }
    }
}
exports.NumericType = NumericType;
class BooleanType extends type_checker_1.BaseType {
    match(typeChecker, ty) {
        return asPrimitive(typeChecker, ty) === 'Bool';
    }
}
exports.BooleanType = BooleanType;
class StringType extends type_checker_1.BaseType {
    match(typeChecker, ty) {
        return asPrimitive(typeChecker, ty) === 'Str';
    }
}
exports.StringType = StringType;
class BytesType extends type_checker_1.BaseType {
    match(typeChecker, ty) {
        switch (ty.kind) {
            case scale_codec_1.TypeKind.HexBytes:
            case scale_codec_1.TypeKind.HexBytesArray:
                return true;
            default:
                return false;
        }
    }
}
exports.BytesType = BytesType;
class BitSequenceType extends type_checker_1.BaseType {
    match(typeChecker, ty) {
        return ty.kind == scale_codec_1.TypeKind.BitSequence;
    }
}
exports.BitSequenceType = BitSequenceType;
class UnitType extends type_checker_1.BaseType {
    match(typeChecker, ty) {
        switch (ty.kind) {
            case scale_codec_1.TypeKind.Tuple:
                return ty.tuple.length == 0;
            case scale_codec_1.TypeKind.Composite:
                return ty.fields.length == 0;
            default:
                return false;
        }
    }
}
exports.UnitType = UnitType;
class AnyType extends type_checker_1.BaseType {
    match(typeChecker, ty) {
        return true;
    }
}
exports.AnyType = AnyType;
class UnknownType extends type_checker_1.BaseType {
    match(typeChecker, ty) {
        return true;
    }
}
exports.UnknownType = UnknownType;
//# sourceMappingURL=primitives.js.map