"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.isPreV14 = exports.isUnitType = exports.normalizeMetadataTypes = void 0;
const util_1 = require("@subsquid/scale-codec/lib/util");
const util_internal_1 = require("@subsquid/util-internal");
const util_naming_1 = require("@subsquid/util-naming");
const assert_1 = __importDefault(require("assert"));
const types_1 = require("./types");
function normalizeMetadataTypes(types) {
    types = fixWrapperKeepOpaqueTypes(types);
    types = fixU256Structs(types);
    types = eliminateWrappers(types);
    types = removeUnitFieldsFromVariants(types);
    types = fixCompactTypes(types);
    types = introduceOptionType(types);
    types = replaceUnitOptionWithBoolean(types);
    types = eliminateOptionsChain(types);
    types = introduceHexBytes(types);
    types = normalizeFieldNames(types);
    return types;
}
exports.normalizeMetadataTypes = normalizeMetadataTypes;
function fixWrapperKeepOpaqueTypes(types) {
    let u8 = types.length;
    let replaced = false;
    types = types.map(ty => {
        if (!ty.path?.length)
            return ty;
        if ((0, util_internal_1.last)(ty.path) != 'WrapperKeepOpaque')
            return ty;
        if (ty.kind != types_1.TypeKind.Composite)
            return ty;
        if (ty.fields.length != 2)
            return ty;
        if (types[ty.fields[0].type].kind != types_1.TypeKind.Compact)
            return ty;
        replaced = true;
        return {
            kind: types_1.TypeKind.Sequence,
            type: u8
        };
    });
    if (replaced) {
        types.push({
            kind: types_1.TypeKind.Primitive,
            primitive: 'U8'
        });
    }
    return types;
}
function fixU256Structs(types) {
    return types.map(ty => {
        let field;
        let element;
        let isU256 = ty.path && (0, util_internal_1.maybeLast)(ty.path) == 'U256'
            && ty.kind == types_1.TypeKind.Composite
            && ty.fields.length == 1
            && (field = types[ty.fields[0].type])
            && field.kind == types_1.TypeKind.Array
            && field.len == 4
            && (element = types[field.type])
            && element.kind == types_1.TypeKind.Primitive
            && element.primitive == 'U64';
        if (isU256)
            return {
                kind: types_1.TypeKind.Primitive,
                primitive: 'U256'
            };
        return ty;
    });
}
function eliminateWrappers(types) {
    let changed = true;
    while (changed) {
        changed = false;
        types = types.map(ty => {
            switch (ty.kind) {
                case types_1.TypeKind.Tuple:
                    if (ty.tuple.length == 1) {
                        changed = true;
                        return replaceType(ty, types[ty.tuple[0]]);
                    }
                    else {
                        return ty;
                    }
                case types_1.TypeKind.Composite: {
                    if (ty.fields.length == 0) {
                        changed = true;
                        return replaceType(ty, {
                            kind: types_1.TypeKind.Tuple,
                            tuple: []
                        });
                    }
                    if (ty.fields[0].name == null) {
                        changed = true;
                        return replaceType(ty, {
                            kind: types_1.TypeKind.Tuple,
                            tuple: ty.fields.map(f => {
                                (0, assert_1.default)(f.name == null);
                                return f.type;
                            })
                        });
                    }
                    let nonUnitFields = ty.fields.filter(f => {
                        return !isUnitType(types[f.type]);
                    });
                    if (nonUnitFields.length != ty.fields.length) {
                        changed = true;
                        return {
                            ...ty,
                            fields: nonUnitFields
                        };
                    }
                    return ty;
                }
                default:
                    return ty;
            }
        });
    }
    return types;
}
function replaceType(prev, next) {
    let { path, docs, ...def } = next;
    let info = {};
    if (prev.path) {
        info.path = prev.path;
    }
    if (prev.docs) {
        info.docs = prev.docs;
    }
    return { ...info, ...def };
}
function removeUnitFieldsFromVariants(types) {
    return types.map(ty => {
        if (ty.kind != types_1.TypeKind.Variant)
            return ty;
        let variants = ty.variants.map(v => {
            let nonUnitFields = v.fields.filter(f => {
                return !isUnitType(types[f.type]);
            });
            if (nonUnitFields.length == v.fields.length)
                return v;
            if (v.fields[0]?.name == null && nonUnitFields.length > 0)
                return v;
            return {
                ...v,
                fields: nonUnitFields
            };
        });
        return {
            ...ty,
            variants
        };
    });
}
function isUnitType(type) {
    return type.kind == types_1.TypeKind.Tuple && type.tuple.length == 0;
}
exports.isUnitType = isUnitType;
function fixCompactTypes(types) {
    return types.map(ty => {
        if (ty.kind != types_1.TypeKind.Compact)
            return ty;
        let compact = types[ty.type];
        switch (compact.kind) {
            case types_1.TypeKind.Primitive:
                (0, assert_1.default)(compact.primitive[0] == 'U');
                return ty;
            case types_1.TypeKind.Tuple:
                (0, assert_1.default)(compact.tuple.length == 0);
                return replaceType(ty, {
                    kind: types_1.TypeKind.Tuple,
                    tuple: []
                });
            case types_1.TypeKind.Composite:
                (0, assert_1.default)(compact.fields.length == 1);
                let compactTi = compact.fields[0].type;
                compact = types[compactTi];
                // FIXME: as far as I understand, CompactAs chain can be arbitrary long
                (0, assert_1.default)(compact.kind == types_1.TypeKind.Primitive);
                (0, assert_1.default)(compact.primitive[0] == 'U');
                return {
                    ...ty,
                    type: compactTi
                };
            default:
                (0, util_1.throwUnexpectedCase)(compact.kind);
        }
    });
}
function introduceOptionType(types) {
    return types.map(ty => {
        if (isOptionType(ty)) {
            return replaceType(ty, {
                kind: types_1.TypeKind.Option,
                type: ty.variants[1].fields[0].type
            });
        }
        else {
            return ty;
        }
    });
}
function isOptionType(type) {
    if (type.kind !== types_1.TypeKind.Variant)
        return false;
    if (type.variants.length != 2)
        return false;
    let v0 = type.variants[0];
    let v1 = type.variants[1];
    return v0.name == 'None' &&
        v0.fields.length == 0 &&
        v0.index == 0 &&
        v1.name == 'Some' &&
        v1.index == 1 &&
        v1.fields.length == 1 &&
        v1.fields[0].name == null;
}
function eliminateOptionsChain(types) {
    return types.map(ty => {
        if (ty.kind != types_1.TypeKind.Option)
            return ty;
        let param = ty.type;
        if (types[param].kind != types_1.TypeKind.Option)
            return ty;
        return {
            kind: types_1.TypeKind.Variant,
            variants: [
                {
                    name: 'None',
                    index: 0,
                    fields: []
                },
                {
                    name: 'Some',
                    index: 1,
                    fields: [{ type: param }]
                }
            ]
        };
    });
}
function replaceUnitOptionWithBoolean(types) {
    return types.map(ty => {
        if (ty.kind == types_1.TypeKind.Option && isUnitType(types[ty.type])) {
            return replaceType(ty, {
                kind: types_1.TypeKind.Primitive,
                primitive: 'Bool'
            });
        }
        else {
            return ty;
        }
    });
}
function introduceHexBytes(types) {
    return types.map(ty => {
        switch (ty.kind) {
            case types_1.TypeKind.Sequence:
                if (isU8(types[ty.type])) {
                    return replaceType(ty, {
                        kind: types_1.TypeKind.HexBytes
                    });
                }
                return ty;
            case types_1.TypeKind.Array: {
                if (isU8(types[ty.type])) {
                    return replaceType(ty, {
                        kind: types_1.TypeKind.HexBytesArray,
                        len: ty.len
                    });
                }
                return ty;
            }
            default:
                return ty;
        }
    });
}
function isU8(type) {
    return type.kind == types_1.TypeKind.Primitive && type.primitive == 'U8';
}
function normalizeFieldNames(types) {
    return types.map(type => {
        switch (type.kind) {
            case types_1.TypeKind.Composite:
                return {
                    ...type,
                    fields: convertToCamelCase(type.fields)
                };
            case types_1.TypeKind.Variant:
                return {
                    ...type,
                    variants: type.variants.map(v => {
                        return {
                            ...v,
                            fields: convertToCamelCase(v.fields)
                        };
                    })
                };
            default:
                return type;
        }
    });
}
function convertToCamelCase(fields) {
    return fields.map(f => {
        if (f.name) {
            let name = f.name;
            if (name.startsWith('r#')) {
                name = name.slice(2);
            }
            name = (0, util_naming_1.toCamelCase)(name);
            return { ...f, name };
        }
        else {
            return f;
        }
    });
}
function isPreV14(metadata) {
    switch (metadata.__kind) {
        case 'V0':
        case 'V1':
        case 'V2':
        case 'V3':
        case 'V4':
        case 'V5':
        case 'V6':
        case 'V7':
        case 'V8':
        case 'V9':
        case 'V10':
        case 'V11':
        case 'V12':
        case 'V13':
            return true;
        default:
            return false;
    }
}
exports.isPreV14 = isPreV14;
//# sourceMappingURL=util.js.map