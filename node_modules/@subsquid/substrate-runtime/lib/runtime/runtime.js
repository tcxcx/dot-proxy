"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Runtime = void 0;
const scale_codec_1 = require("@subsquid/scale-codec");
const sts = __importStar(require("@subsquid/scale-type-system"));
const util_internal_1 = require("@subsquid/util-internal");
const assert_1 = __importDefault(require("assert"));
const metadata_1 = require("../metadata");
const events_and_calls_1 = require("./events-and-calls");
const extrinsic_1 = require("./extrinsic");
const sto = __importStar(require("./storage"));
const util_1 = require("./util");
class Runtime {
    constructor(runtimeVersion, metadata, typesBundle, _rpc) {
        this._rpc = _rpc;
        this.constantValueCache = new Map();
        this.storageFallbackCache = new Map();
        if (typeof metadata == 'string' || metadata instanceof Uint8Array) {
            metadata = (0, metadata_1.decodeMetadata)(metadata);
        }
        this.specName = runtimeVersion.specName;
        this.specVersion = runtimeVersion.specVersion;
        this.implName = runtimeVersion.implName;
        this.implVersion = runtimeVersion.implVersion;
        this.metadata = metadata;
        this.description = (0, metadata_1.getRuntimeDescription)(this.metadata, this.specName, this.specVersion, typesBundle);
        this.events = new events_and_calls_1.EACRegistry(this.description.types, this.description.event);
        this.calls = new events_and_calls_1.EACRegistry(this.description.types, this.description.call);
        this.scaleCodec = new scale_codec_1.Codec(this.description.types);
        this.jsonCodec = new scale_codec_1.JsonCodec(this.description.types);
    }
    get rpc() {
        if (this._rpc == null)
            throw new Error('RPC client is not available');
        return this._rpc;
    }
    hasStorageItem(name) {
        let qn = (0, util_1.parseQualifiedName)(name);
        return !!this.description.storage[qn[0]]?.items[qn[1]];
    }
    _getStorageItem([pallet, name]) {
        let desc = this.description.storage[pallet];
        if (desc == null)
            throw new Error(`There are no storage items in pallet ${pallet}`);
        let def = desc.items[name];
        if (def == null)
            throw new Error(`Unknown storage item: ${pallet}.${name}`);
        return { ...def, prefix: desc.prefix };
    }
    encodeStorageKey(name, ...key) {
        let qn = (0, util_1.parseQualifiedName)(name);
        return sto.encodeKey(this.scaleCodec, qn[0], qn[1], this._getStorageItem(qn), key);
    }
    _decodeStorageKey(item, key) {
        let decoded = sto.decodeKey(this.scaleCodec, item, key);
        return decoded.length > 1 ? decoded : decoded[0];
    }
    _decodeStorageValue(item, value) {
        return sto.decodeValue(this.scaleCodec, item, value);
    }
    decodeStorageValue(name, value) {
        let qn = (0, util_1.parseQualifiedName)(name);
        let item = this._getStorageItem(qn);
        return this._decodeStorageValue(item, value);
    }
    getStorageFallback(name) {
        let value = this.storageFallbackCache.get(name);
        if (value === undefined) {
            let qn = (0, util_1.parseQualifiedName)(name);
            let item = this._getStorageItem(qn);
            (0, assert_1.default)(item.modifier == 'Default');
            value = this._decodeStorageValue(item);
            this.storageFallbackCache.set(name, value);
        }
        return value;
    }
    async getStorage(blockHash, name, ...key) {
        let qn = (0, util_1.parseQualifiedName)(name);
        let item = this._getStorageItem(qn);
        (0, assert_1.default)(item.keys.length === key.length);
        let encodedKey = sto.encodeKey(this.scaleCodec, item.prefix, qn[1], item, key);
        let value = await this.rpc.call('state_getStorageAt', [encodedKey, blockHash]);
        if (value == null)
            return;
        return this._decodeStorageValue(item, value);
    }
    async queryStorage(blockHash, name, keys) {
        let qn = (0, util_1.parseQualifiedName)(name);
        let item = this._getStorageItem(qn);
        let query;
        if (keys == null) {
            query = await this.rpc.call('state_getKeys', [sto.encodeName(item.prefix, qn[1]), blockHash]);
        }
        else {
            query = keys.map(key => {
                let ks = item.keys.length > 1 ? key : [key];
                (0, assert_1.default)(ks.length === item.keys.length);
                return sto.encodeKey(this.scaleCodec, item.prefix, qn[1], item, ks);
            });
        }
        if (query.length == 0)
            return [];
        let result = await this.rpc.call('state_queryStorageAt', [query, blockHash]);
        (0, assert_1.default)(result.length == 1);
        // Response from chain node can't contain key duplicates,
        // but our query list can, hence the following
        // value matching procedure
        let changes = new Map(result[0].changes);
        return query.map(k => {
            let v = changes.get(k);
            if (v == null)
                return;
            return this._decodeStorageValue(item, v);
        });
    }
    async getStorageKeys(blockHash, name, ...args) {
        let qn = (0, util_1.parseQualifiedName)(name);
        let item = this._getStorageItem(qn);
        let encodedKey = sto.encodeKey(this.scaleCodec, qn[0], qn[1], item, args);
        let values = await this.rpc.call('state_getKeys', [encodedKey, blockHash]);
        return values.map(v => this._decodeStorageKey(item, v));
    }
    async getStorageRawKeys(blockHash, name, ...args) {
        let encodedKey = this.encodeStorageKey(name, ...args);
        return this.rpc.call('state_getKeys', [encodedKey, blockHash]);
    }
    async *getStorageKeysPaged(pageSize, blockHash, name, ...args) {
        (0, assert_1.default)(pageSize > 0);
        let qn = (0, util_1.parseQualifiedName)(name);
        let item = this._getStorageItem(qn);
        let encodedKey = sto.encodeKey(this.scaleCodec, qn[0], qn[1], item, args);
        let lastKey = null;
        while (true) {
            let keys = await this.rpc.call('state_getKeysPaged', [encodedKey, pageSize, lastKey, blockHash]);
            if (keys.length == 0)
                return;
            yield keys.map(k => this._decodeStorageKey(item, k));
            if (keys.length == pageSize) {
                lastKey = (0, util_internal_1.last)(keys);
            }
            else {
                return;
            }
        }
    }
    async getStoragePairs(blockHash, name, ...args) {
        let qn = (0, util_1.parseQualifiedName)(name);
        let item = this._getStorageItem(qn);
        let encodedKey = sto.encodeKey(this.scaleCodec, qn[0], qn[1], item, args);
        let query = await this.rpc.call('state_getKeys', [encodedKey, blockHash]);
        if (query.length == 0)
            return [];
        let res = await this.rpc.call('state_queryStorageAt', [query, blockHash]);
        (0, assert_1.default)(res.length == 1);
        return res[0].changes.map(kv => this.decodeStoragePair(item, kv));
    }
    async *getStoragePairsPaged(pageSize, blockHash, name, ...args) {
        (0, assert_1.default)(pageSize > 0);
        let qn = (0, util_1.parseQualifiedName)(name);
        let item = this._getStorageItem(qn);
        let encodedKey = sto.encodeKey(this.scaleCodec, qn[0], qn[1], item, args);
        let lastKey = null;
        while (true) {
            let query = await this.rpc.call('state_getKeysPaged', [encodedKey, pageSize, lastKey, blockHash]);
            if (query.length == 0)
                return;
            let res = await this.rpc.call('state_queryStorageAt', [query, blockHash]);
            (0, assert_1.default)(res.length == 1);
            yield res[0].changes.map(kv => this.decodeStoragePair(item, kv));
            if (query.length == pageSize) {
                lastKey = (0, util_internal_1.last)(query);
            }
            else {
                return;
            }
        }
    }
    decodeStoragePair(item, pair) {
        let decodedKey = this._decodeStorageKey(item, pair[0]);
        let decodedValue = this._decodeStorageValue(item, pair[1]);
        return [decodedKey, decodedValue];
    }
    hasConstant(name) {
        let qn = (0, util_1.parseQualifiedName)(name);
        return !!this.description.constants[qn[0]]?.[qn[1]];
    }
    getConstant(name) {
        let value = this.constantValueCache.get(name);
        if (value === undefined && !this.constantValueCache.has(name)) {
            let def = this.getConstantDefinition(name);
            value = this.scaleCodec.decodeBinary(def.type, def.value);
            this.constantValueCache.set(name, value);
        }
        return value;
    }
    getConstantDefinition(name) {
        let qn = (0, util_1.parseQualifiedName)(name);
        let palletConstants = this.description.constants[qn[0]];
        if (palletConstants == null)
            throw new Error(`There are no constants in ${qn[0]} pallet`);
        let def = palletConstants[qn[1]];
        if (def == null)
            throw new Error(`Unknown constant: ${name}`);
        return def;
    }
    decodeExtrinsic(bytes) {
        return (0, extrinsic_1.decodeExtrinsic)(bytes, this.description, this.scaleCodec);
    }
    encodeExtrinsic(extrinsic) {
        return (0, extrinsic_1.encodeExtrinsic)(extrinsic, this.description, this.scaleCodec);
    }
    decodeCall(bytes) {
        return this.scaleCodec.decodeBinary(this.description.call, bytes);
    }
    encodeCall(call) {
        return this.scaleCodec.encodeToBinary(this.description.call, call);
    }
    toCallRecord(call) {
        return this.toRecord(call, this.calls);
    }
    toEventRecord(event) {
        return this.toRecord(event, this.events);
    }
    toRecord(item, registry) {
        let name = item.__kind + "." + item.value.__kind;
        let args;
        let def = registry.get(name);
        if (def.fields[0]?.name == null) {
            args = item.value.value;
        }
        else {
            let { __kind, ...props } = item.value;
            args = props;
        }
        return { name, args };
    }
    toDecodedCall(call) {
        return this.toDecoded(call, this.calls);
    }
    toDecodedEvent(event) {
        return this.toDecoded(event, this.events);
    }
    toDecoded(rec, registry) {
        let qn = (0, util_1.parseQualifiedName)(rec.name);
        let def = registry.get(rec.name);
        if (def.fields[0]?.name == null) {
            return {
                __kind: qn[0],
                value: {
                    __kind: qn[1],
                    value: rec.args
                }
            };
        }
        else {
            return {
                __kind: qn[0],
                value: {
                    __kind: qn[1],
                    ...rec.args
                }
            };
        }
    }
    /**
     * @deprecated
     */
    decodeCallRecordArguments(call) {
        return this.decodeJsonCallRecordArguments(call);
    }
    /**
     * @deprecated
     */
    decodeEventRecordArguments(event) {
        return this.decodeJsonEventRecordArguments(event);
    }
    decodeJsonCallRecordArguments(call) {
        let def = this.calls.get(call.name);
        return this.decodeJsonArgs(def, call.args);
    }
    decodeJsonEventRecordArguments(event) {
        let def = this.events.get(event.name);
        return this.decodeJsonArgs(def, event.args);
    }
    decodeJsonArgs(def, args) {
        if (def.fields.length == 0)
            return undefined;
        if (def.fields[0].name == null)
            return this.decodeJsonTuple(def.fields, args);
        (0, assert_1.default)(args != null && typeof args == 'object', 'invalid args');
        let result = {};
        for (let i = 0; i < def.fields.length; i++) {
            let f = def.fields[i];
            let name = (0, util_internal_1.assertNotNull)(f.name);
            result[name] = this.jsonCodec.decode(f.type, args[name]);
        }
        return result;
    }
    decodeJsonTuple(fields, args) {
        if (fields.length == 1) {
            return this.jsonCodec.decode(fields[0].type, args);
        }
        else {
            (0, assert_1.default)(Array.isArray(args) && fields.length == args.length, 'invalid args');
            let result = new Array(fields.length);
            for (let i = 0; i < fields.length; i++) {
                result[i] = this.jsonCodec.decode(fields[i].type, args[i]);
            }
            return result;
        }
    }
    hasEvent(name) {
        return this.events.has(name);
    }
    hasCall(name) {
        return this.calls.has(name);
    }
    checkEventType(name, ty) {
        return this.events.checkType(name, ty);
    }
    checkCallType(name, ty) {
        return this.calls.checkType(name, ty);
    }
    checkType(ti, ty) {
        return sts.match(this.description.types, ti, ty);
    }
    checkConstantType(name, ty) {
        let qn = (0, util_1.parseQualifiedName)(name);
        let def = this.description.constants[qn[0]]?.[qn[1]];
        if (def == null)
            return false;
        return this.checkType(def.type, ty);
    }
    checkStorageType(name, modifier, key, valueTy) {
        let qn = (0, util_1.parseQualifiedName)(name);
        let def = this.description.storage[qn[0]]?.items[qn[1]];
        if (def == null)
            return false;
        if (Array.isArray(modifier)) {
            if (!modifier.includes(def.modifier))
                return false;
        }
        else {
            if (def.modifier != modifier)
                return false;
        }
        if (def.keys.length !== key.length)
            return false;
        for (let i = 0; i < key.length; i++) {
            if (!this.checkType(def.keys[i], key[i]))
                return false;
        }
        return this.checkType(def.value, valueTy);
    }
}
exports.Runtime = Runtime;
//# sourceMappingURL=runtime.js.map