import { Codec as ScaleCodec, JsonCodec, Ti } from '@subsquid/scale-codec';
import * as sts from '@subsquid/scale-type-system';
import { Bytes, Metadata, OldSpecsBundle, OldTypesBundle, RuntimeDescription, StorageItem } from '../metadata';
import { EACRegistry } from './events-and-calls';
import { CallRecord, DecodedCall, DecodedEvent, EventRecord, Extrinsic, JsonArgs, QualifiedName, RpcClient, RuntimeVersionId } from './interfaces';
export declare class Runtime {
    private _rpc?;
    readonly specName: string;
    readonly specVersion: number;
    readonly implName: string;
    readonly implVersion: number;
    readonly metadata: Metadata;
    readonly description: RuntimeDescription;
    readonly events: EACRegistry;
    readonly calls: EACRegistry;
    readonly scaleCodec: ScaleCodec;
    readonly jsonCodec: JsonCodec;
    private constantValueCache;
    private storageFallbackCache;
    constructor(runtimeVersion: RuntimeVersionId, metadata: Bytes | Uint8Array | Metadata, typesBundle?: OldTypesBundle | OldSpecsBundle, _rpc?: RpcClient | undefined);
    get rpc(): RpcClient;
    hasStorageItem(name: QualifiedName): boolean;
    private _getStorageItem;
    encodeStorageKey(name: QualifiedName, ...key: any[]): Bytes;
    private _decodeStorageKey;
    private _decodeStorageValue;
    decodeStorageValue(name: QualifiedName, value?: Bytes | Uint8Array | null): any;
    getStorageFallback(name: QualifiedName): any;
    getStorage(blockHash: string, name: QualifiedName, ...key: any[]): Promise<any>;
    queryStorage(blockHash: string, name: QualifiedName, keys?: any[]): Promise<any[]>;
    getStorageKeys(blockHash: string, name: QualifiedName, ...args: any[]): Promise<any[]>;
    getStorageRawKeys(blockHash: string, name: QualifiedName, ...args: any[]): Promise<Bytes[]>;
    getStorageKeysPaged(pageSize: number, blockHash: string, name: QualifiedName, ...args: any[]): AsyncIterable<any[]>;
    getStoragePairs(blockHash: string, name: QualifiedName, ...args: any[]): Promise<[key: any, value: any][]>;
    getStoragePairsPaged(pageSize: number, blockHash: string, name: QualifiedName, ...args: any[]): AsyncIterable<[key: any, value: any][]>;
    private decodeStoragePair;
    hasConstant(name: QualifiedName): boolean;
    getConstant(name: QualifiedName): any;
    private getConstantDefinition;
    decodeExtrinsic(bytes: Bytes | Uint8Array): Extrinsic;
    encodeExtrinsic(extrinsic: Extrinsic): Uint8Array;
    decodeCall(bytes: Bytes | Uint8Array): DecodedCall;
    encodeCall(call: DecodedCall): Uint8Array;
    toCallRecord(call: DecodedCall): CallRecord;
    toEventRecord(event: DecodedEvent): EventRecord;
    private toRecord;
    toDecodedCall(call: CallRecord): DecodedCall;
    toDecodedEvent(event: EventRecord): DecodedEvent;
    private toDecoded;
    /**
     * @deprecated
     */
    decodeCallRecordArguments(call: CallRecord<JsonArgs>): any;
    /**
     * @deprecated
     */
    decodeEventRecordArguments(event: EventRecord<JsonArgs>): any;
    decodeJsonCallRecordArguments(call: CallRecord<JsonArgs>): any;
    decodeJsonEventRecordArguments(event: EventRecord<JsonArgs>): any;
    private decodeJsonArgs;
    private decodeJsonTuple;
    hasEvent(name: QualifiedName): boolean;
    hasCall(name: QualifiedName): boolean;
    checkEventType(name: QualifiedName, ty: sts.Type): boolean;
    checkCallType(name: QualifiedName, ty: sts.Type): boolean;
    checkType(ti: Ti, ty: sts.Type): boolean;
    checkConstantType(name: QualifiedName, ty: sts.Type): boolean;
    checkStorageType(name: QualifiedName, modifier: StorageItem['modifier'] | StorageItem['modifier'][], key: sts.Type[], valueTy: sts.Type): boolean;
}
//# sourceMappingURL=runtime.d.ts.map