"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.decodeValue = exports.decodeKey = exports.encodeKey = exports.encodeName = exports.getKeyHash = exports.getNameHash = void 0;
const scale_codec_1 = require("@subsquid/scale-codec");
const util_internal_1 = require("@subsquid/util-internal");
const util_internal_hex_1 = require("@subsquid/util-internal-hex");
const util_xxhash_1 = require("@subsquid/util-xxhash");
const assert_1 = __importDefault(require("assert"));
const blake2b_1 = __importDefault(require("blake2b"));
const NAME_HASHES = {};
function getNameHash(name) {
    let hash = NAME_HASHES[name];
    if (hash == null) {
        let digest = (0, util_xxhash_1.xxhash128)().update(name).digest();
        let sink = new scale_codec_1.HexSink();
        sink.u128(digest);
        hash = NAME_HASHES[name] = sink.toHex();
    }
    return hash;
}
exports.getNameHash = getNameHash;
function getKeyHash(hasher, key) {
    switch (hasher) {
        case 'Identity':
            return (0, util_internal_hex_1.toHex)(key);
        case 'Blake2_128':
            return (0, util_internal_hex_1.toHex)((0, blake2b_1.default)(16).update(key).digest());
        case 'Blake2_256':
            return (0, util_internal_hex_1.toHex)((0, blake2b_1.default)(32).update(key).digest());
        case 'Blake2_128Concat': {
            let digest = (0, blake2b_1.default)(16).update(key).digest();
            return (0, util_internal_hex_1.toHex)(digest) + (0, util_internal_hex_1.toHex)(key).slice(2);
        }
        case 'Twox64Concat': {
            let digest = (0, util_xxhash_1.xxhash64)().update(key).digest();
            let sink = new scale_codec_1.HexSink();
            sink.u64(digest);
            sink.bytes(key);
            return sink.toHex();
        }
        case 'Twox128': {
            let digest = (0, util_xxhash_1.xxhash128)().update(key).digest();
            let sink = new scale_codec_1.HexSink();
            sink.u128(digest);
            return sink.toHex();
        }
        case 'Twox256': {
            let digest = (0, util_xxhash_1.xxhash256)().update(key).digest();
            let sink = new scale_codec_1.HexSink();
            sink.u256(digest);
            return sink.toHex();
        }
        default:
            throw (0, util_internal_1.unexpectedCase)(hasher);
    }
}
exports.getKeyHash = getKeyHash;
function encodeName(prefix, name) {
    return getNameHash(prefix) + getNameHash(name).slice(2);
}
exports.encodeName = encodeName;
function encodeKey(codec, prefix, name, item, key) {
    (0, assert_1.default)(key.length <= item.hashers.length);
    let encoding = getNameHash(prefix) + getNameHash(name).slice(2);
    for (let i = 0; i < key.length; i++) {
        encoding += getKeyHash(item.hashers[i], codec.encodeToBinary(item.keys[i], key[i])).slice(2);
    }
    return encoding;
}
exports.encodeKey = encodeKey;
function decodeKey(codec, item, key) {
    let res = [];
    let src = new scale_codec_1.Src(key);
    src.skip(32);
    for (let i = 0; i < item.keys.length; i++) {
        switch (item.hashers[i]) {
            case 'Identity':
                break;
            case 'Blake2_128Concat':
                src.skip(16);
                break;
            case 'Twox64Concat':
                src.skip(8);
                break;
            case 'Blake2_128':
            case 'Twox128':
            case 'Blake2_256':
            case 'Twox256':
                throw new Error(`Original value of storage item key can't be restored from ${item.hashers[i]} encoding`);
            default:
                throw (0, util_internal_1.unexpectedCase)(item.hashers[i]);
        }
        res.push(codec.decode(item.keys[i], src));
    }
    src.assertEOF();
    return res;
}
exports.decodeKey = decodeKey;
function decodeValue(codec, item, value) {
    if (value == null) {
        switch (item.modifier) {
            case 'Optional':
                return undefined;
            case 'Default':
                value = item.fallback;
                break;
            case 'Required':
                throw new Error(`Required storage item not found`);
            default:
                throw (0, util_internal_1.unexpectedCase)(item.modifier);
        }
    }
    return codec.decodeBinary(item.value, value);
}
exports.decodeValue = decodeValue;
//# sourceMappingURL=storage.js.map