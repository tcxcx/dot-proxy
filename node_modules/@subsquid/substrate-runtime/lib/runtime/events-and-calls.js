"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.EACRegistry = void 0;
const scale_type_system_1 = require("@subsquid/scale-type-system");
const assert_1 = __importDefault(require("assert"));
const metadata_1 = require("../metadata");
class EACRegistry {
    constructor(types, ti) {
        this.types = types;
        this.definitions = {};
        this.typeRecords = {};
        let pallets = types[ti];
        (0, assert_1.default)(pallets.kind == metadata_1.TypeKind.Variant);
        pallets.variants.forEach(pallet => {
            (0, assert_1.default)(pallet.fields.length == 1);
            let palletType = types[pallet.fields[0].type];
            (0, assert_1.default)(palletType.kind == metadata_1.TypeKind.Variant);
            palletType.variants.forEach(def => {
                this.definitions[`${pallet.name}.${def.name}`] = {
                    ...def,
                    pallet: pallet.name
                };
            });
        });
    }
    has(name) {
        return this.definitions[name] != null;
    }
    get(name) {
        let def = this.definitions[name];
        if (def == null)
            throw new Error(`${name} not found`);
        return def;
    }
    checkType(name, ty) {
        if (!this.has(name))
            return false;
        let rec = this.getTypeRecord(name);
        let ok = rec.checks.get(ty);
        if (ok == null) {
            ok = ty.match((0, scale_type_system_1.getTypeChecker)(this.types), rec.scaleType);
            rec.checks.set(ty, ok);
        }
        return ok;
    }
    getTypeRecord(name) {
        let rec = this.typeRecords[name];
        if (rec == null) {
            rec = this.typeRecords[name] = {
                scaleType: this.createScaleType(name),
                checks: new WeakMap()
            };
        }
        return rec;
    }
    createScaleType(name) {
        let def = this.get(name);
        if (def.fields.length == 0)
            return {
                kind: metadata_1.TypeKind.Tuple,
                tuple: []
            };
        if (def.fields[0].name == null) {
            if (def.fields.length == 1) {
                return this.types[def.fields[0].type];
            }
            else {
                return {
                    kind: metadata_1.TypeKind.Tuple,
                    tuple: def.fields.map(f => {
                        (0, assert_1.default)(f.name == null);
                        return f.type;
                    })
                };
            }
        }
        else {
            return {
                kind: metadata_1.TypeKind.Composite,
                fields: def.fields
            };
        }
    }
    getTypeHash(name) {
        let rec = this.getTypeRecord(name);
        return (0, scale_type_system_1.getTypeHash)(this.types, rec.scaleType);
    }
}
exports.EACRegistry = EACRegistry;
//# sourceMappingURL=events-and-calls.js.map