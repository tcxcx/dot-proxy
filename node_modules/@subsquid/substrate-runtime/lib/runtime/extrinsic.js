"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.encodeExtrinsic = exports.decodeExtrinsic = void 0;
const scale_codec_1 = require("@subsquid/scale-codec");
const util_internal_1 = require("@subsquid/util-internal");
const assert_1 = __importDefault(require("assert"));
var Preamble;
(function (Preamble) {
    Preamble[Preamble["Bare"] = 0] = "Bare";
    Preamble[Preamble["Signed"] = 128] = "Signed";
})(Preamble || (Preamble = {}));
function decodeExtrinsic(rawExtrinsic, runtimeDescription, codec) {
    codec = codec || new scale_codec_1.Codec(runtimeDescription.types);
    let src = new scale_codec_1.Src(rawExtrinsic);
    src.compact();
    let meta = src.u8();
    let version = meta & 0b01111111;
    (0, assert_1.default)([4, 5].includes(version), 'unsupported extrinsic version');
    let preamble = meta & 0b11000000;
    switch (preamble) {
        case Preamble.Bare:
            return {
                version,
                call: codec.decode(runtimeDescription.call, src)
            };
        case Preamble.Signed:
            (0, assert_1.default)(version == 4, 'signed extrinsics only supported for v4');
            return {
                version,
                signature: codec.decode(runtimeDescription.signature, src),
                call: codec.decode(runtimeDescription.call, src)
            };
        default:
            throw (0, util_internal_1.unexpectedCase)(preamble);
    }
}
exports.decodeExtrinsic = decodeExtrinsic;
function encodeExtrinsic(extrinsic, runtimeDescription, codec) {
    (0, assert_1.default)(extrinsic.version == 4, 'unsupported extrinsic version');
    codec = codec || new scale_codec_1.Codec(runtimeDescription.types);
    let sink = new scale_codec_1.ByteSink();
    let meta = 4;
    if (extrinsic.signature) {
        meta |= 0b10000000;
    }
    sink.u8(meta);
    if (extrinsic.signature) {
        codec.encode(runtimeDescription.signature, extrinsic.signature, sink);
    }
    codec.encode(runtimeDescription.call, extrinsic.call, sink);
    let bytes = sink.toBytes();
    sink = new scale_codec_1.ByteSink();
    sink.compact(bytes.length);
    sink.bytes(bytes);
    return sink.toBytes();
}
exports.encodeExtrinsic = encodeExtrinsic;
function encodeToSink(sink, extrinsic, chainDescription, codec) {
    (0, assert_1.default)(extrinsic.version == 4, 'unsupported extrinsic version');
    codec = codec || new scale_codec_1.Codec(chainDescription.types);
    let meta = 4;
    if (extrinsic.signature) {
        meta |= 0b10000000;
    }
    sink.u8(meta);
    if (extrinsic.signature) {
        codec.encode(chainDescription.signature, extrinsic.signature, sink);
    }
    codec.encode(chainDescription.call, extrinsic.call, sink);
}
//# sourceMappingURL=extrinsic.js.map