"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.HttpContext = void 0;
const assert_1 = __importDefault(require("assert"));
const http_1 = __importDefault(require("http"));
const string_decoder_1 = require("string_decoder");
const http_error_1 = require("./http-error");
class HttpContext {
    constructor(request, response, params, options) {
        this.request = request;
        this.response = response;
        this.params = params;
        this.options = options;
        this.requestBodyConsumed = false;
    }
    get url() {
        if (this._url == null) {
            this._url = new URL(this.request.url, `http://localhost/`);
        }
        return this._url;
    }
    send(status, body, contentType) {
        body = body || http_1.default.STATUS_CODES[status] || '';
        contentType = contentType || this.response.getHeader('content-type')?.toString();
        if (typeof body == 'object' && !(body instanceof Uint8Array)) {
            body = JSON.stringify(body);
            contentType = contentType || 'application/json';
        }
        let len;
        if (typeof body == 'string') {
            contentType = contentType || 'text/plain';
            contentType += '; charset=UTF-8';
            len = Buffer.byteLength(body);
        }
        else {
            len = body.length;
        }
        this.response.writeHead(status, {
            'content-type': contentType,
            'content-length': len
        }).end(body);
    }
    getContentLength() {
        let val = this.request.headers['content-length'];
        if (val == null)
            return;
        let len = parseInt(val, 10);
        if (Number.isSafeInteger(len) && len >= 0)
            return len;
        throw new http_error_1.HttpError(400, 'invalid content-length header');
    }
    async getText() {
        let body = '';
        let decoder = new string_decoder_1.StringDecoder('utf-8'); // FIXME: handle charset
        await this.consume(buf => {
            body += decoder.write(buf);
        });
        body += decoder.end();
        return body;
    }
    consume(cb) {
        return new Promise((resolve, reject) => {
            (0, assert_1.default)(!this.requestBodyConsumed);
            this.requestBodyConsumed = true;
            let len = this.getContentLength();
            let limit = this.options.maxRequestBody;
            if (len != null && len > limit)
                return reject(new http_error_1.HttpError(413));
            let received = 0;
            let onData = (data) => {
                received += data.length;
                if (len != null && received > len) {
                    this.request.off('data', onData);
                    reject(new http_error_1.HttpError(400, 'request body exceeded content-length'));
                }
                else if (received > limit) {
                    this.request.off('data', onData);
                    reject(new http_error_1.HttpError(413));
                }
                else {
                    cb(data);
                }
            };
            this.request.on('data', onData);
            this.request.on('end', () => {
                if (len == null || len == received) {
                    resolve();
                }
                else {
                    reject(new http_error_1.HttpError(400, 'request body did not match content-length'));
                }
            });
            this.request.on('error', reject);
        });
    }
    async getJson() {
        let text = await this.getText();
        try {
            return JSON.parse(text);
        }
        catch (err) {
            throw new http_error_1.HttpError(400, 'expected JSON body');
        }
    }
}
exports.HttpContext = HttpContext;
//# sourceMappingURL=ctx.js.map