"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.HttpApp = void 0;
const logger_1 = require("@subsquid/logger");
const assert_1 = __importDefault(require("assert"));
const ctx_1 = require("./ctx");
const http_error_1 = require("./http-error");
const path_pattern_1 = require("./path-pattern");
const server_1 = require("./server");
class HttpApp {
    constructor() {
        this.routes = [];
        this.loggingNamespace = 'sqd:http-server';
        this.ctx = {
            maxRequestBody: 1024 * 1024
        };
        this.serverOptions = {};
    }
    add(path, resource) {
        this.routes.push({
            path: new path_pattern_1.PathPattern(path),
            resource
        });
        return this;
    }
    setMaxRequestBody(bytes) {
        (0, assert_1.default)(bytes > 0);
        this.ctx.maxRequestBody = bytes;
        return this;
    }
    setLogger(log) {
        this._log = log;
        return this;
    }
    setLoggingNamespace(ns) {
        this.loggingNamespace = ns;
        return this;
    }
    setSocketTimeout(ms) {
        this.serverOptions.socketTimeout = ms;
        return this;
    }
    get log() {
        if (this._log)
            return this._log;
        return this._log = (0, logger_1.createLogger)(this.loggingNamespace);
    }
    listen(port = 0) {
        return (0, server_1.createHttpServer)((req, res) => {
            this.handle(req, res).catch(err => this.handleSystemError(err, req, res));
        }, {
            ...this.serverOptions,
            port
        });
    }
    async handle(req, res) {
        let ctx = new ctx_1.HttpContext(req, res, {}, this.ctx);
        let path = ctx.url.pathname;
        for (let route of this.routes) {
            let params = route.path.match(path);
            if (params) {
                ctx.params = params;
                return this.handleResource(ctx, route.resource).catch(err => {
                    this.handleError(err, ctx);
                });
            }
        }
        ctx.send(404, `${path} not found`);
    }
    async handleResource(ctx, resource) {
        let method = ctx.request.method;
        let res = resource;
        if (res[method])
            return res[method](ctx);
        if (method == 'HEAD' && res['GET'])
            return res['GET'](ctx);
        // Handle OPTIONS
        ctx.response.setHeader('allow', allowedMethods(Object.keys(resource)));
        if (method == 'OPTIONS') {
            ctx.send(204);
        }
        else {
            ctx.send(405, `${method} is not allowed`);
        }
    }
    handleError(err, ctx) {
        if (ctx.response.headersSent) {
            this.handleSystemError(err, ctx.request, ctx.response);
        }
        else if ((0, http_error_1.isHttpError)(err)) {
            if (err.headers) {
                for (let name in err.headers) {
                    ctx.response.setHeader(name, err.headers[name]);
                }
            }
            ctx.send(err.status, err.body);
        }
        else {
            this.handleSystemError(err, ctx.request, ctx.response);
        }
    }
    handleSystemError(err, req, res) {
        err = ensureError(err);
        this.log.error(err);
        if (res.headersSent) {
            res.destroy();
        }
        else {
            clearHeaders(res);
            let body = 'Internal server error\n\n' + err.stack;
            res.writeHead(500, {
                'content-type': 'text/plain; charset=UTF-8',
                'content-length': Buffer.byteLength(body)
            }).end(body);
        }
    }
}
exports.HttpApp = HttpApp;
function allowedMethods(methods) {
    let options = new Set(methods);
    if (options.has('GET')) {
        options.add('HEAD');
    }
    options.add('OPTIONS');
    return Array.from(options).sort().join(', ');
}
function clearHeaders(res) {
    for (let name of res.getHeaderNames()) {
        res.removeHeader(name);
    }
}
class NonErrorThrow extends Error {
    constructor(value) {
        super('Non-error object was thrown');
        this.value = value;
    }
}
function ensureError(val) {
    if (val instanceof Error) {
        return val;
    }
    else {
        return new NonErrorThrow(val);
    }
}
//# sourceMappingURL=app.js.map