"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.safeCall = exports.concurrentWriter = exports.concurrentMap = exports.AsyncQueue = exports.ClosedQueueError = exports.createFuture = void 0;
const assert_1 = __importDefault(require("assert"));
const process = __importStar(require("process"));
const misc_1 = require("./misc");
function createFuture() {
    let future;
    let promise = new Promise((resolve, reject) => {
        future = {
            resolve,
            reject,
            promise: () => promise
        };
    });
    return (0, misc_1.assertNotNull)(future);
}
exports.createFuture = createFuture;
class ClosedQueueError extends Error {
    constructor() {
        super('Queue was closed, no more puts are allowed!');
    }
    get name() {
        return 'AsyncQueueWasClosed';
    }
}
exports.ClosedQueueError = ClosedQueueError;
class AsyncQueue {
    constructor(maxsize) {
        this.pos = 0;
        this.size = 0;
        this.closed = false;
        (0, assert_1.default)(maxsize >= 1);
        this.buf = new Array(maxsize);
    }
    isClosed() {
        return this.closed;
    }
    async put(val) {
        if (this.closed)
            throw new ClosedQueueError();
        (0, assert_1.default)(this.size < this.buf.length && this.putFuture == null, 'concurrent puts are not allowed');
        if (this.takeFuture) {
            this.takeFuture.resolve(val);
            this.takeFuture = undefined;
        }
        else {
            this.buf[(this.pos + this.size) % this.buf.length] = val;
            this.size += 1;
            if (this.size == this.buf.length) {
                this.putFuture = createFuture();
                await this.putFuture.promise();
            }
        }
    }
    forcePut(val) {
        if (this.closed)
            throw new ClosedQueueError();
        if (this.takeFuture) {
            this.takeFuture.resolve(val);
            this.takeFuture = undefined;
        }
        else if (this.size < this.buf.length) {
            this.buf[(this.pos + this.size) % this.buf.length] = val;
            this.size += 1;
        }
        else {
            this.buf[(this.pos + this.size - 1) % this.buf.length] = val;
        }
    }
    tryPut(val) {
        this.put(val).catch(err => { });
    }
    async take() {
        if (this.size > 0) {
            let val = this.buf[this.pos];
            this.buf[this.pos] = undefined;
            this.pos = (this.pos + 1) % this.buf.length;
            this.size -= 1;
            if (this.putFuture) {
                this.putFuture.resolve();
                this.putFuture = undefined;
            }
            return val;
        }
        else if (this.closed) {
            return undefined;
        }
        else {
            (0, assert_1.default)(this.takeFuture == null, 'concurrent takes are not allowed');
            this.takeFuture = createFuture();
            return this.takeFuture.promise();
        }
    }
    peek() {
        return this.buf[this.pos];
    }
    close() {
        this.closed = true;
        if (this.putFuture) {
            this.putFuture.reject(new ClosedQueueError());
            this.putFuture = undefined;
        }
        if (this.takeFuture) {
            this.takeFuture.resolve(undefined);
            this.takeFuture = undefined;
        }
        if (this.closeListeners) {
            for (let cb of this.closeListeners) {
                safeCall(cb);
            }
            this.closeListeners = undefined;
        }
    }
    addCloseListener(cb) {
        if (this.closed)
            return process.nextTick(() => safeCall(cb));
        if (this.closeListeners == null) {
            this.closeListeners = [cb];
        }
        else {
            this.closeListeners.push(cb);
        }
    }
    async *iterate() {
        try {
            while (true) {
                let val = await this.take();
                if (val === undefined)
                    return;
                yield val;
            }
        }
        finally {
            this.close();
        }
    }
}
exports.AsyncQueue = AsyncQueue;
async function* concurrentMap(concurrency, stream, f) {
    let queue = new AsyncQueue(concurrency);
    async function map() {
        for await (let val of stream) {
            let promise = f(val);
            promise.catch(() => { }); // prevent unhandled rejection crashes
            await queue.put({ promise });
        }
    }
    map().then(() => queue.close(), err => {
        let promise = Promise.reject(err);
        promise.catch(() => { }); // prevent unhandled rejection crashes
        queue.tryPut({ promise });
    });
    for await (let item of queue.iterate()) {
        yield await item.promise;
    }
}
exports.concurrentMap = concurrentMap;
async function* concurrentWriter(watermark, cb) {
    (0, assert_1.default)(watermark >= 1);
    let queue = new AsyncQueue(watermark);
    cb(value => queue.put(value)).then(() => queue.close(), err => {
        if (!queue.isClosed()) {
            queue.forcePut((0, misc_1.ensureError)(err));
        }
    });
    for await (let valueOrError of queue.iterate()) {
        if (valueOrError instanceof Error)
            throw valueOrError;
        yield valueOrError;
    }
}
exports.concurrentWriter = concurrentWriter;
function safeCall(cb) {
    try {
        cb();
    }
    catch (err) {
        Promise.reject(err);
    }
}
exports.safeCall = safeCall;
//# sourceMappingURL=async.js.map