export interface Future<T> {
    resolve: (val: T) => void;
    reject: (err: Error) => void;
    promise: () => Promise<T>;
}
export declare function createFuture<T>(): Future<T>;
export declare class ClosedQueueError extends Error {
    constructor();
    get name(): string;
}
export declare class AsyncQueue<T> {
    private buf;
    private pos;
    private size;
    private closed;
    private putFuture?;
    private takeFuture?;
    private closeListeners?;
    constructor(maxsize: number);
    isClosed(): boolean;
    put(val: T): Promise<void>;
    forcePut(val: T): void;
    tryPut(val: T): void;
    take(): Promise<T | undefined>;
    peek(): T | undefined;
    close(): void;
    addCloseListener(cb: () => void): void;
    iterate(): AsyncIterable<T>;
}
export declare function concurrentMap<T, R>(concurrency: number, stream: AsyncIterable<T>, f: (val: T) => Promise<R>): AsyncIterable<R>;
export declare function concurrentWriter<T>(watermark: number, cb: (write: (val: T) => Promise<void>) => Promise<void>): AsyncIterable<T>;
export declare function safeCall(cb: () => void): void;
//# sourceMappingURL=async.d.ts.map