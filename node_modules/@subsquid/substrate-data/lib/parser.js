"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.MissingStorageValue = exports.Parser = void 0;
const substrate_data_raw_1 = require("@subsquid/substrate-data-raw");
const util_internal_1 = require("@subsquid/util-internal");
const util_internal_ingest_tools_1 = require("@subsquid/util-internal-ingest-tools");
const util_internal_range_1 = require("@subsquid/util-internal-range");
const block_1 = require("./parsing/block");
const calc_1 = require("./parsing/fee/calc");
const runtime_tracker_1 = require("./runtime-tracker");
const storage_1 = require("./storage");
class Parser {
    constructor(rpc, requests, typesBundle, skipBlocks) {
        this.rpc = rpc;
        this.requests = requests;
        this.skipBlocks = skipBlocks;
        this.prevValidators = new substrate_data_raw_1.Prev();
        this.runtimeTracker = new runtime_tracker_1.RuntimeTracker(this.rpc, block => ({
            height: block.height,
            hash: block.hash,
            parentHash: block.block.block.header.parentHash
        }), block => (0, util_internal_1.assertNotNull)(block.runtimeVersion), typesBundle);
    }
    async parseCold(blocks) {
        await this.parse(blocks);
        (0, util_internal_ingest_tools_1.assertIsValid)(blocks);
        return blocks.map(b => (0, util_internal_1.assertNotNull)(b.parsed));
    }
    async parse(blocks) {
        if (blocks.length == 0)
            return;
        await this.runtimeTracker.setRuntime(blocks);
        blocks = (0, util_internal_ingest_tools_1.trimInvalid)(blocks);
        for (let batch of (0, util_internal_range_1.splitBlocksByRequest)(this.requests, blocks, b => b.height)) {
            let batchBlocks = batch.blocks;
            if (batch.request?.blockValidator) {
                await this.setValidators(batchBlocks);
                batchBlocks = (0, util_internal_ingest_tools_1.trimInvalid)(batchBlocks);
            }
            if (batch.request?.extrinsics?.fee) {
                for (let [runtime, blocks] of (0, util_internal_1.groupBy)(batchBlocks, b => b.runtime).entries()) {
                    if (!runtime.hasEvent('TransactionPayment.TransactionFeePaid') && (0, calc_1.supportsFeeCalc)(runtime)) {
                        await this.setFeeMultiplier(blocks);
                    }
                }
                batchBlocks = (0, util_internal_ingest_tools_1.trimInvalid)(batchBlocks);
            }
            for (let block of batchBlocks) {
                await this.parseBlock(block, batch.request);
                if (block._isInvalid)
                    return;
            }
        }
    }
    async parseBlock(rawBlock, options) {
        while (true) {
            try {
                if (this.skipBlocks?.includes(rawBlock.height)) {
                    options = disableBlockItems(options);
                }
                rawBlock.parsed = (0, block_1.parseBlock)(rawBlock, options ?? {});
                return;
            }
            catch (err) {
                if (err instanceof MissingStorageValue) {
                    let val = await this.rpc.getStorage(err.key, rawBlock.block.block.header.parentHash);
                    if (val === undefined) {
                        rawBlock._isInvalid = true;
                        return;
                    }
                    let storage = rawBlock.storage || (rawBlock.storage = {});
                    storage[err.key] = val;
                }
                else {
                    throw (0, util_internal_1.addErrorContext)(err, getRefCtx(rawBlock));
                }
            }
        }
    }
    async setValidators(blocks) {
        blocks = blocks.filter(b => storage_1.STORAGE.validators.isDefined(b));
        if (blocks.length == 0 || blocks[0]._isInvalid)
            return;
        let prev;
        let maybePrev = this.prevValidators.get(blocks[0].height);
        if (maybePrev == null) {
            maybePrev = await this.fetchValidators(blocks[0]);
            if (maybePrev == null)
                return (0, util_internal_ingest_tools_1.setInvalid)(blocks);
            prev = maybePrev;
        }
        else {
            prev = maybePrev;
        }
        let last = blocks.length - 1;
        let lastBlock;
        while (last >= 0) {
            lastBlock = blocks[last];
            if (lastBlock.session == null) {
                let session = await storage_1.STORAGE.sessionIndex.get(this.rpc, lastBlock);
                if (session === undefined) {
                    last -= 1;
                }
                else {
                    lastBlock.session = session;
                    break;
                }
            }
            else {
                break;
            }
        }
        if (lastBlock == null)
            return (0, util_internal_ingest_tools_1.setInvalid)(blocks);
        for (let i = 0; i <= last; i++) {
            let block = blocks[i];
            if (prev.session == lastBlock.session) {
                block.session = prev.session;
            }
            else {
                let session = await storage_1.STORAGE.sessionIndex.get(this.rpc, block);
                if (session === undefined)
                    return (0, util_internal_ingest_tools_1.setInvalid)(blocks, i);
                block.session = session;
            }
            if (prev.session == block.session) {
                block.session = prev.session;
                block.validators = prev.validators;
            }
            else {
                let maybePrev = await this.fetchValidators(block);
                if (maybePrev == null)
                    return (0, util_internal_ingest_tools_1.setInvalid)(blocks, i);
                prev = maybePrev;
            }
        }
        if (last + 1 < blocks.length) {
            (0, util_internal_ingest_tools_1.setInvalid)(blocks, last + 1);
        }
    }
    async fetchValidators(block) {
        let [session, validators] = await Promise.all([
            block.session ? Promise.resolve(block.session) : storage_1.STORAGE.sessionIndex.get(this.rpc, block),
            storage_1.STORAGE.validators.get(this.rpc, block)
        ]);
        if (session === undefined || validators === undefined)
            return;
        block.session = session;
        block.validators = validators;
        let item = { session, validators };
        this.prevValidators.set(block.height, item);
        return item;
    }
    async setFeeMultiplier(blocks) {
        let values = await this.rpc.getStorageMany(blocks.map(b => {
            let parentHash = b.height == 0 ? b.hash : b.block.block.header.parentHash;
            return [storage_1.STORAGE.nextFeeMultiplier.key(), parentHash];
        }));
        for (let i = 0; i < blocks.length; i++) {
            let value = values[i];
            let block = blocks[i];
            if (value === undefined) {
                block._isInvalid = true;
            }
            else {
                block.feeMultiplier = storage_1.STORAGE.nextFeeMultiplier.decode(block, value);
            }
        }
    }
}
exports.Parser = Parser;
__decorate([
    (0, util_internal_1.annotateAsyncError)(getRefCtx),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object]),
    __metadata("design:returntype", Promise)
], Parser.prototype, "fetchValidators", null);
function getRefCtx(ref) {
    return {
        blockHeight: ref.height,
        blockHash: ref.hash
    };
}
function disableBlockItems(options) {
    let request = { ...options };
    delete request.events;
    delete request.extrinsics;
    return request;
}
class MissingStorageValue extends Error {
    constructor(key) {
        super();
        this.key = key;
    }
    get name() {
        return 'MissingStorageValue';
    }
}
exports.MissingStorageValue = MissingStorageValue;
//# sourceMappingURL=parser.js.map