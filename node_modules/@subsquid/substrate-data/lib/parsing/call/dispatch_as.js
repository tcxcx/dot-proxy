"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.visitDispatchAs = visitDispatchAs;
exports.unwrapDispatchAs = unwrapDispatchAs;
const sts_1 = require("@subsquid/substrate-runtime/lib/sts");
const system_1 = require("../../types/system");
const util_1 = require("../../types/util");
const DispatchAs_Origin = (0, sts_1.struct)({
    asOrigin: system_1.Origin
});
const Result = (0, sts_1.closedEnum)({
    Ok: (0, sts_1.unknown)(),
    Err: (0, sts_1.unknown)()
});
const DispatchedAsLatest = (0, sts_1.struct)({ result: Result });
const DispatchedAsLegacy = Result;
function visitDispatchAs(cp, call) {
    (0, util_1.assertCall)(cp.runtime, DispatchAs_Origin, call);
    let sub = cp.getSubcall(call, call.args.asOrigin);
    cp.visitSubcall(sub, (runtime, event) => {
        if (event.name != 'Utility.DispatchedAs')
            return;
        let result;
        if ((0, util_1.isEvent)(runtime, DispatchedAsLatest, event)) {
            result = event.args.result;
        }
        else if ((0, util_1.isEvent)(runtime, DispatchedAsLegacy, event)) {
            result = event.args;
        }
        else {
            throw new util_1.UnexpectedEventType('Utility.DispatchedAs');
        }
        switch (result.__kind) {
            case 'Ok':
                return { ok: true };
            case 'Err':
                return { ok: false, error: result.value };
        }
    });
}
function unwrapDispatchAs(cp, call, success) {
    (0, util_1.assertCall)(cp.runtime, DispatchAs_Origin, call);
    let sub = cp.getSubcall(call, call.args.asOrigin);
    cp.unwrap(sub, success);
}
//# sourceMappingURL=dispatch_as.js.map