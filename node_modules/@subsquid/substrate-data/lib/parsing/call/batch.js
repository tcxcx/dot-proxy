"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.visitBatch = visitBatch;
exports.visitBatchAll = visitBatchAll;
exports.visitForceBatch = visitForceBatch;
const sts_1 = require("@subsquid/substrate-runtime/lib/sts");
const assert_1 = __importDefault(require("assert"));
const util_1 = require("../../types/util");
const PolymeshBatchCompleted = (0, sts_1.array)((0, sts_1.number)());
const BatchInterrupted = (0, sts_1.union)((0, sts_1.struct)({
    index: (0, sts_1.number)(),
    error: (0, sts_1.unknown)()
}), (0, sts_1.tuple)([(0, sts_1.number)(), (0, sts_1.unknown)()]));
function BATCH_CALL_END(runtime, event) {
    switch (event.name) {
        case 'Utility.BatchCompleted':
            return { ok: true };
        case 'Utility.BatchInterrupted':
            (0, util_1.assertEvent)(runtime, BatchInterrupted, event);
            let failedItemIndex;
            let error;
            if (Array.isArray(event.args)) {
                failedItemIndex = event.args[0];
                error = event.args[1];
            }
            else {
                failedItemIndex = event.args.index;
                error = event.args.error;
            }
            return {
                ok: false,
                failedItemIndex,
                error
            };
    }
}
function ITEM_COMPLETED(runtime, event) {
    return event.name == 'Utility.ItemCompleted';
}
function visitBatch(cp, call) {
    (0, assert_1.default)(call.name == 'Utility.batch');
    if (cp.runtime.checkEventType('Utility.BatchCompleted', PolymeshBatchCompleted)) {
        // Polymesh batch calls are different
        return;
    }
    let items = cp.getSubcalls(call);
    let result = cp.get(BATCH_CALL_END);
    if (result.ok) {
        visitBatchItems(cp, items);
    }
    else {
        cp.visitFailedCall(items[result.failedItemIndex], result.error);
        visitBatchItems(cp, items.slice(0, result.failedItemIndex));
    }
}
function visitBatchItems(cp, items) {
    if (items.length == 0)
        return;
    if (cp.runtime.hasEvent('Utility.ItemCompleted')) {
        for (let i = items.length - 1; i >= 0; i--) {
            cp.get(ITEM_COMPLETED);
            if (i > 0) {
                cp.withBoundary(ITEM_COMPLETED, () => cp.visitCall(items[i]));
            }
            else {
                cp.visitCall(items[i]);
            }
        }
    }
    else {
        // Utility.ItemCompleted doesn't exist yet
        for (let item of items) {
            cp.unwrap(item, true);
        }
    }
}
function visitBatchAll(cp, call) {
    (0, assert_1.default)(call.name == 'Utility.batch_all');
    cp.get((_rt, e) => e.name == 'Utility.BatchCompleted');
    let items = cp.getSubcalls(call);
    visitBatchItems(cp, items);
}
function FORCE_BATCH_CALL_END(runtime, event) {
    switch (event.name) {
        case 'Utility.BatchCompleted':
        case 'Utility.BatchCompletedWithErrors':
            return true;
        default:
            return false;
    }
}
const ItemFailed = (0, sts_1.struct)({
    error: (0, sts_1.unknown)()
});
function FORCE_BATCH_ITEM(runtime, event) {
    switch (event.name) {
        case 'Utility.ItemCompleted':
            return { ok: true };
        case 'Utility.ItemFailed':
            (0, util_1.assertEvent)(runtime, ItemFailed, event);
            return {
                ok: false,
                error: event.args.error
            };
    }
}
function visitForceBatch(cp, call) {
    (0, assert_1.default)(call.name == 'Utility.force_batch');
    cp.get(FORCE_BATCH_CALL_END);
    let items = cp.getSubcalls(call);
    for (let i = items.length - 1; i >= 0; i--) {
        let item = items[i];
        let result = cp.get(FORCE_BATCH_ITEM);
        if (result.ok) {
            if (i > 0) {
                cp.withBoundary(FORCE_BATCH_ITEM, () => cp.visitCall(item));
            }
            else {
                cp.visitCall(item);
            }
        }
        else {
            cp.visitFailedCall(item, result.error);
        }
    }
}
//# sourceMappingURL=batch.js.map