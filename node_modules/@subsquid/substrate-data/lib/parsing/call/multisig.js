"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.visitAsMulti = visitAsMulti;
exports.visitApproveAsMulti = visitApproveAsMulti;
const sts_1 = require("@subsquid/substrate-runtime/lib/sts");
const util_internal_1 = require("@subsquid/util-internal");
const util_internal_hex_1 = require("@subsquid/util-internal-hex");
const assert_1 = __importDefault(require("assert"));
const parser_1 = require("../../parser");
const util_1 = require("../../types/util");
const util_2 = require("../util");
const Result = (0, sts_1.closedEnum)({
    Ok: (0, sts_1.unknown)(),
    Err: (0, sts_1.unknown)()
});
const MultisigExecuted = (0, sts_1.union)((0, sts_1.struct)({
    multisig: (0, sts_1.bytes)(),
    callHash: (0, sts_1.bytes)(),
    result: Result
}), (0, sts_1.tuple)([(0, sts_1.unknown)(), (0, sts_1.unknown)(), (0, sts_1.bytes)(), (0, sts_1.bytes)(), Result]));
function MULTISIG_EXECUTED(runtime, event) {
    if (event.name != 'Multisig.MultisigExecuted')
        return;
    (0, util_1.assertEvent)(runtime, MultisigExecuted, event);
    let multisig;
    let callHash;
    let result;
    if (Array.isArray(event.args)) {
        multisig = event.args[2];
        callHash = event.args[3];
        result = event.args[4];
    }
    else {
        multisig = event.args.multisig;
        callHash = event.args.callHash;
        result = event.args.result;
    }
    switch (result.__kind) {
        case 'Ok':
            return {
                ok: true,
                multisig,
                callHash
            };
        case 'Err':
            return {
                ok: false,
                error: result.value,
                multisig,
                callHash
            };
        default:
            throw (0, util_internal_1.unexpectedCase)();
    }
}
function visitAsMulti(cp, call) {
    if (!cp.isPresent(MULTISIG_EXECUTED))
        return;
    let result = cp.get(MULTISIG_EXECUTED);
    let sub = cp.getSubcall(call, (0, util_2.signedOrigin)(result.multisig));
    if (result.ok) {
        cp.visitCall(sub);
    }
    else {
        cp.visitFailedCall(sub, result.error);
    }
}
const ApproveAsMulti = (0, sts_1.struct)({
    callHash: (0, sts_1.bytes)()
});
const CallsStorageValue = (0, sts_1.tuple)([(0, sts_1.bytes)(), (0, sts_1.unknown)(), (0, sts_1.unknown)()]);
function visitApproveAsMulti(cp, call) {
    if (!cp.isPresent(MULTISIG_EXECUTED))
        return;
    let result = cp.get(MULTISIG_EXECUTED);
    (0, util_1.assertCall)(cp.runtime, ApproveAsMulti, call);
    (0, util_1.assertStorage)(cp.runtime, 'Multisig.Calls', ['Optional'], [(0, sts_1.bytes)()], CallsStorageValue);
    let key = cp.runtime.encodeStorageKey('Multisig.Calls', result.callHash);
    let value = cp.block.storage?.[key];
    if (value === undefined)
        throw new parser_1.MissingStorageValue(key);
    let subCallBytes = cp.runtime.decodeStorageValue('Multisig.Calls', value)?.[0];
    (0, assert_1.default)((0, util_internal_hex_1.isHex)(subCallBytes));
    let subCall = cp.runtime.decodeCall(subCallBytes);
    let sub = cp.createCall(call.extrinsicIndex, call.address.concat([0]), subCall, (0, util_2.signedOrigin)(result.multisig));
    if (result.ok) {
        cp.visitCall(sub);
    }
    else {
        cp.visitFailedCall(sub, result.error);
    }
}
//# sourceMappingURL=multisig.js.map