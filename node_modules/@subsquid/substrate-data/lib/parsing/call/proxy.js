"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.visitProxy = visitProxy;
exports.unwrapProxy = unwrapProxy;
const sts_1 = require("@subsquid/substrate-runtime/lib/sts");
const system_1 = require("../../types/system");
const util_1 = require("../../types/util");
const util_2 = require("../util");
const Proxy_RealAddress = (0, sts_1.struct)({
    real: system_1.Address
});
const Result = (0, sts_1.closedEnum)({
    Ok: (0, sts_1.unknown)(),
    Err: (0, sts_1.unknown)()
});
const ProxyExecutedLatest = (0, sts_1.struct)({ result: Result });
const ProxyExecutedLegacy = Result;
function visitProxy(cp, call) {
    let sub = getSubcall(cp, call);
    return cp.visitSubcall(sub, (runtime, event) => {
        if (event.name != 'Proxy.ProxyExecuted')
            return;
        let result;
        if ((0, util_1.isEvent)(runtime, ProxyExecutedLatest, event)) {
            result = event.args.result;
        }
        else if ((0, util_1.isEvent)(runtime, ProxyExecutedLegacy, event)) {
            result = event.args;
        }
        else {
            throw new util_1.UnexpectedEventType('Proxy.ProxyExecuted');
        }
        switch (result.__kind) {
            case 'Ok':
                return { ok: true };
            case 'Err':
                return { ok: false, error: result.value };
        }
    });
}
function getSubcall(cp, call) {
    (0, util_1.assertCall)(cp.runtime, Proxy_RealAddress, call);
    let origin = (0, util_2.addressOrigin)(call.args.real) ?? null;
    return cp.getSubcall(call, origin);
}
function unwrapProxy(cp, call, success) {
    let sub = getSubcall(cp, call);
    cp.unwrap(sub, success);
}
//# sourceMappingURL=proxy.js.map