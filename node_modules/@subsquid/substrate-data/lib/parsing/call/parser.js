"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.CallParser = void 0;
const sts_1 = require("@subsquid/substrate-runtime/lib/sts");
const util_internal_1 = require("@subsquid/util-internal");
const assert_1 = __importDefault(require("assert"));
const system_1 = require("../../types/system");
const util_1 = require("../../types/util");
const util_2 = require("../util");
const batch_1 = require("./batch");
const dispatch_as_1 = require("./dispatch_as");
const multisig_1 = require("./multisig");
const proxy_1 = require("./proxy");
const sudo_1 = require("./sudo");
const ExtrinsicFailed = (0, sts_1.union)((0, sts_1.struct)({ dispatchError: (0, sts_1.unknown)() }), (0, sts_1.tuple)([(0, sts_1.unknown)(), (0, sts_1.unknown)()]));
const CallWrapper = (0, sts_1.struct)({
    call: (0, sts_1.union)((0, sts_1.externalEnum)(), (0, sts_1.bytes)())
});
const CallListWrapper = (0, sts_1.struct)({
    calls: (0, sts_1.array)((0, sts_1.externalEnum)())
});
class CallParser {
    constructor(runtime, block, extrinsics, events) {
        this.runtime = runtime;
        this.block = block;
        this.extrinsics = extrinsics;
        this.events = events;
        this.calls = [];
        this.eventPos = events.length - 1;
    }
    parse() {
        for (let i = this.extrinsics.length - 1; i >= 0; i--) {
            this.extrinsic = this.extrinsics[i].extrinsic;
            let origin;
            if (this.extrinsic.signature && this.runtime.checkType(this.runtime.description.address, system_1.Address)) {
                origin = (0, util_2.addressOrigin)(this.extrinsic.signature.address);
            }
            let call = {
                extrinsicIndex: i,
                address: [],
                ...this.extrinsics[i].call,
                origin
            };
            let event = this.next();
            switch (event.name) {
                case 'System.ExtrinsicSuccess':
                    this.extrinsic.success = true;
                    this.visitCall(call);
                    break;
                case 'System.ExtrinsicFailed':
                    let err = this.getExtrinsicFailedError(event);
                    this.extrinsic.success = false;
                    this.extrinsic.error = err;
                    this.visitFailedCall(call, err);
                    this.takeEvents();
                    break;
                default:
                    throw (0, util_internal_1.unexpectedCase)(event.name);
            }
        }
        return this.calls.reverse();
    }
    getExtrinsicFailedError(event) {
        (0, assert_1.default)(event.name == 'System.ExtrinsicFailed');
        (0, util_1.assertEvent)(this.runtime, ExtrinsicFailed, event);
        if (Array.isArray(event.args)) {
            return event.args[1];
        }
        else {
            return event.args.dispatchError;
        }
    }
    createCall(extrinsicIndex, address, src, origin) {
        let { name, args } = this.runtime.toCallRecord(src);
        return {
            extrinsicIndex,
            address,
            name,
            args,
            origin
        };
    }
    visitCall(call) {
        call.success = true;
        this.calls.push(call);
        let parentAddress = this.address;
        this.address = call.address;
        switch (call.name) {
            case 'Multisig.as_multi':
                (0, multisig_1.visitAsMulti)(this, call);
                break;
            case 'Multisig.approve_as_multi':
                (0, multisig_1.visitApproveAsMulti)(this, call);
                break;
            case 'Multisig.as_multi_threshold_1':
                // FIXME: compute origin
                this.visitCall(this.getSubcall(call, null));
                break;
            case 'Utility.batch':
                (0, batch_1.visitBatch)(this, call);
                break;
            case 'Utility.batch_all':
                (0, batch_1.visitBatchAll)(this, call);
                break;
            case 'Utility.force_batch':
                (0, batch_1.visitForceBatch)(this, call);
                break;
            case 'Utility.dispatch_as':
                (0, dispatch_as_1.visitDispatchAs)(this, call);
                break;
            case 'Utility.as_derivative':
            case 'Utility.as_sub':
            case 'Utility.as_limited_sub':
                // FIXME: compute origin
                this.visitCall(this.getSubcall(call, null));
                break;
            case 'Proxy.proxy':
            case 'Proxy.proxy_announced':
                (0, proxy_1.visitProxy)(this, call);
                break;
            case 'Sudo.sudo':
            case 'Sudo.sudo_unchecked_weight':
                (0, sudo_1.visitSudo)(this, call);
                break;
            case 'Sudo.sudo_as':
                (0, sudo_1.visitSudoAs)(this, call);
                break;
        }
        this.takeEvents();
        this.address = parentAddress;
    }
    visitSubcall(call, boundary) {
        let result = this.get(boundary);
        if (result.ok) {
            this.visitCall(call);
        }
        else {
            this.visitFailedCall(call, result.error);
        }
    }
    visitFailedCall(call, error) {
        call.success = false;
        call.error = error;
        this.calls.push(call);
    }
    unwrap(call, success) {
        this.calls.push(call);
        call.success = success;
        let parentAddress = this.address;
        this.address = call.address;
        switch (call.name) {
            case 'Utility.batch':
            case 'Utility.batch_all':
            case 'Utility.force_batch':
                for (let sub of this.getSubcalls(call)) {
                    this.unwrap(sub, success);
                }
                break;
            case 'Utility.dispatch_as':
                (0, dispatch_as_1.unwrapDispatchAs)(this, call, success);
                break;
            case 'Utility.as_derivative':
            case 'Utility.as_sub':
            case 'Utility.as_limited_sub':
            case 'Multisig.as_multi':
            case 'Multisig.as_multi_threshold_1': {
                let sub = this.getSubcall(call, null);
                this.unwrap(sub, success);
                break;
            }
            case 'Proxy.proxy':
            case 'Proxy.proxy_announced':
                (0, proxy_1.unwrapProxy)(this, call, success);
                break;
            case 'Sudo.sudo':
            case 'Sudo.sudo_unchecked_weight':
                (0, sudo_1.unwrapSudo)(this, call, success);
                break;
            case 'Sudo.sudo_as':
                (0, sudo_1.unwrapSudoAs)(this, call, success);
                break;
        }
        this.address = parentAddress;
    }
    getSubcalls(call, origin) {
        if (origin === undefined) {
            origin = call.origin;
        }
        (0, util_1.assertCall)(this.runtime, CallListWrapper, call);
        let subcalls = call.args.calls;
        return subcalls.map((sub, idx) => {
            return this.createCall(call.extrinsicIndex, call.address.concat([idx]), sub, origin ?? undefined);
        });
    }
    getSubcall(call, origin) {
        if (origin === undefined) {
            origin = call.origin;
        }
        (0, util_1.assertCall)(this.runtime, CallWrapper, call);
        let sub = call.args.call;
        if (typeof sub == 'string') {
            sub = this.runtime.decodeCall(sub);
        }
        return this.createCall(call.extrinsicIndex, call.address.concat([0]), sub, origin ?? undefined);
    }
    withBoundary(boundary, cb) {
        let current = this.boundary;
        this.boundary = boundary;
        try {
            return cb();
        }
        finally {
            this.boundary = current;
        }
    }
    get(boundary) {
        while (true) {
            let event = this.next();
            event.callAddress = this.address;
            let match = boundary(this.runtime, event);
            if (match)
                return match;
        }
    }
    isPresent(boundary) {
        let pos = this.eventPos;
        try {
            let event;
            while (event = this.maybeNext()) {
                if (this.boundary?.(this.runtime, event)) {
                    return false;
                }
                if (boundary(this.runtime, event)) {
                    return true;
                }
            }
            return false;
        }
        finally {
            this.eventPos = pos;
        }
    }
    takeEvents() {
        let event;
        while (event = this.maybeNext()) {
            if (this.boundary?.(this.runtime, event)) {
                this.eventPos += 1;
                return;
            }
            else {
                event.callAddress = this.address;
            }
        }
    }
    next() {
        return (0, util_internal_1.assertNotNull)(this.maybeNext(), 'missing required event');
    }
    maybeNext() {
        while (this.eventPos >= 0) {
            let event = this.events[this.eventPos];
            if (event.phase === 'ApplyExtrinsic') {
                if (event.extrinsicIndex !== this.extrinsic.index) {
                    if (event.name.includes('Migrations.')) {
                        let index = (0, util_internal_1.assertNotNull)(event.extrinsicIndex);
                        // Besides `Migrations.*` events there can be more parachain-defined events,
                        // so we skip all events related to the "phantom" extrinsic.
                        this.skipExtrinsicEvents(index);
                        continue;
                    }
                    else {
                        return;
                    }
                }
                this.eventPos -= 1;
                return event;
            }
            else {
                this.eventPos -= 1;
            }
        }
    }
    skipExtrinsicEvents(extrinsicIndex) {
        while (true) {
            let event = this.events[this.eventPos];
            if (event.extrinsicIndex == extrinsicIndex) {
                this.eventPos -= 1;
            }
            else {
                break;
            }
        }
    }
}
exports.CallParser = CallParser;
//# sourceMappingURL=parser.js.map