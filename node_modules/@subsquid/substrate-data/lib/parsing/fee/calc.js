"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.supportsFeeCalc = supportsFeeCalc;
exports.getFeeCalc = getFeeCalc;
const util_internal_1 = require("@subsquid/util-internal");
const calc_1 = require("@substrate/calc");
const storage_1 = require("../../storage");
const types_1 = require("./types");
function supportsFeeCalc(runtime) {
    return getFactory(runtime).isAvailable();
}
function getFeeCalc(runtime, feeMultiplier, specName, specVersion) {
    return getFactory(runtime).get(feeMultiplier, specName, specVersion);
}
const cache = new WeakMap();
function getFactory(runtime) {
    let factory = cache.get(runtime);
    if (factory == null) {
        factory = new CalcFactory(runtime);
        cache.set(runtime, factory);
    }
    return factory;
}
class CalcFactory {
    constructor(runtime) {
        this.runtime = runtime;
    }
    isAvailable() {
        return this.hasNextFeeMultiplier()
            && this.baseWeights() != null
            && this.createCalc(1, this.runtime.specName, this.runtime.specVersion) != null;
    }
    hasNextFeeMultiplier() {
        return storage_1.STORAGE.nextFeeMultiplier.check(this.runtime);
    }
    get(feeMultiplier, specName, specVersion) {
        if (!this.hasNextFeeMultiplier())
            return;
        const baseWeights = this.baseWeights();
        if (baseWeights == null)
            return;
        const calc = this.createCalc(feeMultiplier, specName, specVersion);
        if (calc == null)
            return;
        return (dispatchInfo, len) => {
            if (!paysFee(dispatchInfo))
                return undefined;
            let baseWeight = baseWeights[dispatchInfo.class.__kind];
            let fee = calc.calc_fee(dispatchInfo.weight, len, baseWeight);
            return BigInt(fee);
        };
    }
    createCalc(feeMultiplier, specName, specVersion) {
        let coefficients = this.coefficients();
        if (coefficients == null)
            return;
        let perByteFee = this.perByteFee();
        if (perByteFee == null)
            return;
        return calc_1.CalcFee.from_params(coefficients, feeMultiplier.toString(), perByteFee.toString(), specName, specVersion);
    }
    perByteFee() {
        let val = this.getConst('TransactionPayment.TransactionByteFee', types_1.TransactionByteFeeConst);
        if (val != null)
            return val;
        let lengthToFee = this.getConst('TransactionPayment.LengthToFee', types_1.LengthToFeeConst);
        return lengthToFee?.[0].coeffInteger;
    }
    baseWeights() {
        let perClass = this.getConst('System.BlockWeights', types_1.BlockWeightsConst);
        if (perClass)
            return {
                Normal: BigInt(perClass.perClass.normal.baseExtrinsic),
                Operational: BigInt(perClass.perClass.operational.baseExtrinsic),
                Mandatory: BigInt(perClass.perClass.mandatory.baseExtrinsic)
            };
        let baseWeight = this.getConst('System.ExtrinsicBaseWeight', types_1.ExtrinsicBaseWeightConst);
        if (baseWeight)
            return {
                Normal: BigInt(baseWeight),
                Operational: BigInt(baseWeight),
                Mandatory: BigInt(baseWeight)
            };
    }
    coefficients() {
        let weightToFee = this.getConst('TransactionPayment.WeightToFee', types_1.WeightToFeeConst);
        return weightToFee?.map(c => {
            return {
                coeffInteger: String(c.coeffInteger),
                coeffFrac: c.coeffFrac,
                degree: c.degree,
                negative: c.negative
            };
        });
    }
    getConst(name, ty) {
        if (this.runtime.checkConstantType(name, ty)) {
            return this.runtime.getConstant(name);
        }
    }
}
__decorate([
    util_internal_1.def,
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Boolean)
], CalcFactory.prototype, "isAvailable", null);
__decorate([
    util_internal_1.def,
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Boolean)
], CalcFactory.prototype, "hasNextFeeMultiplier", null);
__decorate([
    util_internal_1.def,
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Object)
], CalcFactory.prototype, "perByteFee", null);
__decorate([
    util_internal_1.def,
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Object)
], CalcFactory.prototype, "baseWeights", null);
__decorate([
    util_internal_1.def,
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Object)
], CalcFactory.prototype, "coefficients", null);
function paysFee(dispatchInfo) {
    if (typeof dispatchInfo.paysFee == 'boolean') {
        return dispatchInfo.paysFee;
    }
    else {
        return dispatchInfo.paysFee.__kind == 'Yes';
    }
}
//# sourceMappingURL=calc.js.map