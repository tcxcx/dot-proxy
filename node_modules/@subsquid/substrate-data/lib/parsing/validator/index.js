"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getBlockValidator = getBlockValidator;
const scale_codec_1 = require("@subsquid/scale-codec");
const util_internal_hex_1 = require("@subsquid/util-internal-hex");
const BABE_ENGINE = (0, util_internal_hex_1.toHex)(Buffer.from('BABE'));
const AURA_ENGINE = (0, util_internal_hex_1.toHex)(Buffer.from('aura'));
const POW_ENGINE = (0, util_internal_hex_1.toHex)(Buffer.from('pow_'));
function getBlockValidator(digestLog, validators) {
    let preRuntime;
    let consensus;
    let seal;
    for (let item of digestLog) {
        switch (item.__kind) {
            case 'PreRuntime':
                preRuntime = item.value;
                break;
            case 'Consensus':
                consensus = item.value;
                break;
            case 'Seal':
                seal = item.value;
                break;
        }
    }
    return preRuntime && fromMessage(preRuntime, validators)
        || consensus && fromMessage(consensus, validators)
        || seal && fromMessage(seal, validators);
}
function fromMessage(msg, validators) {
    let [engine, data] = msg;
    switch (engine) {
        case BABE_ENGINE: {
            let src = new scale_codec_1.Src(data);
            src.u8();
            let idx = src.u32();
            return validators[idx];
        }
        case AURA_ENGINE: {
            let src = new scale_codec_1.Src(data);
            let slot = src.u64();
            if (validators.length) {
                let idx = Number(slot % BigInt(validators.length));
                return validators[idx];
            }
            break;
        }
        case POW_ENGINE: {
            if (data.length == 20 * 2 + 2)
                return data;
        }
    }
}
//# sourceMappingURL=index.js.map