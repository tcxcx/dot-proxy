"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.setEthereumTransact = setEthereumTransact;
exports.setEvmLog = setEvmLog;
const sts_1 = require("@subsquid/substrate-runtime/lib/sts");
const util_1 = require("../types/util");
const TransactionAction = (0, sts_1.closedEnum)({
    Call: (0, sts_1.bytes)(),
    Create: (0, sts_1.unit)()
});
const Transaction = (0, sts_1.struct)({
    action: TransactionAction,
    input: (0, sts_1.bytes)()
});
const TransactionV2 = (0, sts_1.closedEnum)({
    Legacy: Transaction,
    EIP2930: Transaction,
    EIP1559: Transaction
});
const EthereumTransactLegacy = (0, sts_1.struct)({
    transaction: Transaction
});
const EthereumTransactLatest = (0, sts_1.struct)({
    transaction: TransactionV2
});
const EvmLogLegacy = (0, sts_1.struct)({
    address: (0, sts_1.bytes)(),
    topics: (0, sts_1.array)((0, sts_1.bytes)())
});
const EvmLogLatest = (0, sts_1.struct)({
    log: EvmLogLegacy
});
function setEthereumTransact(runtime, call) {
    if (call.name != 'Ethereum.transact')
        return;
    let tx;
    if ((0, util_1.isCall)(runtime, EthereumTransactLegacy, call)) {
        tx = call.args.transaction;
    }
    else if ((0, util_1.isCall)(runtime, EthereumTransactLatest, call)) {
        tx = call.args.transaction.value;
    }
    else {
        throw new util_1.UnexpectedCallType('Ethereum.transact');
    }
    call._ethereumTransactSighash = tx.input.slice(0, 10);
    if (tx.action.__kind == 'Call') {
        call._ethereumTransactTo = tx.action.value;
    }
}
function setEvmLog(runtime, event) {
    if (event.name != 'EVM.Log')
        return;
    let log;
    if ((0, util_1.isEvent)(runtime, EvmLogLegacy, event)) {
        log = event.args;
    }
    else if ((0, util_1.isEvent)(runtime, EvmLogLatest, event)) {
        log = event.args.log;
    }
    else {
        throw new util_1.UnexpectedEventType('EVM.Log');
    }
    event._evmLogAddress = log.address;
    event._evmLogTopics = log.topics;
}
//# sourceMappingURL=evm.js.map