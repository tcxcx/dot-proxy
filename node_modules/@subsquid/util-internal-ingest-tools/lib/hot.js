"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.HotProcessor = void 0;
const util_internal_1 = require("@subsquid/util-internal");
const assert_1 = __importDefault(require("assert"));
class HotProcessor {
    constructor(state, options) {
        this.o = options;
        this.chain = [state, ...state.top];
        for (let i = 1; i < this.chain.length; i++) {
            (0, assert_1.default)(this.chain[i].height == this.chain[i - 1].height + 1);
        }
    }
    getHeight() {
        return (0, util_internal_1.last)(this.chain).height;
    }
    getFinalizedHeight() {
        return Math.max(this.chain[0].height, this.getPassedFinalizedHeight());
    }
    getPassedFinalizedHeight() {
        if (this.finalizedHead == null)
            return 0;
        if (this.finalizedHead.height == null) {
            return this.chain.find(h => h.hash === this.finalizedHead?.hash)?.height ?? 0;
        }
        else {
            return this.finalizedHead.height;
        }
    }
    async goto(heads) {
        if (this.isKnownBlock(heads.best))
            return;
        this.finalizedHead = heads.finalized;
        for await (let blocks of this.o.getBlockRange(this.getHeight() + 1, heads.best)) {
            await this.moveToBlocks(blocks);
        }
    }
    isKnownBlock(ref) {
        if (ref.height == null) {
            return !!this.chain.find(b => b.hash === ref.hash);
        }
        else {
            if (ref.height <= this.chain[0].height)
                return true;
            if (ref.hash == null)
                return ref.height < this.getHeight();
            let pos = ref.height - this.chain[0].height;
            return this.chain[pos]?.hash === ref.hash;
        }
    }
    async moveToBlocks(blocks) {
        if (blocks.length == 0)
            return;
        for (let i = 1; i < blocks.length; i++) {
            (0, assert_1.default)(this.o.getHeader(blocks[i - 1]).hash === this.o.getHeader(blocks[i]).parentHash);
        }
        let newBlocks = blocks.slice().reverse();
        let head = getParent(this.o.getHeader(blocks[0]));
        (0, assert_1.default)(head.height >= this.chain[0].height);
        let chain = this.chain.slice(0, head.height - this.chain[0].height + 1);
        while ((0, util_internal_1.last)(chain).height < head.height) {
            let block = await this.o.getBlock(head);
            newBlocks.push(block);
            head = getParent(this.o.getHeader(block));
        }
        (0, assert_1.default)((0, util_internal_1.last)(chain).height === head.height);
        while ((0, util_internal_1.last)(chain).hash !== head.hash) {
            let block = await this.o.getBlock(head);
            newBlocks.push(block);
            head = getParent(this.o.getHeader(block));
            chain.pop();
        }
        newBlocks = newBlocks.reverse();
        for (let block of newBlocks) {
            chain.push(this.o.getHeader(block));
        }
        chain = await this.finalize(chain);
        let baseHead = newBlocks.length
            ? getParent(this.o.getHeader(newBlocks[0]))
            : (0, util_internal_1.last)(chain);
        await this.o.process({
            baseHead,
            finalizedHead: chain[0],
            blocks: newBlocks
        });
        this.chain = chain;
    }
    async finalize(chain) {
        if (this.finalizedHead == null)
            return chain;
        let finalizedHeight;
        if (this.finalizedHead.height == null) {
            finalizedHeight = chain.find(b => b.hash == this.finalizedHead?.hash)?.height
                || await this.getFinalizedBlockHeight(this.finalizedHead.hash);
            this.finalizedHead = {
                height: finalizedHeight,
                hash: this.finalizedHead.hash
            };
        }
        else {
            finalizedHeight = this.finalizedHead.height;
        }
        let pos = finalizedHeight - chain[0].height;
        if (this.finalizedHead.hash && 0 <= pos && pos < chain.length) {
            (0, assert_1.default)(chain[pos].hash === this.finalizedHead.hash);
        }
        pos = Math.min(pos, chain.length - 1);
        if (pos > 0) {
            return chain.slice(pos);
        }
        else {
            return chain;
        }
    }
    getFinalizedBlockHeight(blockHash) {
        if (this.o.getFinalizedBlockHeight == null)
            throw new Error(`.getFinalizedBlockHeight() method is not available`);
        return this.o.getFinalizedBlockHeight(blockHash);
    }
}
exports.HotProcessor = HotProcessor;
function getParent(hdr) {
    return {
        hash: hdr.parentHash,
        height: hdr.height - 1
    };
}
//# sourceMappingURL=hot.js.map