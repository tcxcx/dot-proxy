import { BlockHeader, Hash, HashAndHeight, HotState, HotUpdate } from './interfaces';
import { BlockRef } from './ref';
export interface ChainHeads {
    best: BlockRef;
    finalized: BlockRef;
}
export interface HotProcessorOptions<B> {
    process(update: HotUpdate<B>): Promise<void>;
    getBlock(ref: HashAndHeight): Promise<B>;
    /**
     * This method must handle situations where `from > to`,
     * in such cases `from` must be coerced to `to`.
     */
    getBlockRange(from: number, to: BlockRef): AsyncIterable<B[]>;
    getHeader(block: B): BlockHeader;
    getFinalizedBlockHeight?(hash: Hash): Promise<number>;
}
export declare class HotProcessor<B> {
    private o;
    private chain;
    private finalizedHead?;
    constructor(state: HotState, options: HotProcessorOptions<B>);
    getHeight(): number;
    getFinalizedHeight(): number;
    private getPassedFinalizedHeight;
    goto(heads: ChainHeads): Promise<void>;
    private isKnownBlock;
    private moveToBlocks;
    private finalize;
    private getFinalizedBlockHeight;
}
//# sourceMappingURL=hot.d.ts.map