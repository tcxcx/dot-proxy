"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.toCodecTypes = exports.getCodecType = void 0;
const assert_1 = __importDefault(require("assert"));
const types_1 = require("./types");
const util_1 = require("./util");
function getCodecType(types, ti) {
    let def = types[ti];
    switch (def.kind) {
        case types_1.TypeKind.Compact: {
            let compact = types[def.type];
            (0, assert_1.default)(compact.kind == types_1.TypeKind.Primitive);
            (0, assert_1.default)(compact.primitive[0] == 'U');
            return { kind: types_1.TypeKind.Compact, integer: compact.primitive };
        }
        case types_1.TypeKind.Composite:
            if (def.fields.length == 0 || def.fields[0].name == null) {
                return {
                    kind: types_1.TypeKind.Tuple,
                    tuple: def.fields.map(f => {
                        (0, assert_1.default)(f.name == null);
                        return f.type;
                    })
                };
            }
            else {
                return {
                    kind: types_1.TypeKind.Struct,
                    fields: def.fields.map(f => {
                        let name = (0, util_1.assertNotNull)(f.name);
                        return { name, type: f.type };
                    })
                };
            }
        case types_1.TypeKind.Variant: {
            let variants = def.variants.filter(v => v != null);
            let variantsByName = {};
            let uniqueIndexes = new Set(variants.map(v => v.index));
            if (uniqueIndexes.size != variants.length) {
                throw new Error(`Variant type ${ti} has duplicate case indexes`);
            }
            let len = variants.reduce((len, v) => Math.max(len, v.index), 0) + 1;
            let placedVariants = new Array(len);
            variants.forEach(v => {
                let cv;
                if (v.fields[0]?.name == null) {
                    switch (v.fields.length) {
                        case 0:
                            cv = { kind: 'empty', name: v.name, index: v.index };
                            break;
                        case 1:
                            cv = { kind: 'value', name: v.name, index: v.index, type: v.fields[0].type };
                            break;
                        default:
                            cv = {
                                kind: 'tuple',
                                name: v.name,
                                index: v.index,
                                def: {
                                    kind: types_1.TypeKind.Tuple,
                                    tuple: v.fields.map(f => {
                                        (0, assert_1.default)(f.name == null);
                                        return f.type;
                                    })
                                }
                            };
                    }
                }
                else {
                    cv = {
                        kind: 'struct',
                        name: v.name,
                        index: v.index,
                        def: {
                            kind: types_1.TypeKind.Struct,
                            fields: v.fields.map(f => {
                                let name = (0, util_1.assertNotNull)(f.name);
                                return { name, type: f.type };
                            })
                        }
                    };
                }
                placedVariants[v.index] = cv;
                variantsByName[cv.name] = cv;
            });
            return {
                kind: types_1.TypeKind.Variant,
                variants: placedVariants,
                variantsByName
            };
        }
        default:
            return def;
    }
}
exports.getCodecType = getCodecType;
function toCodecTypes(types) {
    let codecTypes = new Array(types.length);
    for (let i = 0; i < types.length; i++) {
        codecTypes[i] = getCodecType(types, i);
    }
    return codecTypes;
}
exports.toCodecTypes = toCodecTypes;
//# sourceMappingURL=types-codec.js.map