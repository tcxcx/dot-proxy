"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.isMissingBlockError = exports.captureMissingBlock = exports.Rpc = void 0;
const rpc_client_1 = require("@subsquid/rpc-client");
const util_1 = require("./util");
class Rpc {
    constructor(client, options = {}) {
        this.client = client;
        this.options = options;
    }
    withPriority(priority) {
        return new Rpc(this.client, {
            ...this.options,
            priority
        });
    }
    call(method, params, options) {
        return this.client.call(method, params, { ...this.options, ...options });
    }
    batchCall(batch, options) {
        return this.client.batchCall(batch, { ...this.options, ...options });
    }
    getFinalizedHead() {
        return this.call('chain_getFinalizedHead');
    }
    getHead() {
        return this.call('chain_getHead');
    }
    getBlockHash(height) {
        return this.call('chain_getBlockHash', [(0, util_1.toQty)(height)]);
    }
    getBlockHeader(blockHash) {
        return this.call('chain_getHeader', [blockHash]);
    }
    getBlock(blockHash) {
        return this.call('chain_getBlock', [blockHash]);
    }
    getRuntimeVersion(blockHash) {
        return this.call('state_getRuntimeVersion', [blockHash], {
            validateError: captureMissingBlock
        });
    }
    getMetadata(blockHash) {
        return this.call('state_getMetadata', [blockHash], {
            validateError: captureMissingBlock
        });
    }
    getStorage(key, blockHash) {
        return this.call('state_getStorageAt', [key, blockHash], {
            validateError: captureMissingBlock
        });
    }
    getStorageMany(query) {
        let call = query.map(q => ({
            method: 'state_getStorageAt',
            params: q
        }));
        return this.batchCall(call, {
            validateError: captureMissingBlock
        });
    }
}
exports.Rpc = Rpc;
function captureMissingBlock(info) {
    if (isMissingBlockError(info)) {
        return undefined;
    }
    else {
        throw new rpc_client_1.RpcError(info);
    }
}
exports.captureMissingBlock = captureMissingBlock;
function isMissingBlockError(info) {
    return info.message.includes(' not found');
}
exports.isMissingBlockError = isMissingBlockError;
//# sourceMappingURL=rpc.js.map