"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Fetch1 = void 0;
const util_internal_1 = require("@subsquid/util-internal");
const util_internal_ingest_tools_1 = require("@subsquid/util-internal-ingest-tools");
const assert_1 = __importDefault(require("assert"));
const rpc_1 = require("./rpc");
const util_1 = require("./util");
class Fetch1 {
    constructor(rpc) {
        this.rpc = rpc;
    }
    async getColdSplit0(from, to, req) {
        let top = typeof to == 'number' ? to : to.height;
        (0, assert_1.default)(from <= top);
        let hash;
        if (typeof to == 'number') {
            hash = await this.rpc.getBlockHash(top).then(hash => {
                if (hash == null)
                    throw new util_internal_ingest_tools_1.BlockConsistencyError({ height: top });
                return hash;
            });
        }
        else {
            hash = to.hash;
        }
        let blocks = new Array(top - from + 1);
        for (let i = blocks.length - 1; i >= 0; i--) {
            let block = await this.getBlock0(hash, req);
            if (block == null)
                throw new util_internal_ingest_tools_1.BlockConsistencyError({ hash, height: from + i });
            blocks[i] = block;
            hash = block.block.block.header.parentHash;
        }
        return blocks;
    }
    async getBlock0(blockHash, req) {
        if (req.extrinsics) {
            let block = await this.rpc.getBlock(blockHash);
            if (block == null)
                return;
            return {
                height: (0, util_1.qty2Int)(block.block.header.number),
                hash: blockHash,
                block
            };
        }
        else {
            let header = await this.rpc.getBlockHeader(blockHash);
            if (header == null)
                return;
            return {
                height: (0, util_1.qty2Int)(header.number),
                hash: blockHash,
                block: {
                    block: { header }
                }
            };
        }
    }
    async getColdSplit(from, to, req) {
        let blocks = await this.getColdSplit0(from, to, req);
        await this.addRequestedData(blocks, req);
        (0, util_internal_ingest_tools_1.assertIsValid)(blocks);
        return blocks;
    }
    async getHotSplit(from, to, req) {
        let heads = await this.getHotHeads(from, to);
        await Promise.all([
            this.addBlock(heads, req),
            this.addRequestedData(heads, req)
        ]);
        let blocks = (0, util_internal_ingest_tools_1.trimInvalid)(heads);
        for (let i = 1; i < blocks.length; i++) {
            if (blocks[i].block.block.header.parentHash !== blocks[i - 1].hash)
                return blocks.slice(0, i);
        }
        return blocks;
    }
    async addBlock(blocks, req) {
        if (blocks.length == 0)
            return;
        let last = blocks.length - 1;
        let lastBlock = blocks[last];
        if (lastBlock.block && (lastBlock.block.block.extrinsics || !req.extrinsics)) {
            last -= 1;
        }
        let call = [];
        for (let i = 0; i <= last; i++) {
            let block = blocks[i];
            if (req.extrinsics) {
                call.push({
                    method: 'chain_getBlock',
                    params: [block.hash]
                });
            }
            else {
                call.push({
                    method: 'chain_getHeader',
                    params: [block.hash]
                });
            }
        }
        let batch = await this.rpc.batchCall(call);
        for (let i = 0; i < batch.length; i++) {
            let block = batch[i];
            if (block == null)
                return (0, util_internal_ingest_tools_1.setInvalid)(blocks, i);
            if (req.extrinsics) {
                blocks[i].block = block;
            }
            else {
                blocks[i].block = {
                    block: { header: block }
                };
            }
        }
    }
    async getHotHeads(from, to) {
        let top = typeof to == 'number' ? to : to.height;
        if (from > top) {
            from = top;
        }
        let blocks;
        if (typeof to == 'object') {
            if (to.block) {
                let missingHashHeight = to.height - 2;
                if (missingHashHeight - from >= 0) {
                    blocks = await this.getHashes(from, missingHashHeight);
                }
                else {
                    blocks = [];
                }
                if (from < to.height)
                    blocks.push({
                        height: to.height - 1,
                        hash: to.block.block.header.parentHash
                    });
                blocks.push(to);
            }
            else {
                let missingHashHeight = to.height - 1;
                if (missingHashHeight - from >= 0) {
                    blocks = await this.getHashes(from, missingHashHeight);
                }
                else {
                    blocks = [];
                }
                blocks.push(to);
            }
        }
        else {
            blocks = await this.getHashes(from, to);
        }
        for (let i = 1; i < blocks.length; i++) {
            if (blocks[i].height - blocks[i - 1].height != 1)
                return blocks.slice(0, i);
        }
        return blocks;
    }
    async getHashes(from, to) {
        let call = [];
        for (let height = from; height <= to; height++) {
            call.push({
                method: 'chain_getBlockHash',
                params: [(0, util_1.toQty)(height)]
            });
        }
        let hashes = await this.rpc.batchCall(call);
        let heads = [];
        for (let i = 0; i < hashes.length; i++) {
            let height = from + i;
            let hash = hashes[i];
            if (hash == null)
                return heads;
            heads.push({ hash, height });
        }
        return heads;
    }
    async addRequestedData(blocks, req) {
        if (blocks.length == 0)
            return;
        let tasks = [];
        if (req.events) {
            tasks.push(this.addEvents(blocks));
        }
        if (req.trace != null) {
            tasks.push(this.addTrace(blocks, req.trace));
        }
        if (req.runtimeVersion) {
            let block = (0, util_internal_1.last)(blocks);
            tasks.push(this.rpc.getRuntimeVersion(block.hash).then(v => {
                if (v == null) {
                    block._isInvalid = true;
                }
                else {
                    block.runtimeVersion = v;
                }
            }));
        }
        await Promise.all(tasks);
    }
    async addEvents(blocks) {
        let events = await this.rpc.getStorageMany(blocks.map(b => {
            return [
                '0x26aa394eea5630e07c48ae0c9558cef780d41e5e16056765bc8461851072c9d7',
                b.hash
            ];
        }));
        for (let i = 0; i < blocks.length; i++) {
            let bytes = events[i];
            if (bytes === undefined) {
                blocks[i]._isInvalid = true;
            }
            else {
                blocks[i].events = bytes;
            }
        }
    }
    async addTrace(blocks, targets) {
        let tasks = [];
        for (let i = 0; i < blocks.length; i++) {
            let block = blocks[i];
            if (block.height != 0) {
                tasks.push(this.rpc.call('state_traceBlock', [
                    block.hash,
                    targets,
                    '',
                    ''
                ], {
                    validateError: rpc_1.captureMissingBlock
                }).then(trace => {
                    if (trace === undefined) {
                        block._isInvalid = true;
                    }
                    else {
                        block.trace = trace;
                    }
                }));
            }
        }
        await Promise.all(tasks);
    }
}
exports.Fetch1 = Fetch1;
//# sourceMappingURL=fetch1.js.map