"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.RpcDataSource = void 0;
const logger_1 = require("@subsquid/logger");
const util_internal_1 = require("@subsquid/util-internal");
const util_internal_ingest_tools_1 = require("@subsquid/util-internal-ingest-tools");
const util_internal_range_1 = require("@subsquid/util-internal-range");
const util_timeout_1 = require("@subsquid/util-timeout");
const assert_1 = __importDefault(require("assert"));
const fetch1_1 = require("./fetch1");
const rpc_1 = require("./rpc");
const runtimeVersionTracker_1 = require("./runtimeVersionTracker");
const util_1 = require("./util");
class RpcDataSource {
    constructor(options) {
        this.rpc = new rpc_1.Rpc(options.rpc);
        this.headPollInterval = options.headPollInterval ?? 5000;
        this.newHeadTimeout = options.newHeadTimeout ?? 0;
        this.finalityConfirmation = options.finalityConfirmation;
        this.log = options.log;
    }
    async getFinalizedHeight() {
        if (this.finalityConfirmation == null) {
            let head = await this.rpc.getFinalizedHead();
            let header = await this.rpc.getBlockHeader(head);
            (0, assert_1.default)(header, 'finalized blocks must be always available');
            return (0, util_1.qty2Int)(header.number);
        }
        else {
            let header = await this.rpc.getBlockHeader();
            (0, assert_1.default)(header, 'the header of the latest block on the chain must be always available');
            return Math.max(0, (0, util_1.qty2Int)(header.number) - this.finalityConfirmation);
        }
    }
    async *getFinalizedBlocks(requests, stopOnHead) {
        (0, util_internal_range_1.assertRangeList)(requests.map(req => req.range));
        let runtimeVersionTracker = new runtimeVersionTracker_1.RuntimeVersionTracker();
        let stream = (0, util_internal_ingest_tools_1.coldIngest)({
            getFinalizedHeight: () => this.getFinalizedHeight(),
            getSplit: req => {
                let fetch = new fetch1_1.Fetch1(this.rpc.withPriority(req.range.from));
                return fetch.getColdSplit(req.range.from, req.range.to, req.request);
            },
            requests,
            concurrency: Math.min(5, this.rpc.client.getConcurrency()),
            splitSize: 10,
            stopOnHead,
            headPollInterval: this.headPollInterval
        });
        for await (let batch of stream) {
            let request = (0, util_internal_range_1.getRequestAt)(requests, batch.blocks[0].height);
            if (request?.runtimeVersion) {
                await runtimeVersionTracker.addRuntimeVersion(this.rpc, batch.blocks);
                (0, util_internal_ingest_tools_1.assertIsValid)(batch.blocks);
            }
            yield batch;
        }
    }
    async processHotBlocks(requests, state, cb) {
        let runtimeVersionTracker = new runtimeVersionTracker_1.RuntimeVersionTracker();
        let rpc = this.rpc;
        let fetch = new fetch1_1.Fetch1(rpc);
        let proc = new util_internal_ingest_tools_1.HotProcessor(state, {
            process: async (upd) => {
                for (let pack of (0, util_internal_1.partitionBy)(upd.blocks, b => !!(0, util_internal_range_1.getRequestAt)(requests, b.height)?.runtimeVersion)) {
                    if (pack.value) {
                        await runtimeVersionTracker.addRuntimeVersion(rpc, pack.items);
                    }
                }
                (0, util_internal_ingest_tools_1.assertIsValid)(upd.blocks);
                await cb(upd);
            },
            async getBlock(ref) {
                let blocks = await fetch.getColdSplit(ref.height, ref, {
                    ...(0, util_internal_range_1.getRequestAt)(requests, ref.height),
                    runtimeVersion: false
                });
                return blocks[0];
            },
            async *getBlockRange(from, to) {
                let top;
                let headBlock;
                if (to.height == null) {
                    headBlock = await fetch.getBlock0(to.hash, (0, util_internal_range_1.getRequestAt)(requests, from) || {});
                    if (headBlock == null)
                        throw new util_internal_ingest_tools_1.BlockConsistencyError(to);
                    top = headBlock.height;
                }
                else {
                    top = to.height;
                }
                if (top <= proc.getFinalizedHeight())
                    return;
                if (from > top) {
                    from = top;
                }
                for (let split of (0, util_internal_range_1.splitRangeByRequest)(requests, { from, to: top })) {
                    for (let range of (0, util_internal_range_1.splitRange)(10, split.range)) {
                        let blocks = await fetch.getHotSplit(range.from, range.to === headBlock?.height ? headBlock : range.to, split.request || {});
                        let lastBlock = (0, util_internal_1.maybeLast)(blocks)?.height ?? range.from - 1;
                        yield blocks;
                        if (lastBlock < range.to) {
                            throw new util_internal_ingest_tools_1.BlockConsistencyError({ height: lastBlock + 1 });
                        }
                    }
                }
            },
            getHeader(block) {
                return {
                    height: block.height,
                    hash: block.hash,
                    parentHash: block.block.block.header.parentHash
                };
            },
            async getFinalizedBlockHeight(hash) {
                let header = await rpc.getBlockHeader(hash);
                (0, assert_1.default)(header, 'finalized blocks must be always available');
                return (0, util_1.qty2Int)(header.number);
            }
        });
        function isEnd() {
            return proc.getFinalizedHeight() >= ((0, util_internal_1.maybeLast)(requests)?.range.to ?? Infinity);
        }
        if (this.rpc.client.supportsNotifications()) {
            await this.subscription(heads => proc.goto(heads), isEnd);
        }
        else {
            await this.polling(heads => proc.goto(heads), isEnd);
        }
    }
    async polling(cb, isEnd) {
        let headSrc = new util_internal_1.Throttler(() => this.rpc.getHead(), this.headPollInterval);
        let prev = '';
        while (!isEnd()) {
            let head = await headSrc.call();
            if (head === prev)
                continue;
            let finalizedHead = null;
            if (this.finalityConfirmation == null) {
                finalizedHead = await this.rpc.getFinalizedHead();
            }
            else {
                let attempt = 0;
                while (attempt < 5) {
                    let header = await this.rpc.getBlockHeader(head);
                    if (header != null) {
                        let finalizedHeight = (0, util_1.qty2Int)(header.number) - this.finalityConfirmation;
                        finalizedHead = await this.rpc.getBlockHash(finalizedHeight);
                        if (finalizedHead != null)
                            break;
                    }
                    head = await this.rpc.getHead();
                    attempt += 1;
                }
                (0, assert_1.default)(finalizedHead != null, `failed to get finalized head after ${attempt} attempts`);
            }
            await this.handleNewHeads({
                best: { hash: head },
                finalized: { hash: finalizedHead }
            }, cb);
        }
    }
    async subscription(cb, isEnd) {
        let finalityConfirmation = this.finalityConfirmation;
        let queue = new util_internal_1.AsyncQueue(1);
        let finalizedHeight = 0;
        let prevHeight = 0;
        let finalizedHeadsHandle;
        if (finalityConfirmation == null) {
            finalizedHeadsHandle = this.rpc.client.subscribe({
                method: 'chain_subscribeFinalizedHeads',
                unsubscribe: 'chain_unsubscribeFinalizedHeads',
                notification: 'chain_finalizedHead',
                onMessage(head) {
                    try {
                        let height = (0, util_1.qty2Int)(head.number);
                        finalizedHeight = Math.max(finalizedHeight, height);
                    }
                    catch (err) {
                        close(err);
                    }
                },
                onError(err) {
                    close((0, util_internal_1.ensureError)(err));
                },
                resubscribeOnConnectionLoss: true
            });
        }
        let newHeadsHandle = this.rpc.client.subscribe({
            method: 'chain_subscribeNewHeads',
            unsubscribe: 'chain_unsubscribeNewHeads',
            notification: 'chain_newHead',
            onMessage(head) {
                try {
                    let height = (0, util_1.qty2Int)(head.number);
                    if (height >= prevHeight) {
                        prevHeight = height;
                        if (finalityConfirmation != null) {
                            finalizedHeight = Math.max(0, height - finalityConfirmation);
                        }
                        queue.forcePut(height);
                    }
                }
                catch (err) {
                    close(err);
                }
            },
            onError(err) {
                close((0, util_internal_1.ensureError)(err));
            },
            resubscribeOnConnectionLoss: true
        });
        function close(err) {
            newHeadsHandle.close();
            finalizedHeadsHandle?.close();
            if (err) {
                queue.forcePut(err);
            }
            queue.close();
        }
        try {
            while (!isEnd()) {
                let height = await (0, util_timeout_1.addTimeout)(queue.take(), this.newHeadTimeout).catch(util_internal_1.ensureError);
                if (height instanceof util_timeout_1.TimeoutError) {
                    this.log?.warn(`resetting RPC connection, because we haven't seen a new head for ${this.newHeadTimeout} ms`);
                    this.rpc.client.reset();
                }
                else if (height instanceof Error) {
                    throw height;
                }
                else {
                    (0, assert_1.default)(height != null);
                    let hash = await this.rpc.getBlockHash(height);
                    if (hash) {
                        await this.handleNewHeads({
                            best: { height, hash },
                            finalized: { height: finalizedHeight }
                        }, cb);
                    }
                }
            }
        }
        finally {
            close();
        }
    }
    async handleNewHeads(heads, cb) {
        for (let i = 0; i < 3; i++) {
            try {
                return await cb(heads);
            }
            catch (err) {
                if ((0, util_internal_ingest_tools_1.isDataConsistencyError)(err)) {
                    this.log?.write(i > 0 ? logger_1.LogLevel.WARN : logger_1.LogLevel.DEBUG, err.message);
                    await (0, util_internal_1.wait)(100);
                }
                else {
                    throw err;
                }
            }
        }
    }
}
exports.RpcDataSource = RpcDataSource;
//# sourceMappingURL=datasource.js.map