import { CallOptions, RpcClient } from '@subsquid/rpc-client';
import { RpcErrorInfo } from '@subsquid/rpc-client/lib/interfaces';
import { BlockHeader, Bytes, GetBlockResult, Hash, RuntimeVersion } from './interfaces';
export declare class Rpc {
    readonly client: RpcClient;
    readonly options: CallOptions;
    constructor(client: RpcClient, options?: CallOptions);
    withPriority(priority: number): Rpc;
    call<T = any>(method: string, params?: any[], options?: CallOptions<T>): Promise<T>;
    batchCall<T = any>(batch: {
        method: string;
        params?: any[];
    }[], options?: CallOptions<T>): Promise<T[]>;
    getFinalizedHead(): Promise<Hash>;
    getHead(): Promise<Hash>;
    getBlockHash(height: number): Promise<Hash | null>;
    getBlockHeader(blockHash?: Hash): Promise<BlockHeader | null>;
    getBlock(blockHash: Hash): Promise<GetBlockResult | null>;
    getRuntimeVersion(blockHash: Hash): Promise<RuntimeVersion | undefined>;
    getMetadata(blockHash: Hash): Promise<Bytes | undefined>;
    getStorage(key: Bytes, blockHash: Hash): Promise<Bytes | null | undefined>;
    getStorageMany(query: [key: Bytes, blockHash: Hash][]): Promise<(Bytes | null | undefined)[]>;
}
export declare function captureMissingBlock(info: RpcErrorInfo): undefined;
export declare function isMissingBlockError(info: RpcErrorInfo): boolean;
//# sourceMappingURL=rpc.d.ts.map