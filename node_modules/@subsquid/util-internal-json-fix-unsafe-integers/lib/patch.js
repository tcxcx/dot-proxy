"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Patch = void 0;
class Patch {
    constructor(s) {
        this.s = s;
        this.pos = 0;
    }
    scan() {
        while (this.pos < this.s.length) {
            switch (this.code()) {
                case 0x22: // "
                    this.pos += 1;
                    this.eatString();
                    break;
                case 0x2d: // -
                case 0x30: // 0 - 9
                case 0x31:
                case 0x32:
                case 0x33:
                case 0x34:
                case 0x35:
                case 0x36:
                case 0x37:
                case 0x38:
                case 0x39:
                    this.eatNumber();
                    break;
                default:
                    this.pos += 1;
            }
        }
    }
    eatNumber() {
        let offset = this.pos;
        let isInteger = true;
        if (this.code() == 0x2d) { // -
            this.pos += 1;
        }
        this.expectDigits();
        if (this.code() == 0x2e) { // . ; fraction
            this.pos += 1;
            this.expectDigits();
            isInteger = false;
        }
        if (this.code() == 0x65 || this.code() == 0x45) { // e E ; exponent
            this.pos += 1;
            if (this.code() == 0x2d || this.code() == 0x2b) { // + -
                this.pos += 1;
            }
            this.expectDigits();
            isInteger = false;
        }
        if (isInteger) {
            let num = parseInt(this.s.slice(offset, this.pos));
            if (!Number.isSafeInteger(num)) {
                this.patch(offset, this.pos);
            }
        }
    }
    expectDigits() {
        let offset = this.pos;
        while (true) {
            let code = this.code();
            if (0x30 <= code && code <= 0x39) {
                this.pos += 1;
            }
            else if (offset == this.pos) {
                this.fail('digit expected');
            }
            else {
                return;
            }
        }
    }
    eatString() {
        while (this.pos < this.s.length) {
            let code = this.code();
            this.pos += 1;
            switch (code) {
                case 0x22: // "
                    return;
                case 0x5c: // \ (escape)
                    this.eatEscape();
                    break;
            }
        }
    }
    eatEscape() {
        switch (this.code()) {
            case 0x22:
            case 0x5c:
            case 0x2f:
            case 0x62:
            case 0x66:
            case 0x6e:
            case 0x72:
            case 0x74:
                this.pos += 1;
                return;
            case 0x75: // u
                this.pos += 1;
                for (let i = 0; i < 4; i++) {
                    this.eatHexDigit();
                }
                return;
            default:
                this.fail('invalid escape sequence');
        }
    }
    eatHexDigit() {
        let code = this.code();
        if (0x30 <= code && code <= 0x39 || 0x41 <= code && code <= 0x46 || 0x61 <= code && code <= 0x66) {
            this.pos += 1;
        }
        else {
            this.fail('hex digit expected');
        }
    }
    code() {
        return this.s.charCodeAt(this.pos);
    }
    fail(msg) {
        throw new Error(`JSON syntax error at ${this.pos + 1}: ${msg}`);
    }
    patch(beg, end) {
        if (this.locations == null) {
            this.locations = [[beg, end]];
        }
        else {
            this.locations.push([beg, end]);
        }
    }
    result() {
        if (this.locations == null)
            return this.s;
        let result = '';
        let offset = 0;
        for (let [beg, end] of this.locations) {
            result += this.s.slice(offset, beg);
            result += '"';
            result += this.s.slice(beg, end);
            result += '"';
            offset = end;
        }
        result += this.s.slice(offset);
        return result;
    }
}
exports.Patch = Patch;
//# sourceMappingURL=patch.js.map