"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.TypeormOpenreaderContext = void 0;
const subscription_1 = require("@subsquid/openreader/lib/subscription");
const lazy_transaction_1 = require("@subsquid/openreader/lib/util/lazy-transaction");
const util_internal_1 = require("@subsquid/util-internal");
let CTX_COUNTER = 0;
class TypeormOpenreaderContext {
    constructor(dbType, connection, subscriptionConnection, subscriptionPollInterval = 1000, log) {
        this.dbType = dbType;
        this.connection = connection;
        this.subscriptionPollInterval = subscriptionPollInterval;
        this.id = (CTX_COUNTER = (CTX_COUNTER + 1) % Number.MAX_SAFE_INTEGER);
        this.queryCounter = 0;
        this.log = log?.child({ graphqlCtx: this.id });
        this.tx = new lazy_transaction_1.LazyTransaction(cb => this.connection.transaction(cb));
        this.subscriptionConnection = subscriptionConnection || this.connection;
    }
    async executeQuery(query) {
        let em = await this.tx.get();
        let result = await this.query(em, query.sql, query.params);
        return query.map(result);
    }
    subscription(query) {
        return new subscription_1.Subscription(this.subscriptionPollInterval, () => this.subscriptionConnection.transaction(async (em) => {
            let result = await this.query(em, query.sql, query.params);
            return query.map(result);
        }));
    }
    getEntityManager() {
        return this.tx.get();
    }
    close() {
        return this.tx.close();
    }
    async query(em, sql, parameters) {
        let queryId = this.queryCounter = (this.queryCounter + 1) % Number.MAX_SAFE_INTEGER;
        let ctx = {
            graphqlCtx: this.id,
            graphqlSqlQuery: queryId,
        };
        let log = this.log?.child('sql', ctx);
        log?.debug({
            sql,
            parameters
        }, 'sql query');
        try {
            let rows = await em.query(sql, parameters).then(mapRecords);
            log?.debug({
                rowCount: rows.length,
                rows: log.isTrace() ? rows : undefined
            }, 'sql result');
            return rows;
        }
        catch (err) {
            throw (0, util_internal_1.addErrorContext)(err, {
                ...ctx,
                sql,
                parameters
            });
        }
    }
}
exports.TypeormOpenreaderContext = TypeormOpenreaderContext;
function mapRecords(records) {
    let rows = new Array(records.length);
    let len = 0;
    for (let i = 0; i < records.length; i++) {
        let rec = records[i];
        let row = new Array(len);
        let j = 0;
        for (let key in rec) {
            row[j] = rec[key];
            j += 1;
        }
        len = j;
        rows[i] = row;
    }
    return rows;
}
//# sourceMappingURL=typeorm.js.map