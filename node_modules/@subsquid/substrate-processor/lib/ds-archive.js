"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.SubstrateArchive = void 0;
const substrate_data_1 = require("@subsquid/substrate-data");
const util_internal_1 = require("@subsquid/util-internal");
const util_internal_ingest_tools_1 = require("@subsquid/util-internal-ingest-tools");
const util_internal_range_1 = require("@subsquid/util-internal-range");
const data_1 = require("./interfaces/data");
const mapping_1 = require("./mapping");
class SubstrateArchive {
    constructor(options) {
        this.client = options.client;
        this.rpc = new substrate_data_1.Rpc(options.rpc);
        this.typesBundle = options.typesBundle;
    }
    getFinalizedHeight() {
        return this.client.getHeight();
    }
    getBlockHash(height) {
        return this.rpc.getBlockHash(height);
    }
    async *getFinalizedBlocks(requests, stopOnHead) {
        let runtimeTracker = new substrate_data_1.RuntimeTracker(this.rpc, hdr => ({ height: hdr.number, hash: hdr.hash, parentHash: hdr.parentHash }), hdr => hdr, this.typesBundle);
        let archiveRequests = (0, util_internal_range_1.mapRangeRequestList)(requests, req => {
            let { fields, ...items } = req;
            let q = {
                type: 'substrate',
                fields: getFields(fields),
                ...items
            };
            return q;
        });
        for await (let { blocks, isHead } of (0, util_internal_ingest_tools_1.archiveIngest)({
            client: this.client,
            requests: archiveRequests,
            stopOnHead
        })) {
            let headers = blocks.map(b => b.header);
            await runtimeTracker.setRuntime(headers);
            (0, util_internal_ingest_tools_1.assertIsValid)(headers);
            yield {
                blocks: blocks.map(b => this.mapBlock(b)),
                isHead
            };
        }
    }
    mapBlock(src) {
        let block = new mapping_1.Block(new mapping_1.BlockHeader((0, util_internal_1.assertNotNull)(src.header.runtime), (0, util_internal_1.assertNotNull)(src.header.runtimeOfPrevBlock), {
            height: src.header.number,
            ...src.header
        }));
        if (src.extrinsics) {
            for (let s of src.extrinsics) {
                let extrinsic = new mapping_1.Extrinsic(block.header, s.index);
                if (s.version != null) {
                    extrinsic.version = s.version;
                }
                if (s.signature != null) {
                    extrinsic.signature = s.signature;
                }
                if (s.fee != null) {
                    extrinsic.fee = BigInt(s.fee);
                }
                if (s.tip != null) {
                    extrinsic.tip = BigInt(s.tip);
                }
                if (s.error != null) {
                    extrinsic.error = s.error;
                }
                if (s.success != null) {
                    extrinsic.success = s.success;
                }
                if (s.hash != null) {
                    extrinsic.hash = s.hash;
                }
                block.extrinsics.push(extrinsic);
            }
        }
        if (src.calls) {
            for (let s of src.calls) {
                let call = new mapping_1.Call(block.header, s.extrinsicIndex, s.address);
                if (s.name) {
                    call.name = s.name;
                }
                if (s.args != null) {
                    call.args = s.args;
                }
                if (s.origin != null) {
                    call.origin = s.origin;
                }
                if (s.error != null) {
                    call.error = s.error;
                }
                if (s.success != null) {
                    call.success = s.success;
                }
                block.calls.push(call);
            }
        }
        if (src.events) {
            for (let s of src.events) {
                let event = new mapping_1.Event(block.header, s.index);
                if (s.name != null) {
                    event.name = s.name;
                }
                if (s.args != null) {
                    event.args = s.args;
                }
                if (s.phase != null) {
                    event.phase = s.phase;
                }
                if (s.extrinsicIndex != null) {
                    event.extrinsicIndex = s.extrinsicIndex;
                }
                if (s.callAddress != null) {
                    event.callAddress = s.callAddress;
                }
                if (s.topics != null) {
                    event.topics = s.topics;
                }
                block.events.push(event);
            }
        }
        (0, mapping_1.setUpItems)(block);
        return block;
    }
}
exports.SubstrateArchive = SubstrateArchive;
__decorate([
    (0, util_internal_1.annotateSyncError)((src) => ({ blockHeight: src.header.number, blockHash: src.header.hash })),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object]),
    __metadata("design:returntype", mapping_1.Block)
], SubstrateArchive.prototype, "mapBlock", null);
function mergeFields(def, requested, required) {
    let fields = { ...def };
    for (let key in requested) {
        fields[key] = requested[key];
    }
    Object.assign(fields, required);
    return fields;
}
function getFields(fields) {
    return {
        block: mergeFields(data_1.DEFAULT_FIELDS.block, fields?.block, {
            specName: true,
            specVersion: true,
            implName: true,
            implVersion: true
        }),
        event: mergeFields(data_1.DEFAULT_FIELDS.event, fields?.event),
        call: mergeFields(data_1.DEFAULT_FIELDS.call, fields?.call),
        extrinsic: mergeFields(data_1.DEFAULT_FIELDS.extrinsic, fields?.extrinsic)
    };
}
//# sourceMappingURL=ds-archive.js.map