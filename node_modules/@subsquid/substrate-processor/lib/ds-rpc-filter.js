"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.filterBlockBatch = filterBlockBatch;
const util_internal_1 = require("@subsquid/util-internal");
const util_internal_processor_tools_1 = require("@subsquid/util-internal-processor-tools");
const util_internal_range_1 = require("@subsquid/util-internal-range");
function buildCallFilter(dataRequest) {
    let calls = new util_internal_processor_tools_1.EntityFilter();
    dataRequest.calls?.forEach(req => {
        let { name, ...relations } = req;
        let filter = new util_internal_processor_tools_1.FilterBuilder();
        filter.propIn('name', name);
        calls.add(filter, relations);
    });
    dataRequest.ethereumTransactions?.forEach(req => {
        let { to, sighash, ...relations } = req;
        let filter = new util_internal_processor_tools_1.FilterBuilder();
        filter.propIn('_ethereumTransactTo', to);
        filter.propIn('_ethereumTransactSighash', sighash);
        calls.add(filter, relations);
    });
    return calls;
}
function buildEventFilter(dataRequest) {
    let events = new util_internal_processor_tools_1.EntityFilter;
    dataRequest.events?.forEach(req => {
        let { name, ...relations } = req;
        let filter = new util_internal_processor_tools_1.FilterBuilder();
        filter.propIn('name', name);
        events.add(filter, relations);
    });
    dataRequest.evmLogs?.forEach(req => {
        let { address, topic0, topic1, topic2, topic3, ...relations } = req;
        let filter = new util_internal_processor_tools_1.FilterBuilder();
        filter.propIn('_evmLogAddress', address);
        filter.propIn('_evmLogTopic0', topic0);
        filter.propIn('_evmLogTopic1', topic1);
        filter.propIn('_evmLogTopic2', topic2);
        filter.propIn('_evmLogTopic3', topic3);
        events.add(filter, relations);
    });
    dataRequest.contractsEvents?.forEach(req => {
        let { contractAddress, ...relations } = req;
        let filter = new util_internal_processor_tools_1.FilterBuilder();
        filter.propIn('_contractAddress', contractAddress);
        events.add(filter, relations);
    });
    dataRequest.gearMessagesQueued?.forEach(req => {
        let { programId, ...relations } = req;
        let filter = new util_internal_processor_tools_1.FilterBuilder();
        filter.propIn('name', ['Gear.MessageQueued']);
        filter.propIn('_gearProgramId', programId);
        events.add(filter, relations);
    });
    dataRequest.gearUserMessagesSent?.forEach(req => {
        let { programId, ...relations } = req;
        let filter = new util_internal_processor_tools_1.FilterBuilder();
        filter.propIn('name', ['Gear.UserMessageSent']);
        filter.propIn('_gearProgramId', programId);
        events.add(filter, relations);
    });
    dataRequest.reviveContractEmitted?.forEach(req => {
        let { contract, topic0, topic1, topic2, topic3, ...relations } = req;
        let filter = new util_internal_processor_tools_1.FilterBuilder();
        filter.propIn('name', ['Revive.ContractEmitted']);
        filter.propIn('_reviveContract', contract);
        filter.propIn('_reviveTopic0', topic0);
        filter.propIn('_reviveTopic1', topic1);
        filter.propIn('_reviveTopic2', topic2);
        filter.propIn('_reviveTopic3', topic3);
        events.add(filter, relations);
    });
    return events;
}
const getItemFilter = (0, util_internal_1.weakMemo)((dataRequest) => {
    return {
        calls: buildCallFilter(dataRequest),
        events: buildEventFilter(dataRequest)
    };
});
class IncludeSet {
    constructor() {
        this.events = new Set();
        this.calls = new Set();
        this.extrinsics = new Set();
    }
    addEvent(event) {
        if (event) {
            this.events.add(event);
        }
    }
    addCall(call) {
        if (call) {
            this.calls.add(call);
        }
    }
    addExtrinsic(extrinsic) {
        if (extrinsic) {
            this.extrinsics.add(extrinsic);
        }
    }
    addCallStack(call) {
        while (call) {
            this.calls.add(call);
            call = call.parentCall;
        }
    }
}
function filterBlock(block, dataRequest) {
    let items = getItemFilter(dataRequest);
    let include = new IncludeSet();
    if (items.events.present()) {
        for (let event of block.events) {
            let rel = items.events.match(event);
            if (rel == null)
                continue;
            include.addEvent(event);
            if (rel.stack) {
                include.addCallStack(event.call);
            }
            else if (rel.call) {
                include.addCall(event.call);
            }
            if (rel.extrinsic) {
                include.addExtrinsic(event.extrinsic);
            }
        }
    }
    if (items.calls.present()) {
        for (let call of block.calls) {
            let rel = items.calls.match(call);
            if (rel == null)
                continue;
            include.addCall(call);
            if (rel.events) {
                for (let event of call.events) {
                    include.addEvent(event);
                }
            }
            if (rel.stack) {
                include.addCallStack(call.parentCall);
            }
            if (rel.extrinsic) {
                include.addExtrinsic(call.extrinsic);
            }
        }
    }
    block.events = block.events.filter(event => {
        if (!include.events.has(event))
            return false;
        if (event.call && !include.calls.has(event.call)) {
            event.call = undefined;
        }
        if (event.extrinsic && !include.extrinsics.has(event.extrinsic)) {
            event.extrinsic = undefined;
        }
        return true;
    });
    block.calls = block.calls.filter(call => {
        if (!include.calls.has(call))
            return false;
        if (call.parentCall && !include.calls.has(call.parentCall)) {
            call.parentCall = undefined;
        }
        if (call.extrinsic && !include.extrinsics.has(call.extrinsic)) {
            call.extrinsic = undefined;
        }
        call.subcalls = call.subcalls.filter(sub => include.calls.has(sub));
        call.events = call.events.filter(event => include.events.has(event));
        return true;
    });
    block.extrinsics = block.extrinsics.filter(ex => {
        if (!include.extrinsics.has(ex))
            return false;
        if (ex.call && !include.calls.has(ex.call)) {
            ex.call = undefined;
        }
        ex.subcalls = ex.subcalls.filter(sub => include.calls.has(sub));
        ex.events = ex.events.filter(event => include.events.has(event));
        return true;
    });
}
function filterBlockBatch(requests, blocks) {
    for (let block of blocks) {
        let dataRequest = (0, util_internal_range_1.getRequestAt)(requests, block.header.height) || NO_DATA_REQUEST;
        filterBlock(block, dataRequest);
    }
}
const NO_DATA_REQUEST = {};
//# sourceMappingURL=ds-rpc-filter.js.map