"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.SubstrateBatchProcessor = void 0;
const http_client_1 = require("@subsquid/http-client");
const logger_1 = require("@subsquid/logger");
const rpc_client_1 = require("@subsquid/rpc-client");
const metadata_1 = require("@subsquid/substrate-runtime/lib/metadata");
const typesBundle_polkadotjs_1 = require("@subsquid/substrate-runtime/lib/metadata/old/typesBundle-polkadotjs");
const util_internal_1 = require("@subsquid/util-internal");
const util_internal_archive_client_1 = require("@subsquid/util-internal-archive-client");
const util_internal_processor_tools_1 = require("@subsquid/util-internal-processor-tools");
const util_internal_range_1 = require("@subsquid/util-internal-range");
const util_internal_validation_1 = require("@subsquid/util-internal-validation");
const assert_1 = __importDefault(require("assert"));
const chain_1 = require("./chain");
const ds_archive_1 = require("./ds-archive");
const ds_rpc_1 = require("./ds-rpc");
const selection_1 = require("./selection");
/**
 * Provides methods to configure and launch data processing.
 */
class SubstrateBatchProcessor {
    constructor() {
        this.requests = [];
        this.prometheus = new util_internal_processor_tools_1.PrometheusServer();
        this.running = false;
    }
    /**
     * @deprecated Use {@link .setGateway()}
     */
    setArchive(url) {
        return this.setGateway(url);
    }
    /**
     * Set Subsquid Network Gateway endpoint (ex Archive).
     *
     * Subsquid Network allows to get data from finalized blocks up to
     * infinite times faster and more efficient than via regular RPC.
     *
     * @example
     * processor.setGateway('https://v2.archive.subsquid.io/network/kusama')
     */
    setGateway(url) {
        this.assertNotRunning();
        if (typeof url == 'string') {
            this.archive = { url };
        }
        else {
            this.archive = url;
        }
        return this;
    }
    /**
     * Set chain RPC endpoint
     *
     * @example
     * // just pass a URL
     * processor.setRpcEndpoint('https://kusama-rpc.polkadot.io')
     *
     * // adjust some connection options
     * processor.setRpcEndpoint({
     *     url: 'https://kusama-rpc.polkadot.io',
     *     rateLimit: 10
     * })
     */
    setRpcEndpoint(url) {
        this.assertNotRunning();
        if (typeof url == 'string') {
            this.rpcEndpoint = { url };
        }
        else {
            this.rpcEndpoint = url;
        }
        return this;
    }
    /**
     * Sets blockchain data source.
     *
     * @example
     * processor.setDataSource({
     *     archive: 'https://v2.archive.subsquid.io/network/kusama',
     *     chain: 'https://kusama-rpc.polkadot.io'
     * })
     *
     * @deprecated Use separate {@link .setGateway()} and {@link .setRpcEndpoint()} methods
     * to specify data sources.
     */
    setDataSource(src) {
        this.assertNotRunning();
        if (src.archive) {
            this.setGateway(src.archive);
        }
        else {
            this.archive = undefined;
        }
        if (src.chain) {
            this.setRpcEndpoint(src.chain);
        }
        else {
            this.rpcEndpoint = undefined;
        }
        return this;
    }
    /**
     * Set up RPC data ingestion settings
     */
    setRpcDataIngestionSettings(settings) {
        this.assertNotRunning();
        this.rpcIngestSettings = settings;
        return this;
    }
    /**
     * @deprecated Use {@link .setRpcDataIngestionSettings()} instead
     */
    setChainPollInterval(ms) {
        (0, assert_1.default)(ms >= 0);
        this.assertNotRunning();
        this.rpcIngestSettings = { ...this.rpcIngestSettings, headPollInterval: ms };
        return this;
    }
    /**
     * Never use RPC endpoint for data ingestion.
     *
     * @deprecated This is the same as `.setRpcDataIngestionSettings({disabled: true})`
     */
    useArchiveOnly(yes) {
        this.assertNotRunning();
        this.rpcIngestSettings = { ...this.rpcIngestSettings, disabled: true };
        return this;
    }
    /**
     * Limits the range of blocks to be processed.
     *
     * When the upper bound is specified,
     * the processor will terminate with exit code 0 once it reaches it.
     */
    setBlockRange(range) {
        this.assertNotRunning();
        this.blockRange = range;
        return this;
    }
    /**
     * Distance from the head block behind which all blocks are considered to be finalized.
     *
     * By default, the processor will track finalized blocks via `chain_getFinalizedHead`.
     * Configure it only if `chain_getFinalizedHead` doesnâ€™t return the expected info.
     */
    setFinalityConfirmation(nBlocks) {
        this.assertNotRunning();
        this.finalityConfirmation = nBlocks;
        return this;
    }
    /**
     * Configure a set of fetched fields
     */
    setFields(fields) {
        this.assertNotRunning();
        let validator = (0, selection_1.getFieldSelectionValidator)();
        this.fields = (0, util_internal_validation_1.cast)(validator, fields);
        return this;
    }
    add(request, range) {
        this.requests.push({
            range: range || { from: 0 },
            request
        });
    }
    /**
     * By default, the processor will fetch only blocks
     * which contain requested items. This method
     * modifies such behaviour to fetch all chain blocks.
     *
     * Optionally a range of blocks can be specified
     * for which the setting should be effective.
     */
    includeAllBlocks(range) {
        this.assertNotRunning();
        this.add({ includeAllBlocks: true }, range);
        return this;
    }
    addEvent(options) {
        this.assertNotRunning();
        let { range, ...req } = options;
        this.add({ events: [req] }, range);
        return this;
    }
    addCall(options) {
        this.assertNotRunning();
        let { range, ...req } = options;
        this.add({ calls: [req] }, range);
        return this;
    }
    addEvmLog(options) {
        this.assertNotRunning();
        let { range, address, ...req } = options;
        this.add({ evmLogs: [{
                    ...req,
                    address: address?.map(s => s.toLowerCase())
                }] }, range);
        return this;
    }
    addEthereumTransaction(options) {
        this.assertNotRunning();
        let { range, to, ...req } = options;
        this.add({ ethereumTransactions: [{
                    ...req,
                    to: to?.map(s => s.toLowerCase())
                }] }, range);
        return this;
    }
    addContractsContractEmitted(options) {
        this.assertNotRunning();
        let { range, ...req } = options;
        this.add({ contractsEvents: [req] }, range);
        return this;
    }
    addGearMessageQueued(options) {
        this.assertNotRunning();
        let { range, ...req } = options;
        this.add({ gearMessagesQueued: [req] }, range);
        return this;
    }
    addGearUserMessageSent(options) {
        this.assertNotRunning();
        let { range, ...req } = options;
        this.add({ gearUserMessagesSent: [req] }, range);
        return this;
    }
    addReviveContractEmitted(options) {
        this.assertNotRunning();
        let { range, ...req } = options;
        this.add({ reviveContractEmitted: [req] }, range);
        return this;
    }
    /**
     * Sets types bundle.
     *
     * Types bundle is only required for blocks which have
     * metadata version below 14 and only if we don't have built-in
     * support for the chain in question.
     *
     * Subsquid project has its own types bundle format,
     * however, most of polkadotjs types bundles will work as well.
     *
     * Types bundle can be specified in 2 different ways:
     *
     * 1. as a name of a JSON file
     * 2. as an {@link OldTypesBundle} or {@link OldSpecsBundle} or {@link PolkadotjsTypesBundle} object
     *
     * @example
     * // A path to a JSON file resolved relative to `cwd`.
     * processor.setTypesBundle('typesBundle.json')
     *
     * // OldTypesBundle object
     * processor.setTypesBundle({
     *     types: {
     *         Foo: 'u8'
     *     }
     * })
     */
    setTypesBundle(bundle) {
        this.assertNotRunning();
        if (typeof bundle == 'string') {
            this.typesBundle = (0, metadata_1.getOldTypesBundle)(bundle) || (0, metadata_1.readOldTypesBundle)(bundle);
        }
        else {
            this.typesBundle = (0, typesBundle_polkadotjs_1.eliminatePolkadotjsTypesBundle)(bundle);
        }
        return this;
    }
    /**
     * Sets the port for a built-in prometheus metrics server.
     *
     * By default, the value of `PROMETHEUS_PORT` environment
     * variable is used. When it is not set,
     * the processor will pick up an ephemeral port.
     */
    setPrometheusPort(port) {
        this.assertNotRunning();
        this.prometheus.setPort(port);
        return this;
    }
    assertNotRunning() {
        if (this.running) {
            throw new Error('Settings modifications are not allowed after start of processing');
        }
    }
    getSquidId() {
        return (0, util_internal_processor_tools_1.getOrGenerateSquidId)();
    }
    getChainRpcClient() {
        if (this.rpcEndpoint == null) {
            throw new Error(`use .setRpcEndpoint() to specify chain RPC endpoint`);
        }
        let client = new rpc_client_1.RpcClient({
            url: this.rpcEndpoint.url,
            headers: this.rpcEndpoint.headers,
            maxBatchCallSize: this.rpcEndpoint.maxBatchCallSize ?? 100,
            requestTimeout: this.rpcEndpoint.requestTimeout ?? 30000,
            capacity: this.rpcEndpoint.capacity ?? 10,
            rateLimit: this.rpcEndpoint.rateLimit,
            retryAttempts: Number.MAX_SAFE_INTEGER,
            log: this.getLogger().child('rpc', { rpcUrl: this.rpcEndpoint.url })
        });
        this.prometheus.addChainRpcMetrics(() => client.getMetrics());
        return client;
    }
    getRpcDataSource() {
        return new ds_rpc_1.RpcDataSource({
            rpc: this.getChainRpcClient(),
            headPollInterval: this.rpcIngestSettings?.headPollInterval,
            newHeadTimeout: this.rpcIngestSettings?.newHeadTimeout,
            typesBundle: this.typesBundle,
            finalityConfirmation: this.finalityConfirmation
        });
    }
    getArchiveDataSource() {
        let options = (0, util_internal_1.assertNotNull)(this.archive);
        let log = this.getLogger().child('archive');
        let http = new http_client_1.HttpClient({
            headers: {
                'x-squid-id': this.getSquidId()
            },
            agent: new http_client_1.HttpAgent({
                keepAlive: true
            }),
            log
        });
        return new ds_archive_1.SubstrateArchive({
            client: new util_internal_archive_client_1.ArchiveClient({
                http,
                url: options.url,
                queryTimeout: options.requestTimeout,
                log
            }),
            rpc: this.getChainRpcClient(),
            typesBundle: this.typesBundle
        });
    }
    getLogger() {
        return (0, logger_1.createLogger)('sqd:processor');
    }
    getBatchRequests() {
        function concat(a, b) {
            let result = [];
            if (a) {
                result.push(...a);
            }
            if (b) {
                result.push(...b);
            }
            return result.length == 0 ? undefined : result;
        }
        let requests = (0, util_internal_range_1.mergeRangeRequests)(this.requests, (a, b) => {
            return {
                includeAllBlocks: a.includeAllBlocks || b.includeAllBlocks,
                events: concat(a.events, b.events),
                calls: concat(a.calls, b.calls),
                evmLogs: concat(a.evmLogs, b.evmLogs),
                ethereumTransactions: concat(a.ethereumTransactions, b.ethereumTransactions),
                contractsEvents: concat(a.contractsEvents, b.contractsEvents),
                gearMessagesQueued: concat(a.gearMessagesQueued, b.gearMessagesQueued),
                gearUserMessagesSent: concat(a.gearUserMessagesSent, b.gearUserMessagesSent),
                reviveContractEmitted: concat(a.reviveContractEmitted, b.reviveContractEmitted)
            };
        });
        if (this.fields) {
            requests = requests.map(({ range, request }) => {
                return {
                    range,
                    request: {
                        fields: this.fields,
                        ...request
                    }
                };
            });
        }
        return (0, util_internal_range_1.applyRangeBound)(requests, this.blockRange);
    }
    getChain() {
        return new chain_1.Chain(() => this.getChainRpcClient());
    }
    processBatch(store, batch, handler) {
        return handler({
            _chain: this.getChain(),
            log: this.getLogger().child('mapping'),
            store,
            blocks: batch.blocks,
            isHead: batch.isHead,
        });
    }
    /**
     * Run data processing.
     *
     * This method assumes full control over the current OS process as
     * it terminates the entire program in case of error or
     * at the end of data processing.
     *
     * @param database - database is responsible for providing storage to the data handler
     * and persisting mapping progress and status.
     *
     * @param handler - The data handler, see {@link DataHandlerContext} for an API available to the handler.
     */
    run(database, handler) {
        this.assertNotRunning();
        this.running = true;
        let log = this.getLogger();
        (0, util_internal_1.runProgram)(async () => {
            if (this.rpcEndpoint == null) {
                throw new Error('Chain RPC endpoint is always required. Use .setRpcEndpoint() to specify it.');
            }
            if (this.rpcIngestSettings?.disabled && this.archive == null) {
                throw new Error('Archive is required when RPC data ingestion is disabled. ' +
                    'Use .setArchive() to specify it.');
            }
            return new util_internal_processor_tools_1.Runner({
                database,
                requests: this.getBatchRequests(),
                archive: this.archive == null ? undefined : this.getArchiveDataSource(),
                hotDataSource: this.rpcIngestSettings?.disabled ? undefined : this.getRpcDataSource(),
                allBlocksAreFinal: this.finalityConfirmation === 0,
                process: (s, b) => this.processBatch(s, b, handler),
                prometheus: this.prometheus,
                log
            }).run();
        }, err => log.fatal(err));
    }
}
exports.SubstrateBatchProcessor = SubstrateBatchProcessor;
__decorate([
    util_internal_1.def,
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", String)
], SubstrateBatchProcessor.prototype, "getSquidId", null);
__decorate([
    util_internal_1.def,
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", rpc_client_1.RpcClient)
], SubstrateBatchProcessor.prototype, "getChainRpcClient", null);
__decorate([
    util_internal_1.def,
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", ds_rpc_1.RpcDataSource)
], SubstrateBatchProcessor.prototype, "getRpcDataSource", null);
__decorate([
    util_internal_1.def,
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", ds_archive_1.SubstrateArchive)
], SubstrateBatchProcessor.prototype, "getArchiveDataSource", null);
__decorate([
    util_internal_1.def,
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", logger_1.Logger)
], SubstrateBatchProcessor.prototype, "getLogger", null);
__decorate([
    util_internal_1.def,
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Array)
], SubstrateBatchProcessor.prototype, "getBatchRequests", null);
__decorate([
    util_internal_1.def,
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", chain_1.Chain)
], SubstrateBatchProcessor.prototype, "getChain", null);
//# sourceMappingURL=processor.js.map