"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.RpcClient = void 0;
const http_client_1 = require("@subsquid/http-client");
const logger_1 = require("@subsquid/logger");
const util_internal_1 = require("@subsquid/util-internal");
const util_internal_binary_heap_1 = require("@subsquid/util-internal-binary-heap");
const assert_1 = __importDefault(require("assert"));
const errors_1 = require("./errors");
const rate_1 = require("./rate");
const subscriptions_1 = require("./subscriptions");
const http_1 = require("./transport/http");
const ws_1 = require("./transport/ws");
class RpcClient {
    constructor(options) {
        this.counter = 0;
        this.queue = new util_internal_binary_heap_1.Heap(byPriority);
        this.rateLimit = Number.MAX_SAFE_INTEGER;
        this.schedulingScheduled = false;
        this.connectionErrorsInRow = 0;
        this.connectionErrors = 0;
        this.requestsServed = 0;
        this.notificationsReceived = 0;
        this.backoffEpoch = 0;
        this.notificationListeners = [];
        this.resetListeners = [];
        this.closed = false;
        this.url = trimCredentials(options.url);
        this.con = this.createConnection(options.url, options.fixUnsafeIntegers || false, options.headers);
        this.maxBatchCallSize = options.maxBatchCallSize ?? Number.MAX_SAFE_INTEGER;
        this.capacity = this.maxCapacity = options.capacity || 10;
        this.requestTimeout = options.requestTimeout ?? 0;
        this.retryAttempts = options.retryAttempts ?? 0;
        this.retrySchedule = options.retrySchedule ?? [10, 100, 500, 2000, 10000, 20000];
        this.log = options.log === null
            ? undefined
            : options.log || (0, logger_1.createLogger)('sqd:rpc-client', { rpcUrl: this.url });
        if (options.rateLimit) {
            (0, assert_1.default)(options.rateLimit > 0);
            let window = 10;
            let slotTime = 100;
            if (options.rateLimit < 1) {
                slotTime = Math.ceil(1000 / (options.rateLimit * window));
            }
            this.rate = new rate_1.RateMeter(window, slotTime);
            this.rateLimit = options.rateLimit;
            this.maxBatchCallSize = Math.min(this.maxBatchCallSize, Math.max(1, Math.floor(this.rateLimit / 5)));
        }
    }
    createConnection(url, fixUnsafeIntegers, headers) {
        let protocol = new URL(url).protocol;
        switch (protocol) {
            case 'ws:':
            case 'wss:':
                return new ws_1.WsConnection({
                    url,
                    headers,
                    onNotificationMessage: msg => this.onNotification(msg),
                    onReset: reason => {
                        if (this.closed)
                            return;
                        for (let cb of this.resetListeners) {
                            this.safeCallback(cb, reason);
                        }
                    },
                    fixUnsafeIntegers
                });
            case 'http:':
            case 'https:':
                return new http_1.HttpConnection({
                    url,
                    headers,
                    log: this.log,
                    fixUnsafeIntegers
                });
            default:
                throw new TypeError(`unsupported protocol: ${protocol}`);
        }
    }
    getConcurrency() {
        return this.maxCapacity;
    }
    getMetrics() {
        return {
            url: this.url,
            requestsServed: this.requestsServed,
            connectionErrors: this.connectionErrors,
            notificationsReceived: this.notificationsReceived
        };
    }
    onNotification(msg) {
        this.notificationsReceived += 1;
        this.log?.debug({ rpcMsg: msg }, 'rpc notification');
        for (let cb of this.notificationListeners) {
            this.safeCallback(cb, msg);
        }
    }
    safeCallback(cb, arg) {
        try {
            cb(arg);
        }
        catch (err) {
            this.log?.error(err, 'callback error');
        }
    }
    addNotificationListener(cb) {
        this.notificationListeners.push(cb);
    }
    removeNotificationListener(cb) {
        removeItem(this.notificationListeners, cb);
    }
    addResetListener(cb) {
        this.resetListeners.push(cb);
    }
    removeResetListener(cb) {
        removeItem(this.resetListeners, cb);
    }
    subscribe(sub) {
        return this.subscriptions().add(sub);
    }
    subscriptions() {
        (0, assert_1.default)(this.supportsNotifications(), 'subscriptions are only supported by websocket connections');
        return new subscriptions_1.Subscriptions(this);
    }
    supportsNotifications() {
        return this.con instanceof ws_1.WsConnection;
    }
    call(method, params, options) {
        return new Promise((resolve, reject) => {
            let call = {
                id: this.counter += 1,
                jsonrpc: '2.0',
                method,
                params
            };
            if (this.log?.isDebug()) {
                this.log.debug({
                    rpcId: call.id,
                    rpcMethod: call.method,
                    rpcParams: call.params
                }, 'rpc call');
            }
            this.enqueue({
                call,
                priority: options?.priority ?? 0,
                timeout: options?.timeout ?? this.requestTimeout,
                retryAttempts: options?.retryAttempts ?? this.retryAttempts,
                resolve,
                reject,
                validateResult: options?.validateResult,
                validateError: options?.validateError,
            });
        });
    }
    batchCall(batch, options) {
        return (0, util_internal_1.splitParallelWork)(this.maxBatchCallSize, batch, b => this.batchCallInternal(b, options));
    }
    batchCallInternal(batch, options) {
        if (batch.length == 0)
            return Promise.resolve([]);
        if (batch.length == 1)
            return this.call(batch[0].method, batch[0].params, options).then(res => [res]);
        return new Promise((resolve, reject) => {
            if (batch.length == 0)
                return resolve([]);
            let calls = batch.map(it => {
                return {
                    ...it,
                    id: this.counter += 1,
                    jsonrpc: '2.0'
                };
            });
            if (this.log?.isDebug()) {
                for (let call of calls) {
                    this.log.debug({
                        rpcId: call.id,
                        rpcMethod: call.method,
                        rpcParams: call.params
                    }, 'rpc call');
                }
            }
            this.enqueue({
                call: calls,
                priority: options?.priority ?? 0,
                timeout: options?.timeout ?? this.requestTimeout,
                retryAttempts: options?.retryAttempts ?? this.retryAttempts,
                resolve,
                reject,
                validateResult: options?.validateResult,
                validateError: options?.validateError
            });
        });
    }
    enqueue(req) {
        this.assertNotClosed();
        this.queue.push(req);
        this.schedule();
    }
    schedule() {
        if (this.schedulingScheduled || this.closed)
            return;
        if (this.queue.peek() == null || this.capacity <= 0)
            return;
        this.schedulingScheduled = true;
        Promise.resolve().then(() => this.performScheduling());
    }
    performScheduling() {
        this.waitForConnection().then(() => {
            if (this.rate) {
                this.performRateLimitedScheduling(this.rate);
            }
            else {
                if (this.closed)
                    return;
                this.schedulingScheduled = false;
                while (this.capacity > 0 && this.queue.peek()) {
                    this.send(this.queue.pop());
                }
            }
        }, err => {
            this.close(err);
        });
    }
    performRateLimitedScheduling(rateMeter) {
        if (this.closed)
            return;
        this.schedulingScheduled = false;
        let now = Date.now();
        let rate = rateMeter.getRate(now);
        let rateCapacity = this.rateLimit - rate;
        while (this.capacity > 0 && this.queue.peek()) {
            if (rateCapacity <= 0) {
                this.schedulingScheduled = true;
                setTimeout(() => this.performScheduling(), rateMeter.slotTime);
                return;
            }
            let req = this.queue.pop();
            let size = Array.isArray(req.call) ? req.call.length : 1;
            rateCapacity -= size;
            rateMeter.inc(size, now);
            this.send(req);
        }
    }
    send(req) {
        this.capacity -= 1;
        let backoffEpoch = this.backoffEpoch;
        let promise;
        if (Array.isArray(req.call)) {
            let call = req.call;
            this.log?.debug({ rpcBatchId: [call[0].id, (0, util_internal_1.last)(call).id] }, 'rpc send');
            promise = this.con.batchCall(call, req.timeout).then(res => {
                let result = new Array(res.length);
                for (let i = 0; i < res.length; i++) {
                    result[i] = this.receiveResult(call[i], res[i], req.validateResult, req.validateError);
                }
                return result;
            });
        }
        else {
            let call = req.call;
            this.log?.debug({ rpcId: call.id }, 'rpc send');
            promise = this.con.call(call, req.timeout).then(res => {
                return this.receiveResult(call, res, req.validateResult, req.validateError);
            });
        }
        promise.then(result => {
            this.requestsServed += 1;
            if (this.backoffEpoch == backoffEpoch) {
                this.connectionErrorsInRow = 0;
            }
            req.resolve(result);
        }, err => {
            if (this.closed)
                return req.reject(err);
            if (this.isConnectionError(err)) {
                if (req.retryAttempts > 0) {
                    req.retryAttempts -= 1;
                    this.enqueue(req);
                }
                else {
                    req.reject(err);
                }
                if (this.backoffEpoch == backoffEpoch) {
                    this.backoff(err, req);
                }
            }
            else {
                req.reject(err);
            }
        }).finally(() => {
            this.capacity += 1;
            this.schedule();
        });
    }
    async waitForConnection() {
        while (true) {
            if (this.backoffTime != null) {
                let pause = Math.max(this.backoffTime - Date.now(), 0);
                this.backoffTime = undefined;
                if (pause > 0) {
                    await (0, util_internal_1.wait)(pause);
                }
            }
            if (this.closed)
                return;
            try {
                return await this.con.connect();
            }
            catch (err) {
                if (this.closed)
                    return;
                if (err instanceof errors_1.RpcConnectionError) {
                    this.backoff(err);
                }
                else {
                    throw err;
                }
            }
        }
    }
    backoff(reason, req) {
        this.backoffEpoch += 1;
        this.connectionErrorsInRow += 1;
        this.connectionErrors += 1;
        let backoffPause = this.retrySchedule[Math.min(this.connectionErrorsInRow, this.retrySchedule.length) - 1];
        this.backoffTime = Date.now() + backoffPause;
        if (this.log?.isWarn()) {
            let httpResponseBody = undefined;
            if (reason instanceof http_client_1.HttpError &&
                reason.response.body &&
                !reason.response.headers.get('content-type')?.includes('text/html')) {
                httpResponseBody = reason.response.body;
            }
            this.log.warn({
                reason: reason.toString(),
                httpResponseBody,
                rpcCall: req?.call
            }, 'connection failure');
            this.log.warn(`will pause new requests for ${backoffPause}ms`);
        }
    }
    receiveResult(call, res, validateResult, validateError) {
        if (this.log?.isDebug()) {
            this.log.debug({
                rpcId: call.id,
                rpcMethod: call.method,
                rpcParams: call.params,
                rpcResponse: res
            }, 'rpc response');
        }
        try {
            if (res.error) {
                if (validateError) {
                    return validateError(res.error, call);
                }
                else {
                    throw new errors_1.RpcError(res.error);
                }
            }
            else if (validateResult) {
                return validateResult(res.result, call);
            }
            else {
                return res.result;
            }
        }
        catch (err) {
            throw (0, util_internal_1.addErrorContext)(err, {
                rpcUrl: this.url,
                rpcId: call.id,
                rpcMethod: call.method,
                rpcParams: call.params,
                rpcResponse: res
            });
        }
    }
    isConnectionError(err) {
        if (err instanceof errors_1.RetryError)
            return true;
        if (isRateLimitError(err))
            return true;
        if (isExecutionTimeoutError(err))
            return true;
        if (isRequestTimedOutError(err))
            return true;
        if (err instanceof errors_1.RpcConnectionError)
            return true;
        if ((0, http_client_1.isHttpConnectionError)(err))
            return true;
        if (err instanceof http_client_1.HttpTimeoutError)
            return true;
        if (err instanceof http_client_1.HttpError) {
            switch (err.response.status) {
                case 429:
                case 502:
                case 503:
                case 504:
                    return true;
                default:
                    return false;
            }
        }
        return false;
    }
    reset(reason) {
        if (this.closed)
            return;
        if (this.con instanceof ws_1.WsConnection) {
            this.con.close(reason || new errors_1.RpcConnectionError('client was reset'));
        }
    }
    close(err) {
        if (this.closed)
            return;
        this.closed = true;
        this.con.close(err);
        while (this.queue.peek()) { // drain queue
            let req = this.queue.pop();
            req.reject(err || new Error('RpcClient was closed'));
        }
    }
    assertNotClosed() {
        if (this.closed) {
            throw new Error('RpcClient was closed');
        }
    }
}
exports.RpcClient = RpcClient;
__decorate([
    util_internal_1.def,
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", subscriptions_1.Subscriptions)
], RpcClient.prototype, "subscriptions", null);
function byPriority(a, b) {
    let p = a.priority - b.priority;
    if (p != 0)
        return p;
    return getCallPriority(a) - getCallPriority(b);
}
function getCallPriority(req) {
    if (Array.isArray(req.call)) {
        return req.call[0].id;
    }
    else {
        return req.call.id;
    }
}
function trimCredentials(url) {
    let u = new URL(url);
    u.password = '';
    u.username = '';
    return u.toString();
}
function isRateLimitError(err) {
    return err instanceof errors_1.RpcError && /rate limit/i.test(err.message);
}
function isExecutionTimeoutError(err) {
    return err instanceof errors_1.RpcError && /execution timeout/i.test(err.message);
}
function isRequestTimedOutError(err) {
    return err instanceof errors_1.RpcError && /request.*timed out/i.test(err.message);
}
function removeItem(arr, item) {
    let index = arr.indexOf(item);
    if (index < 0)
        return;
    arr.splice(index, 1);
}
//# sourceMappingURL=client.js.map