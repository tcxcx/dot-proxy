import { Logger } from '@subsquid/logger';
import { RpcConnectionError } from './errors';
import { HttpHeaders, RpcCall, RpcErrorInfo, RpcNotification, RpcRequest } from './interfaces';
import { Subscription, SubscriptionHandle } from './subscriptions';
export interface RpcClientOptions {
    /**
     * RPC endpoint URL (either http(s) or ws(s))
     */
    url: string;
    /**
     * Maximum number of ongoing concurrent requests
     *
     * Batch call is counted as a single request.
     */
    capacity?: number;
    /**
     * Maximum number of calls per second
     *
     * Batch call items are counted towards the limit.
     */
    rateLimit?: number;
    /**
     * Request timeout in `ms`
     */
    requestTimeout?: number;
    /**
     * When set, every call (by default) will be retried specified number of times after connection error.
     */
    retryAttempts?: number;
    /**
     * Retry pauses in `ms.
     *
     * First value will be used for a first retry pause,
     * second - for a second, etc.
     *
     * For all further retry attempts the last pause value will be used.
     *
     * Default is `[10, 100, 500, 2000, 10000, 20000]`
     */
    retrySchedule?: number[];
    /**
     * Maximum number of requests in a single batch call
     */
    maxBatchCallSize?: number;
    /**
     * Convert unsafe integers to strings in incoming JSON messages
     */
    fixUnsafeIntegers?: boolean;
    /**
     * HTTP headers
     */
    headers?: HttpHeaders;
    log?: Logger | null;
}
export interface CallOptions<R = any> {
    priority?: number;
    retryAttempts?: number;
    timeout?: number;
    /**
     * Result validator/transformer
     *
     * This option is mainly a way to utilize built-in retry machinery by throwing {@link RetryError}.
     * Otherwise, `client.call(...).then(validateResult)` is a better option.
     */
    validateResult?: ResultValidator<R>;
    validateError?: ErrorValidator<R>;
}
type ResultValidator<R = any> = (result: any, req: RpcRequest) => R;
type ErrorValidator<R = any> = (info: RpcErrorInfo, req: RpcRequest) => R;
export declare class RpcClient {
    private counter;
    private queue;
    readonly url: string;
    private con;
    private maxBatchCallSize;
    private requestTimeout;
    private retrySchedule;
    private retryAttempts;
    private capacity;
    private maxCapacity;
    private log?;
    private rate?;
    private rateLimit;
    private schedulingScheduled;
    private connectionErrorsInRow;
    private connectionErrors;
    private requestsServed;
    private notificationsReceived;
    private backoffEpoch;
    private backoffTime?;
    private notificationListeners;
    private resetListeners;
    private closed;
    constructor(options: RpcClientOptions);
    private createConnection;
    getConcurrency(): number;
    getMetrics(): {
        url: string;
        requestsServed: number;
        connectionErrors: number;
        notificationsReceived: number;
    };
    private onNotification;
    private safeCallback;
    addNotificationListener(cb: (msg: RpcNotification) => void): void;
    removeNotificationListener(cb: (msg: RpcNotification) => void): void;
    addResetListener(cb: (reason: Error) => void): void;
    removeResetListener(cb: (reason: Error) => void): void;
    subscribe<T>(sub: Subscription<T>): SubscriptionHandle;
    private subscriptions;
    supportsNotifications(): boolean;
    call<T = any>(method: string, params?: any[], options?: CallOptions<T>): Promise<T>;
    batchCall<T = any>(batch: RpcCall[], options?: CallOptions<T>): Promise<T[]>;
    private batchCallInternal;
    private enqueue;
    private schedule;
    private performScheduling;
    private performRateLimitedScheduling;
    private send;
    private waitForConnection;
    private backoff;
    private receiveResult;
    isConnectionError(err: Error): boolean;
    reset(reason?: RpcConnectionError): void;
    close(err?: Error): void;
    private assertNotClosed;
}
export {};
//# sourceMappingURL=client.d.ts.map