"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Typegen = void 0;
const substrate_runtime_1 = require("@subsquid/substrate-runtime");
const sts_1 = require("@subsquid/substrate-runtime/lib/sts");
const util_internal_1 = require("@subsquid/util-internal");
const util_internal_code_printer_1 = require("@subsquid/util-internal-code-printer");
const util_naming_1 = require("@subsquid/util-naming");
const ifs_1 = require("./ifs");
const names_1 = require("./names");
const util_1 = require("./util");
class Typegen {
    static generate(options) {
        new Typegen(options).generate();
    }
    constructor(options) {
        this.options = options;
        this.sts = new Map();
        this.dir = new util_internal_code_printer_1.OutDir(options.outDir);
    }
    generate() {
        this.dir.del();
        this.generateEnums('events');
        this.generateEnums('calls');
        this.generateStorage();
        this.generateConsts();
        let index = this.dir.file('index.ts');
        this.sts.forEach((sts, runtime) => {
            if (sts.sink.isEmpty())
                return;
            let version = this.getVersionName(runtime);
            let file = this.dir.file(version + '.ts');
            file.line(`import {sts, Result, Option, Bytes, BitSequence} from './support'`);
            sts.sink.generate(file);
            file.write();
            index.line(`export * as ${version} from './${version}'`);
        });
        for (let [kind, items] of [
            ['events', this.events()],
            ['calls', this.calls()],
            ['constants', this.constants()],
            ['storage', this.storageItems()]
        ]) {
            if (items.length == 0)
                continue;
            index.line(`export * as ${kind} from './${kind}'`);
            let file = this.dir.file(kind + '.ts');
            for (let pallet of (0, util_1.groupBy)(items, it => it.name.split('.')[0]).keys()) {
                file.line(`export * as ${(0, util_1.toJsName)(pallet)} from './${getPalletDir(pallet)}/${kind}'`);
            }
            file.write();
        }
        index.write();
        this.dir.add('support.ts', [__dirname, '../src/support.ts']);
    }
    generateEnums(kind) {
        const fix = kind == 'events' ? 'Event' : 'Call';
        let items = this[kind]();
        for (let [pallet, palletItems] of (0, util_1.groupBy)(items, it => it.def.pallet)) {
            let file = new ItemFile(this, pallet, fix);
            let out = file.out;
            for (let [name, versions] of (0, util_1.groupBy)(palletItems, it => it.def.name)) {
                out.line();
                out.block(`export const ${(0, util_1.toJsName)(name)} = `, () => {
                    out.line(`name: '${pallet}.${name}',`);
                    for (let it of versions) {
                        let useSts = file.useSts(it.runtime);
                        out.blockComment(it.def.docs);
                        out.line(`${this.getVersionName(it.runtime)}: new ${fix}Type(`);
                        out.indentation(() => {
                            out.line(`'${pallet}.${name}',`);
                            if (it.def.fields.length == 0 || it.def.fields[0].name == null) {
                                if (it.def.fields.length == 1) {
                                    out.line(useSts(it.def.fields[0].type));
                                }
                                else {
                                    let list = it.def.fields.map(f => useSts(f.type)).join(', ');
                                    if (list) {
                                        out.line(`sts.tuple([${list}])`);
                                    }
                                    else {
                                        out.line('sts.unit()');
                                    }
                                }
                            }
                            else {
                                out.line('sts.struct({');
                                out.indentation(() => {
                                    for (let f of it.def.fields) {
                                        out.blockComment(f.docs);
                                        out.line(`${f.name}: ${useSts(f.type)},`);
                                    }
                                });
                                out.line('})');
                            }
                        });
                        out.line('),');
                    }
                });
            }
            file.write();
        }
    }
    generateConsts() {
        let items = this.constants();
        for (let [pallet, palletItems] of (0, util_1.groupBy)(items, it => (0, util_1.splitQualifiedName)(it.name)[0])) {
            let file = new ItemFile(this, pallet, 'Constant');
            let out = file.out;
            for (let [name, versions] of (0, util_1.groupBy)(palletItems, it => (0, util_1.splitQualifiedName)(it.name)[1])) {
                out.line();
                out.block(`export const ${(0, util_1.toJsName)(name)} = `, () => {
                    for (let it of versions) {
                        let useSts = file.useSts(it.runtime);
                        out.blockComment(it.def.docs);
                        out.line(`${this.getVersionName(it.runtime)}: new ConstantType(`);
                        out.indentation(() => {
                            out.line(`'${it.name}',`);
                            out.line(useSts(it.def.type));
                        });
                        out.line('),');
                    }
                });
            }
            file.write();
        }
    }
    generateStorage() {
        let items = this.storageItems();
        for (let [pallet, palletItems] of (0, util_1.groupBy)(items, it => (0, util_1.splitQualifiedName)(it.name)[0])) {
            let file = new ItemFile(this, pallet, 'Storage');
            let out = file.out;
            for (let [jsName, versions] of (0, util_1.groupBy)(palletItems, it => (0, util_1.toJsName)((0, util_1.splitQualifiedName)(it.name)[1]))) {
                let ifs = [];
                out.line();
                out.block(`export const ${jsName} = `, () => {
                    for (let it of versions) {
                        let ifName = (0, util_1.upperCaseFirst)((0, util_naming_1.toCamelCase)(`${jsName}_${this.getVersionName(it.runtime)}`));
                        let useSts = file.useSts(it.runtime);
                        let useIfs = file.useIfs(it.runtime);
                        let keyListExp = it.def.keys.map(ti => useSts(ti)).join(', ');
                        let valueExp = useSts(it.def.value);
                        out.blockComment(it.def.docs);
                        out.line(`${this.getVersionName(it.runtime)}: new StorageType(` +
                            `'${it.name}', ` +
                            `'${it.def.modifier}', ` +
                            `[${keyListExp}], ` +
                            `${valueExp}` +
                            `) as ${ifName},`);
                        ifs.push(() => {
                            out.line();
                            out.blockComment(it.def.docs);
                            out.block(`export interface ${ifName} `, () => {
                                out.line(`is(block: RuntimeCtx): boolean`);
                                let value = useIfs(it.def.value);
                                let keys = it.def.keys.map(ti => useIfs(ti));
                                let args = keys.length == 1
                                    ? [`key: ${keys[0]}`]
                                    : keys.map((exp, idx) => `key${idx + 1}: ${exp}`);
                                let fullKey = keys.length == 1 ? keys[0] : `[${keys.join(', ')}]`;
                                let ret = it.def.modifier == 'Required' ? value : `(${value} | undefined)`;
                                let kv = `[k: ${fullKey}, v: ${ret}]`;
                                function* enumeratePartialApps(leading) {
                                    let list = [];
                                    if (leading) {
                                        list.push(leading);
                                    }
                                    list.push('block: Block');
                                    yield list.join(', ');
                                    for (let arg of args) {
                                        list.push(arg);
                                        yield list.join(', ');
                                    }
                                }
                                if (it.def.modifier == 'Default') {
                                    out.line(`getDefault(block: Block): ${value}`);
                                }
                                out.line(`get(${['block: Block'].concat(args).join(', ')}): Promise<${ret}>`);
                                if (args.length > 0) {
                                    out.line(`getMany(block: Block, keys: ${fullKey}[]): Promise<${ret}[]>`);
                                    if (isStorageKeyDecodable(it.def)) {
                                        for (let args of enumeratePartialApps()) {
                                            out.line(`getKeys(${args}): Promise<${fullKey}[]>`);
                                        }
                                        for (let args of enumeratePartialApps('pageSize: number')) {
                                            out.line(`getKeysPaged(${args}): AsyncIterable<${fullKey}[]>`);
                                        }
                                        for (let args of enumeratePartialApps()) {
                                            out.line(`getPairs(${args}): Promise<${kv}[]>`);
                                        }
                                        for (let args of enumeratePartialApps('pageSize: number')) {
                                            out.line(`getPairsPaged(${args}): AsyncIterable<${kv}[]>`);
                                        }
                                    }
                                }
                            });
                        });
                    }
                });
                for (let i of ifs) {
                    i();
                }
            }
            file.write();
        }
    }
    events() {
        return this.collectItems(toItemRequest(this.options, 'events'), runtime => Object.entries(runtime.events.definitions).map(([name, def]) => {
            return { name, def, runtime };
        }), item => item.runtime.events.getTypeHash(item.name));
    }
    calls() {
        return this.collectItems(toItemRequest(this.options, 'calls'), runtime => Object.entries(runtime.calls.definitions).map(([name, def]) => {
            return { name, def, runtime };
        }), item => item.runtime.calls.getTypeHash(item.name));
    }
    storageItems() {
        return this.collectItems(toItemRequest(this.options, 'storage'), runtime => {
            let storage = runtime.description.storage;
            return getStorageItems(runtime).map(({ pallet, prefix, name }) => {
                let def = (0, util_internal_1.assertNotNull)(storage[pallet]?.items[name]);
                return {
                    runtime,
                    name: pallet + '.' + name,
                    def: { ...def, prefix }
                };
            });
        }, item => {
            return JSON.stringify({
                modifier: item.def.modifier,
                key: item.def.keys.map(ti => (0, sts_1.getTypeHash)(item.runtime.description.types, ti)),
                value: (0, sts_1.getTypeHash)(item.runtime.description.types, item.def.value)
            });
        }).filter(it => !isEmptyStorageItem(it));
    }
    constants() {
        return this.collectItems(toItemRequest(this.options, 'constants'), runtime => {
            let items = [];
            let consts = runtime.description.constants;
            for (let prefix in consts) {
                for (let name in consts[prefix]) {
                    items.push({
                        runtime,
                        name: prefix + '.' + name,
                        def: consts[prefix][name]
                    });
                }
            }
            return items;
        }, item => {
            let [prefix, name] = item.name.split('.');
            let def = item.runtime.description.constants[prefix][name];
            return (0, sts_1.getTypeHash)(item.runtime.description.types, def.type);
        });
    }
    collectItems(req, extract, hash) {
        let list = this.runtimes().flatMap(chain => extract(chain));
        let byName = (0, util_1.groupBy)(list, i => i.name);
        if (req !== true) {
            for (let qn of byName.keys()) {
                let [pallet, name] = (0, util_1.splitQualifiedName)(qn);
                let pr = req[pallet];
                if (!pr || Array.isArray(pr) && !pr.includes(name)) {
                    byName.delete(qn);
                }
            }
        }
        let items = [];
        byName.forEach(versions => {
            let unique = [];
            versions.forEach(v => {
                let prev = (0, util_internal_1.maybeLast)(unique);
                if (prev && hash(prev) === hash(v)) {
                }
                else {
                    unique.push(v);
                }
            });
            items.push(...unique);
        });
        return items;
    }
    getVersionName(runtime) {
        if (this.specNameNotChanged() || (0, util_internal_1.last)(this.runtimes()).specName == runtime.specName) {
            return `v${runtime.specVersion}`;
        }
        else {
            return (0, util_naming_1.toCamelCase)(`${runtime.specName}-v${runtime.specVersion}`);
        }
    }
    specNameNotChanged() {
        return new Set(this.runtimes().map(v => v.specName)).size < 2;
    }
    runtimes() {
        return this.options.specVersions.map(v => {
            return new substrate_runtime_1.Runtime({
                specName: v.specName,
                specVersion: v.specVersion,
                implName: '-',
                implVersion: 0
            }, v.metadata, this.options.typesBundle);
        });
    }
    getSts(runtime) {
        let sts = this.sts.get(runtime);
        if (sts)
            return sts;
        let sink = new ifs_1.Sink(runtime.description.types, (0, names_1.assignNames)(runtime.description));
        sts = new ifs_1.Sts(sink);
        this.sts.set(runtime, sts);
        return sts;
    }
}
exports.Typegen = Typegen;
__decorate([
    util_internal_1.def,
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Array)
], Typegen.prototype, "events", null);
__decorate([
    util_internal_1.def,
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Array)
], Typegen.prototype, "calls", null);
__decorate([
    util_internal_1.def,
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Array)
], Typegen.prototype, "storageItems", null);
__decorate([
    util_internal_1.def,
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Array)
], Typegen.prototype, "constants", null);
__decorate([
    util_internal_1.def,
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Boolean)
], Typegen.prototype, "specNameNotChanged", null);
__decorate([
    util_internal_1.def,
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Array)
], Typegen.prototype, "runtimes", null);
class ItemFile {
    constructor(typegen, pallet, type) {
        this.typegen = typegen;
        this.imported = new Set();
        this.out = this.typegen.dir
            .child(getPalletDir(pallet))
            .file(type == 'Storage' ? 'storage.ts' : type.toLowerCase() + 's.ts');
        this.out.line(`import {sts, Block, Bytes, Option, Result, ${type}Type, RuntimeCtx} from '../support'`);
        this.out.lazy(() => {
            Array.from(this.imported)
                .sort((a, b) => a.specVersion - b.specVersion)
                .forEach(runtime => {
                let name = this.typegen.getVersionName(runtime);
                this.out.line(`import * as ${name} from '../${name}'`);
            });
        });
    }
    useSts(runtime) {
        let sts = this.typegen.getSts(runtime);
        return ti => {
            let exp = sts.use(ti);
            return this.qualify(runtime, exp);
        };
    }
    useIfs(runtime) {
        let sts = this.typegen.getSts(runtime);
        return ti => {
            let exp = sts.ifs.use(ti);
            return this.qualify(runtime, exp);
        };
    }
    qualify(runtime, exp) {
        let version = this.typegen.getVersionName(runtime);
        let qualified = this.typegen.getSts(runtime).sink.qualify(version, exp);
        if (qualified != exp) {
            this.imported.add(runtime);
        }
        return qualified;
    }
    write() {
        this.out.write();
    }
}
function getStorageItems(runtime) {
    let metadata = runtime.metadata;
    switch (metadata.__kind) {
        case 'V9':
        case 'V10':
        case 'V11':
        case 'V12':
        case 'V13':
            return metadata.value
                .modules
                .flatMap(m => {
                if (!m.storage)
                    return [];
                let prefix = m.storage.prefix;
                return m.storage.items.map(it => {
                    return { prefix, pallet: m.name, name: it.name };
                });
            });
        case 'V14':
            return metadata.value
                .pallets
                .flatMap(m => {
                if (!m.storage)
                    return [];
                let prefix = m.storage.prefix;
                return m.storage.items.map(it => {
                    return { prefix, pallet: m.name, name: it.name };
                });
            });
        default:
            throw (0, util_internal_1.unexpectedCase)(metadata.__kind);
    }
}
function getPalletDir(pallet) {
    return (0, util_naming_1.toSnakeCase)(pallet).replace(/_/g, '-');
}
/**
 * Returns true when storage item actually can't hold any value
 */
function isEmptyStorageItem(item) {
    return (0, util_1.isEmptyVariant)(item.runtime.description.types[item.def.value]);
}
function isStorageKeyDecodable(item) {
    return item.hashers.every(hasher => {
        switch (hasher) {
            case 'Blake2_128Concat':
            case 'Twox64Concat':
            case 'Identity':
                return true;
            default:
                return false;
        }
    });
}
function toItemRequest(options, kind) {
    let list = options[kind];
    if (list === true)
        return true;
    let req = {};
    if (options.pallets) {
        for (let pallet in options.pallets) {
            let pr = options.pallets[pallet];
            if (pr === true) {
                req[pallet] = true;
            }
            else if (pr) {
                let ir = pr[kind];
                if (ir === true) {
                    req[pallet] = true;
                }
                else if (ir) {
                    req[pallet] = ir.slice();
                }
            }
        }
    }
    if (list) {
        for (let qualifiedName of list) {
            let [pallet, name] = (0, util_1.splitQualifiedName)(qualifiedName);
            let selected = req[pallet];
            if (selected === true)
                continue;
            if (Array.isArray(selected)) {
                selected.push(name);
            }
            else {
                req[pallet] = [name];
            }
        }
    }
    return req;
}
//# sourceMappingURL=typegen.js.map