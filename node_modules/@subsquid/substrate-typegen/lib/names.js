"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.needsName = exports.deriveName = exports.Names = exports.assignNames = void 0;
const metadata_1 = require("@subsquid/substrate-runtime/lib/metadata");
const sts_1 = require("@subsquid/substrate-runtime/lib/sts");
const assert_1 = __importDefault(require("assert"));
const util_1 = require("./util");
/**
 * Assign names to types
 */
function assignNames(d) {
    let names = new Names(d.types);
    // assign good names for events and calls
    names.assign(d.call, 'Call');
    names.assign(d.event, 'Event');
    forEachPallet(d.types, d.call, (pallet, ti) => {
        names.assign(ti, pallet + 'Call');
    });
    forEachPallet(d.types, d.event, (pallet, ti) => {
        names.assign(ti, pallet + 'Event');
    });
    return names.getAssignment();
}
exports.assignNames = assignNames;
function forEachPallet(types, ti, cb) {
    let type = types[ti];
    (0, assert_1.default)(type.kind == metadata_1.TypeKind.Variant);
    type.variants.forEach(v => {
        (0, assert_1.default)(v.fields.length == 1);
        let vi = v.fields[0].type;
        cb(v.name, vi);
    });
}
class Names {
    constructor(types) {
        this.types = types;
        this.assignment = new Map();
        this.assigned = new Map(); // Map<Name, TypeHash>
        this.reserved = new Set(['Result', 'Option', 'Bytes', 'BitSequence']);
        this.aliases = new Map();
    }
    assign(ti, name) {
        (0, assert_1.default)(this.isFree(name));
        this.assigned.set(name, (0, sts_1.getTypeHash)(this.types, ti));
        this.assignment.set(ti, name);
    }
    isFree(name) {
        return !(this.reserved.has(name) || this.assigned.has(name));
    }
    reserve(name) {
        (0, assert_1.default)(this.isFree(name));
        this.reserved.add(name);
    }
    alias(ti, name) {
        let aliases = this.aliases.get(ti);
        if (aliases) {
            aliases.add(name);
        }
        else {
            this.aliases.set(ti, new Set([name]));
        }
    }
    getAssignment() {
        this.types.forEach((type, ti) => {
            if (this.assignment.has(ti))
                return;
            if (!needsName(this.types, ti))
                return;
            let name = deriveName(type);
            if (name && this.isFree(name)) {
                this.assign(ti, name);
                return;
            }
            for (let name of this.aliases.get(ti)?.values() || []) {
                if (this.isFree(name)) {
                    this.assign(ti, name);
                    return;
                }
            }
            this.assign(ti, `Type_${ti}`);
        });
        this.types.forEach((type, ti) => {
            if (this.assignment.has(ti))
                return;
            if (type.kind == metadata_1.TypeKind.Sequence)
                return;
            let name = deriveName(type);
            if (name && this.isFree(name)) {
                this.assign(ti, name);
            }
        });
        this.types.forEach((type, ti) => {
            if (this.assignment.has(ti))
                return;
            if (type.kind == metadata_1.TypeKind.Sequence)
                return;
            let aliases = this.aliases.get(ti);
            if (aliases?.size !== 1)
                return;
            let name = Array.from(aliases)[0];
            if (this.isFree(name)) {
                this.assign(ti, name);
            }
        });
        return this.assignment;
    }
}
exports.Names = Names;
/**
 * Derive "the best" name from the path.
 */
function deriveName(type) {
    if (!type.path?.length)
        return undefined;
    let version = type.path.find(name => /^v\d+$/i.test(name));
    let name = type.path[type.path.length - 1];
    if (version && version !== name) {
        return `V${version.slice(1)}${name}`;
    }
    else {
        return name;
    }
}
exports.deriveName = deriveName;
function needsName(types, ti) {
    let ty = types[ti];
    switch (ty.kind) {
        case metadata_1.TypeKind.Variant:
            return !(0, util_1.asResultType)(ty) && !(0, util_1.asOptionType)(ty);
        case metadata_1.TypeKind.Composite:
            return true;
        default:
            return false;
    }
}
exports.needsName = needsName;
//# sourceMappingURL=names.js.map