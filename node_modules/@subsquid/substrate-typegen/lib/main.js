"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const http_client_1 = require("@subsquid/http-client");
const logger_1 = require("@subsquid/logger");
const specVersion_1 = require("@subsquid/substrate-metadata-explorer/lib/specVersion");
const metadata_1 = require("@subsquid/substrate-runtime/lib/metadata");
const util_internal_1 = require("@subsquid/util-internal");
const util_internal_config_1 = require("@subsquid/util-internal-config");
const commander_1 = require("commander");
const config_1 = require("./config");
const typegen_1 = require("./typegen");
const log = (0, logger_1.createLogger)('sqd:substrate-typegen');
(0, util_internal_1.runProgram)(async () => {
    let program = new commander_1.Command();
    program.description(`
Generates TypeScript classes for events, calls and storage items
    `.trim());
    program.argument('[config...]', 'JSON file with options');
    for (let configFile of program.parse().processedArgs[0]) {
        log.info(`using ${configFile}`);
        let config = await (0, config_1.readConfig)(configFile);
        let typesBundle;
        if (config.typesBundle) {
            typesBundle = (0, metadata_1.getOldTypesBundle)(config.typesBundle) || (0, metadata_1.readOldTypesBundle)(config.typesBundle);
        }
        let specVersions;
        if (/^https?:\/\//.test(config.specVersions)) {
            log.info(`downloading spec versions from ${config.specVersions}`);
            specVersions = await downloadSpecVersions(config.specVersions);
        }
        else {
            specVersions = (0, specVersion_1.readSpecVersions)(config.specVersions);
        }
        typegen_1.Typegen.generate({
            outDir: config.outDir,
            specVersions,
            typesBundle,
            events: config.events,
            calls: config.calls,
            storage: config.storage,
            constants: config.constants,
            pallets: config.pallets
        });
    }
}, err => {
    if (err instanceof util_internal_config_1.ConfigError || err instanceof metadata_1.OldTypesBundleError || err instanceof specVersion_1.SpecFileError) {
        log.fatal(err.message);
    }
    else {
        log.fatal(err);
    }
});
async function downloadSpecVersions(url) {
    let versions = [];
    let http = new http_client_1.HttpClient();
    let res = await http.get(url, { stream: true });
    for await (let line of lines(res)) {
        let rec = JSON.parse(line);
        let error = (0, specVersion_1.validateSpecVersion)(rec);
        if (error)
            throw new Error(`invalid spec record in response: ${error}`);
        versions.push(rec);
    }
    return versions;
}
async function* lines(input) {
    input.setEncoding('utf-8');
    let buf = '';
    for await (let chunk of input) {
        let ls = chunk.split(/\r\n|\n|\r/);
        if (ls.length == 1) {
            buf += ls[0];
        }
        else {
            for (let i = 0; i < ls.length - 1; i++) {
                let line = buf + ls[i];
                if (line) {
                    yield line;
                    buf = '';
                }
            }
            buf = (0, util_internal_1.last)(ls);
        }
    }
    if (buf) {
        yield buf;
    }
}
//# sourceMappingURL=main.js.map