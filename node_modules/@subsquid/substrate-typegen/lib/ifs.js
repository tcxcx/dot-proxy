"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Sts = exports.Interfaces = exports.Sink = void 0;
const metadata_1 = require("@subsquid/substrate-runtime/lib/metadata");
const util_internal_1 = require("@subsquid/util-internal");
const assert_1 = __importDefault(require("assert"));
const names_1 = require("./names");
const util_1 = require("./util");
class Sink {
    constructor(types, nameAssignment) {
        this.types = types;
        this.nameAssignment = nameAssignment;
        this.queue = [];
        this.assignedNames = new Set();
        for (let name of this.nameAssignment.values()) {
            this.assignedNames.add(name);
        }
    }
    push(cb) {
        this.queue.push(cb);
    }
    getName(ti) {
        return (0, util_internal_1.assertNotNull)(this.nameAssignment.get(ti));
    }
    hasName(ti) {
        return this.nameAssignment.has(ti);
    }
    needsName(ti) {
        return (0, names_1.needsName)(this.types, ti);
    }
    isEmpty() {
        return this.queue.length == 0;
    }
    generate(out) {
        let cb;
        while (cb = this.queue.pop()) {
            cb(out);
        }
    }
    qualify(ns, exp) {
        let names = exp
            .split(/[<>&|,()\[\]{}:]/)
            .map(t => t.trim())
            .filter(t => !!t);
        let local = new Set(names.filter(name => this.assignedNames.has(name)));
        local.forEach(name => {
            exp = exp.replace(new RegExp(`\\b${name}\\b`, 'g'), ns + '.' + name);
        });
        return exp;
    }
}
exports.Sink = Sink;
class Interfaces {
    constructor(sink) {
        this.sink = sink;
        this.generatedNames = new Set();
        this.generated = new Array(this.sink.types.length).fill('');
    }
    use(ti) {
        let exp = this.generated[ti];
        if (exp)
            return exp;
        exp = this.makeType(ti);
        if (!this.sink.needsName(ti) && this.sink.hasName(ti)) {
            let alias = this.getName(ti);
            if (!this.generatedNames.has(alias)) {
                this.generatedNames.add(alias);
                let def = exp;
                this.sink.push(out => {
                    out.line();
                    out.blockComment(this.sink.types[ti].docs);
                    out.line(`export type ${alias} = ${def}`);
                });
            }
            exp = alias;
        }
        return this.generated[ti] = exp;
    }
    getName(ti) {
        return this.sink.getName(ti);
    }
    makeType(ti) {
        let ty = this.sink.types[ti];
        switch (ty.kind) {
            case metadata_1.TypeKind.Primitive:
                return (0, util_1.toNativePrimitive)(ty.primitive);
            case metadata_1.TypeKind.Compact: {
                let compact = this.sink.types[ty.type];
                (0, assert_1.default)(compact.kind == metadata_1.TypeKind.Primitive);
                return (0, util_1.toNativePrimitive)(compact.primitive);
            }
            case metadata_1.TypeKind.BitSequence:
                return 'BitSequence';
            case metadata_1.TypeKind.HexBytes:
            case metadata_1.TypeKind.HexBytesArray:
                return 'Bytes';
            case metadata_1.TypeKind.Sequence:
            case metadata_1.TypeKind.Array:
                return this.use(ty.type) + '[]';
            case metadata_1.TypeKind.Tuple:
                return this.makeTuple(ty.tuple);
            case metadata_1.TypeKind.Composite:
                if (ty.fields.length == 0 || ty.fields[0].name == null) {
                    return this.makeTuple(ty.fields.map(f => {
                        (0, assert_1.default)(f.name == null);
                        return f.type;
                    }));
                }
                else {
                    return this.makeStruct(ty, ti);
                }
            case metadata_1.TypeKind.Variant: {
                let result = (0, util_1.asResultType)(ty);
                if (result) {
                    let ok = result.ok == null ? 'null' : this.use(result.ok);
                    let err = result.err == null ? 'null' : this.use(result.err);
                    return `Result<${ok}, ${err}>`;
                }
                let option = (0, util_1.asOptionType)(ty);
                if (option) {
                    let some = option.some == null ? 'null' : this.use(option.some);
                    return `Option<${some}>`;
                }
                return this.makeVariant(ty, ti);
            }
            case metadata_1.TypeKind.Option:
                return `(${this.use(ty.type)} | undefined)`;
            case metadata_1.TypeKind.DoNotConstruct:
                return 'never';
            default:
                throw (0, util_internal_1.unexpectedCase)(ty.kind);
        }
    }
    makeTuple(fields) {
        if (fields.length == 0)
            return 'null';
        return '[' + fields.map(f => this.use(f)).join(', ') + ']';
    }
    makeStruct(type, ti) {
        let name = this.getName(ti);
        if (this.generatedNames.has(name))
            return name;
        this.generatedNames.add(name);
        this.sink.push(out => {
            out.line();
            out.blockComment(this.sink.types[ti].docs);
            out.block(`export interface ${name}`, () => {
                this.printStructFields(out, type.fields);
            });
        });
        return name;
    }
    printStructFields(out, fields) {
        fields.forEach(f => {
            let name = (0, util_internal_1.assertNotNull)(f.name);
            let exp = this.use(f.type);
            let opt = this.isUndefined(f.type) ? '?' : '';
            out.blockComment(f.docs);
            out.line(`${name}${opt}: ${exp}`);
        });
    }
    isUndefined(ti) {
        return this.sink.types[ti].kind == metadata_1.TypeKind.Option;
    }
    isUnit(ti) {
        let ty = this.sink.types[ti];
        switch (ty.kind) {
            case metadata_1.TypeKind.Composite:
                return ty.fields.length == 0;
            case metadata_1.TypeKind.Tuple:
                return ty.tuple.length == 0;
            default:
                return false;
        }
    }
    makeVariant(type, ti) {
        let name = this.getName(ti);
        if (this.generatedNames.has(name))
            return name;
        this.generatedNames.add(name);
        this.sink.push(out => {
            out.line();
            out.blockComment(type.docs);
            if (type.variants.length == 0) {
                out.line(`export type ${name} = never`);
                return;
            }
            out.line(`export type ${name} = ${type.variants.map(v => name + '_' + v.name).join(' | ')}`);
            type.variants.forEach(v => {
                out.line();
                out.blockComment(v.docs);
                out.block(`export interface ${name + '_' + v.name}`, () => {
                    out.line(`__kind: '${v.name}'`);
                    if (v.fields.length > 0) {
                        if (v.fields[0].name != null) {
                            this.printStructFields(out, v.fields);
                        }
                        else if (v.fields.length == 1) {
                            let ti = v.fields[0].type;
                            if (!this.isUnit(ti)) {
                                let opt = this.isUndefined(ti) ? '?' : '';
                                out.line(`value${opt}: ${this.use(ti)}`);
                            }
                        }
                        else {
                            out.line(`value: ${this.makeTuple(v.fields.map(f => f.type))}`);
                        }
                    }
                });
            });
        });
        return name;
    }
}
exports.Interfaces = Interfaces;
class Sts {
    constructor(sink) {
        this.sink = sink;
        this.generatedNames = new Set();
        this.ifs = new Interfaces(this.sink);
        this.generated = new Array(this.sink.types.length).fill('');
    }
    use(ti) {
        let exp = this.generated[ti];
        if (exp)
            return exp;
        exp = this.makeType(ti);
        if (!this.sink.needsName(ti) && this.sink.hasName(ti)) {
            let alias = this.sink.getName(ti);
            if (!this.generatedNames.has(alias)) {
                this.generatedNames.add(alias);
                let def = exp;
                this.sink.push(out => {
                    out.line();
                    out.blockComment(this.sink.types[ti].docs);
                    out.line(`export const ${alias} = ${def}`);
                });
            }
            exp = alias;
        }
        return this.generated[ti] = exp;
    }
    makeType(ti) {
        let ty = this.sink.types[ti];
        switch (ty.kind) {
            case metadata_1.TypeKind.Primitive:
                return `sts.${(0, util_1.toNativePrimitive)(ty.primitive)}()`;
            case metadata_1.TypeKind.Compact: {
                let compact = this.sink.types[ty.type];
                (0, assert_1.default)(compact.kind == metadata_1.TypeKind.Primitive);
                return `sts.${(0, util_1.toNativePrimitive)(compact.primitive)}()`;
            }
            case metadata_1.TypeKind.BitSequence:
                return `sts.bitseq()`;
            case metadata_1.TypeKind.HexBytes:
            case metadata_1.TypeKind.HexBytesArray:
                return 'sts.bytes()';
            case metadata_1.TypeKind.Sequence:
            case metadata_1.TypeKind.Array:
                return `sts.array(() => ${this.use(ty.type)})`;
            case metadata_1.TypeKind.Tuple:
                return this.renderTuple(ty.tuple);
            case metadata_1.TypeKind.Composite:
                if (ty.fields.length == 0 || ty.fields[0].name == null) {
                    return this.renderTuple(ty.fields.map(f => f.type));
                }
                else {
                    return this.makeStruct(ty, ti);
                }
            case metadata_1.TypeKind.Variant: {
                let result = (0, util_1.asResultType)(ty);
                if (result) {
                    let ok = result.ok == null ? 'sts.unit()' : this.use(result.ok);
                    let err = result.err == null ? 'sts.unit()' : this.use(result.err);
                    return `sts.result(() => ${ok}, () => ${err})`;
                }
                let option = (0, util_1.asOptionType)(ty);
                if (option) {
                    let some = option.some == null ? 'sts.unit()' : this.use(option.some);
                    return `sts.enumOption(() => ${some})`;
                }
                return this.makeVariant(ty, ti);
            }
            case metadata_1.TypeKind.Option:
                return `sts.option(() => ${this.use(ty.type)})`;
            default:
                throw (0, util_internal_1.unexpectedCase)();
        }
    }
    makeStruct(ty, ti) {
        let name = this.sink.getName(ti);
        if (this.generatedNames.has(name))
            return name;
        this.generatedNames.add(name);
        this.sink.push(out => {
            out.line();
            out.line(`export const ${name}: sts.Type<${this.ifs.use(ti)}> = sts.struct(() => {`);
            out.indentation(() => {
                out.block('return ', () => this.printStructFields(out, ty.fields));
            });
            out.line('})');
        });
        return name;
    }
    printStructFields(out, fields) {
        fields.forEach(f => {
            let name = (0, util_internal_1.assertNotNull)(f.name);
            let exp = this.use(f.type);
            out.line(`${name}: ${exp},`);
        });
    }
    makeVariant(ty, ti) {
        let name = this.sink.getName(ti);
        if (this.generatedNames.has(name))
            return name;
        this.generatedNames.add(name);
        this.sink.push(out => {
            out.line();
            out.blockComment(ty.docs);
            out.line(`export const ${name}: sts.Type<${this.ifs.use(ti)}> = sts.closedEnum(() => {`);
            out.indentation(() => {
                out.block('return ', () => {
                    for (let v of ty.variants) {
                        if (v.fields.length == 0 || v.fields[0].name == null) {
                            if (v.fields.length == 1) {
                                out.line(`${v.name}: ${this.use(v.fields[0].type)},`);
                            }
                            else {
                                out.line(`${v.name}: ${this.renderTuple(v.fields.map(f => f.type))},`);
                            }
                        }
                        else {
                            out.line(`${v.name}: sts.enumStruct({`);
                            out.indentation(() => this.printStructFields(out, v.fields));
                            out.line('}),');
                        }
                    }
                });
            });
            out.line('})');
        });
        return name;
    }
    renderTuple(tuple) {
        let list = tuple.map(ti => this.use(ti)).join(', ');
        return list ? `sts.tuple(() => [${list}])` : 'sts.unit()';
    }
}
exports.Sts = Sts;
//# sourceMappingURL=ifs.js.map