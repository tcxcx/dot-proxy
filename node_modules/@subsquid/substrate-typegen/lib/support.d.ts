import type { BitSequence, Bytes, QualifiedName, Runtime } from '@subsquid/substrate-runtime';
import * as sts from '@subsquid/substrate-runtime/lib/sts';
import { Option, Result } from '@subsquid/substrate-runtime/lib/sts';
export { sts, Bytes, BitSequence, Option, Result };
export interface RuntimeCtx {
    _runtime: Runtime;
}
export interface Block extends RuntimeCtx {
    hash: Bytes;
    height: number;
}
interface Event {
    block: RuntimeCtx;
    name: QualifiedName;
    args: unknown;
}
interface Call {
    block: RuntimeCtx;
    name: QualifiedName;
    args: unknown;
}
export declare class EventType<T extends sts.Type> {
    readonly name: QualifiedName;
    private type;
    constructor(name: QualifiedName, type: T);
    matches(block: RuntimeCtx): boolean;
    is(event: Event): boolean;
    decode(event: Event): sts.GetType<T>;
}
export declare class CallType<T extends sts.Type> {
    readonly name: QualifiedName;
    private type;
    constructor(name: QualifiedName, type: T);
    matches(block: RuntimeCtx): boolean;
    is(call: Call): boolean;
    decode(call: Call): sts.GetType<T>;
}
export declare class ConstantType<T extends sts.Type> {
    private name;
    private type;
    constructor(name: QualifiedName, type: T);
    is(block: RuntimeCtx): boolean;
    get(block: RuntimeCtx): sts.GetType<T>;
}
export declare class StorageType {
    private name;
    private modifier;
    private key;
    private value;
    constructor(name: QualifiedName, modifier: 'Required' | 'Optional' | 'Default', key: sts.Type[], value: sts.Type);
    is(block: RuntimeCtx): boolean;
    get(block: Block, ...key: any[]): Promise<any>;
    getAll(block: Block): Promise<any[]>;
    getMany(block: Block, keys: any[]): Promise<any[]>;
    getKeys(block: Block, ...args: any[]): Promise<any[]>;
    getRawKeys(block: Block, ...args: any[]): Promise<Bytes[]>;
    getKeysPaged(pageSize: number, block: Block, ...args: any[]): AsyncIterable<any[]>;
    getPairs(block: Block, ...args: any[]): Promise<[key: any, value: any][]>;
    getPairsPaged(pageSize: number, block: Block, ...args: any[]): AsyncIterable<[key: any, value: any][]>;
    getDefault(block: Block): any;
}
//# sourceMappingURL=support.d.ts.map