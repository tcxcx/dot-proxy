"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.splitQualifiedName = exports.toJsName = exports.upperCaseFirst = exports.groupBy = exports.toNativePrimitive = exports.asOptionType = exports.asResultType = exports.isEmptyVariant = void 0;
const metadata_1 = require("@subsquid/substrate-runtime/lib/metadata");
const util_internal_1 = require("@subsquid/util-internal");
const util_naming_1 = require("@subsquid/util-naming");
function isEmptyVariant(type) {
    return type.kind == metadata_1.TypeKind.Variant && type.variants.length == 0;
}
exports.isEmptyVariant = isEmptyVariant;
function asResultType(type) {
    if (type.kind != metadata_1.TypeKind.Variant)
        return;
    if (type.variants.length != 2)
        return;
    let ok = type.variants.find(v => v.name == 'Ok');
    if (ok == null)
        return;
    let err = type.variants.find(v => v.name == 'Err');
    if (err == null)
        return;
    if (isValueVariant(ok) && isValueVariant(err))
        return {
            ok: ok.fields[0]?.type,
            err: err.fields[0]?.type
        };
}
exports.asResultType = asResultType;
function asOptionType(type) {
    if (type.kind !== metadata_1.TypeKind.Variant)
        return;
    if (type.variants.length != 2)
        return;
    let some = type.variants.find(v => v.name == 'Some');
    if (some == null)
        return;
    let none = type.variants.find(v => v.name == 'None');
    if (none == null)
        return;
    if (isValueVariant(some) && none.fields.length == 0)
        return {
            some: some.fields[0]?.type
        };
}
exports.asOptionType = asOptionType;
function isValueVariant(v) {
    return v.fields.length < 2 && v.fields[0]?.name == null;
}
function toNativePrimitive(primitive) {
    switch (primitive) {
        case "I8":
        case "U8":
        case "I16":
        case "U16":
        case "I32":
        case "U32":
            return "number";
        case "I64":
        case "U64":
        case "I128":
        case "U128":
        case "I256":
        case "U256":
            return "bigint";
        case "Bool":
            return "boolean";
        case "Str":
            return "string";
        default:
            throw (0, util_internal_1.unexpectedCase)(primitive);
    }
}
exports.toNativePrimitive = toNativePrimitive;
function groupBy(arr, group) {
    let grouping = new Map();
    for (let i = 0; i < arr.length; i++) {
        let item = arr[i];
        let key = group(item);
        let g = grouping.get(key);
        if (g == null) {
            grouping.set(key, [item]);
        }
        else {
            g.push(item);
        }
    }
    return grouping;
}
exports.groupBy = groupBy;
function upperCaseFirst(s) {
    return s[0].toUpperCase() + s.slice(1);
}
exports.upperCaseFirst = upperCaseFirst;
const jsReservedKeywords = new Set([
    'break',
    'case',
    'catch',
    'class',
    'const',
    'continue',
    'debugger',
    'default',
    'delete',
    'do',
    'else',
    'export',
    'extends',
    'false',
    'finally',
    'for',
    'function',
    'if',
    'import',
    'in',
    'instanceof',
    'new',
    'null',
    'return',
    'super',
    'switch',
    'this',
    'throw',
    'true',
    'try',
    'typeof',
    'var',
    'void',
    'while',
    'with',
    'let',
    'static',
    'yield',
    'await'
]);
function toJsName(name) {
    name = (0, util_naming_1.toCamelCase)(name);
    if (jsReservedKeywords.has(name)) {
        return name + '_';
    }
    else {
        return name;
    }
}
exports.toJsName = toJsName;
function splitQualifiedName(qualifiedName) {
    let parts = qualifiedName.split('.');
    if (parts.length != 2)
        throw new Error(`Invalid qualified name '${qualifiedName}'. ` +
            `Qualified name should follow {Pallet}.{item} pattern, e.g. 'Balances.Transfer'`);
    return [parts[0], parts[1]];
}
exports.splitQualifiedName = splitQualifiedName;
//# sourceMappingURL=util.js.map