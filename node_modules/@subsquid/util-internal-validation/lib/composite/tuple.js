"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.TupleValidator = void 0;
const error_1 = require("../error");
class TupleValidator {
    constructor(tuple) {
        this.tuple = tuple;
    }
    getInvalidLengthMessage() {
        if (this.invalidLengthMessage)
            return this.invalidLengthMessage;
        return this.invalidLengthMessage = `{value} is not a tuple of length ${this.tuple.length}`;
    }
    cast(value) {
        if (!Array.isArray(value))
            return new error_1.ValidationFailure(value, `{value} is not a tuple`);
        if (value.length !== this.tuple.length)
            return new error_1.ValidationFailure(value, this.getInvalidLengthMessage());
        let result = new Array(this.tuple.length);
        for (let i = 0; i < this.tuple.length; i++) {
            let v = this.tuple[i].cast(value[i]);
            if (v instanceof error_1.ValidationFailure) {
                v.path.push(i);
                return v;
            }
            else {
                result[i] = v;
            }
        }
        return result;
    }
    validate(value) {
        if (!Array.isArray(value))
            return new error_1.ValidationFailure(value, `{value} is not a tuple`);
        if (value.length !== this.tuple.length)
            return new error_1.ValidationFailure(value, this.getInvalidLengthMessage());
        for (let i = 0; i < this.tuple.length; i++) {
            let err = this.tuple[i].validate(value[i]);
            if (err) {
                err.path.push(i);
                return err;
            }
        }
    }
    phantom() {
        throw new Error();
    }
}
exports.TupleValidator = TupleValidator;
//# sourceMappingURL=tuple.js.map