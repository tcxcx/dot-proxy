"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.assertValidity = exports.cast = exports.constant = exports.oneOf = exports.ref = exports.withDefault = exports.withSentinel = exports.nullable = exports.option = exports.array = exports.tuple = exports.keyTaggedUnion = exports.taggedUnion = exports.record = exports.object = void 0;
const array_1 = require("./composite/array");
const constant_1 = require("./composite/constant");
const default_1 = require("./composite/default");
const key_tagged_union_1 = require("./composite/key-tagged-union");
const nullable_1 = require("./composite/nullable");
const object_1 = require("./composite/object");
const one_of_1 = require("./composite/one-of");
const option_1 = require("./composite/option");
const record_1 = require("./composite/record");
const ref_1 = require("./composite/ref");
const sentinel_1 = require("./composite/sentinel");
const tagged_union_1 = require("./composite/tagged-union");
const tuple_1 = require("./composite/tuple");
const error_1 = require("./error");
function object(props) {
    let presentProps = {};
    for (let key in props) {
        let v = props[key];
        if (v) {
            presentProps[key] = v;
        }
    }
    return new object_1.ObjectValidator(presentProps);
}
exports.object = object;
function record(key, value) {
    return new record_1.RecordValidator(key, value);
}
exports.record = record;
function taggedUnion(field, variants) {
    return new tagged_union_1.TaggedUnion(field, variants);
}
exports.taggedUnion = taggedUnion;
function keyTaggedUnion(variants) {
    return new key_tagged_union_1.KeyTaggedUnionValidator(variants);
}
exports.keyTaggedUnion = keyTaggedUnion;
function tuple(...tuple) {
    return new tuple_1.TupleValidator(tuple);
}
exports.tuple = tuple;
function array(item) {
    return new array_1.ArrayValidator(item);
}
exports.array = array;
function option(item) {
    return new option_1.OptionValidator(item);
}
exports.option = option;
function nullable(item) {
    return new nullable_1.NullableValidator(item);
}
exports.nullable = nullable;
function withSentinel(label, value, validator) {
    return new sentinel_1.Sentinel(label, value, validator);
}
exports.withSentinel = withSentinel;
function withDefault(value, validator) {
    return new default_1.Default(value, validator);
}
exports.withDefault = withDefault;
function ref(get) {
    return new ref_1.RefValidator(get);
}
exports.ref = ref;
function oneOf(patterns) {
    return new one_of_1.OneOfValidator(patterns);
}
exports.oneOf = oneOf;
function constant(value, equals) {
    return new constant_1.ConstantValidator(value, equals);
}
exports.constant = constant;
function cast(validator, value) {
    let result = validator.cast(value);
    if (result instanceof error_1.ValidationFailure)
        throw new error_1.DataValidationError(result.toString());
    return result;
}
exports.cast = cast;
function assertValidity(validator, value) {
    let err = validator.validate(value);
    if (err)
        throw new error_1.DataValidationError(err.toString());
}
exports.assertValidity = assertValidity;
//# sourceMappingURL=dsl.js.map