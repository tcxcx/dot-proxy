"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.BOOLEAN = exports.B64 = exports.B58 = exports.BYTES = exports.SMALL_QTY = exports.QTY = exports.STRING_FLOAT = exports.STRING_NAT = exports.ANY_NAT = exports.BIG_NAT = exports.NAT = exports.ANY_INT = exports.INT = exports.STRING = exports.ANY_OBJECT = exports.ANY = void 0;
const error_1 = require("./error");
exports.ANY = {
    cast(value) {
        return value;
    },
    validate(value) {
        return;
    },
    phantom() {
        throw new Error('Function not implemented.');
    }
};
exports.ANY_OBJECT = {
    cast(value) {
        return this.validate(value) || value;
    },
    validate(value) {
        if (value && typeof value == 'object')
            return;
        return new error_1.ValidationFailure(value, '{value} is not an object');
    },
    phantom() {
        return {};
    }
};
exports.STRING = {
    cast(value) {
        if (typeof value == 'string') {
            return value;
        }
        else {
            return new error_1.ValidationFailure(value, '{value} is not a string');
        }
    },
    validate(value) {
        if (typeof value == 'string')
            return;
        return new error_1.ValidationFailure(value, '{value} is not a string');
    },
    phantom() {
        return '';
    }
};
/**
 * Safe integer
 */
exports.INT = {
    cast(value) {
        if (isSafeInteger(value)) {
            return value;
        }
        else {
            return new error_1.ValidationFailure(value, '{value} is not an integer');
        }
    },
    validate(value) {
        if (isSafeInteger(value))
            return;
        return new error_1.ValidationFailure(value, '{value} is not an integer');
    },
    phantom() {
        return 0;
    }
};
exports.ANY_INT = {
    cast(value) {
        if (isSafeInteger(value) || isBigNat(value)) {
            return BigInt(value);
        }
        else {
            return new error_1.ValidationFailure(value, '{value} is not an integer');
        }
    },
    validate(value) {
        if (isSafeInteger(value) || isBigNat(value))
            return;
        return new error_1.ValidationFailure(value, '{value} is not an integer');
    },
    phantom() {
        return 0;
    }
};
function isSafeInteger(value) {
    return typeof value == 'number' && Number.isSafeInteger(value);
}
function isBigNat(value) {
    return typeof value == 'string' && /^\d+$/.test(value);
}
/**
 * Safe integer greater or equal to 0
 */
exports.NAT = {
    cast(value) {
        if (isSafeInteger(value) && value >= 0) {
            return value;
        }
        else {
            return new error_1.ValidationFailure(value, '{value} is not a safe natural number');
        }
    },
    validate(value) {
        if (isSafeInteger(value) && value >= 0)
            return;
        return new error_1.ValidationFailure(value, '{value} is not a safe natural number');
    },
    phantom() {
        return 0;
    }
};
exports.BIG_NAT = {
    cast(value) {
        if (isBigNat(value)) {
            return BigInt(value);
        }
        else {
            return new error_1.ValidationFailure(value, '{value} is not a string representing natural number');
        }
    },
    validate(value) {
        if (isBigNat(value))
            return;
        return new error_1.ValidationFailure(value, '{value} is not a string representing natural number');
    },
    phantom() {
        return '0';
    }
};
exports.ANY_NAT = {
    cast(value) {
        if (isSafeInteger(value) && value >= 0 || isBigNat(value)) {
            return BigInt(value);
        }
        else {
            return new error_1.ValidationFailure(value, '{value} is not a natural number');
        }
    },
    validate(value) {
        if (isSafeInteger(value) && value >= 0 || isBigNat(value))
            return;
        return new error_1.ValidationFailure(value, '{value} is not a natural number');
    },
    phantom() {
        return 0;
    }
};
exports.STRING_NAT = {
    cast(value) {
        if (typeof value == 'string') {
            let val = parseInt(value);
            if (Number.isSafeInteger(val)) {
                return val;
            }
            else {
                return new error_1.ValidationFailure(value, `{value} is not a safe integer`);
            }
        }
        else {
            return new error_1.ValidationFailure(value, '{value} is not a string natural number');
        }
    },
    validate(value) {
        let i = this.cast(value);
        if (i instanceof error_1.ValidationFailure)
            return i;
    },
    phantom() {
        return '0';
    }
};
exports.STRING_FLOAT = {
    cast(value) {
        if (typeof value == 'string') {
            let val = parseFloat(value);
            if (Number.isNaN(val)) {
                return new error_1.ValidationFailure(value, `{value} is not a number`);
            }
            else {
                return val;
            }
        }
        else {
            return new error_1.ValidationFailure(value, '{value} is not a string float number');
        }
    },
    validate(value) {
        let i = this.cast(value);
        if (i instanceof error_1.ValidationFailure)
            return i;
    },
    phantom() {
        return '0';
    }
};
function isBytes(value) {
    return typeof value == 'string' && /^0x[0-9a-fA-F]*$/.test(value);
}
/**
 * Hex encoded natural number of an arbitrary size
 */
exports.QTY = {
    cast(value) {
        if (isBytes(value)) {
            return BigInt(value);
        }
        else {
            return new error_1.ValidationFailure(value, `{value} is not a hex encoded natural number`);
        }
    },
    validate(value) {
        if (isBytes(value))
            return;
        return new error_1.ValidationFailure(value, `{value} is not a hex encoded natural number`);
    },
    phantom() {
        return '0x0';
    }
};
/**
 * Hex encoded safe natural number
 */
exports.SMALL_QTY = {
    cast(value) {
        if (isBytes(value)) {
            let val = parseInt(value);
            if (Number.isSafeInteger(val)) {
                return val;
            }
            else {
                return new error_1.ValidationFailure(value, `{value} is not a safe integer`);
            }
        }
        else {
            return new error_1.ValidationFailure(value, `{value} is not a hex encoded natural number`);
        }
    },
    validate(value) {
        let i = this.cast(value);
        if (i instanceof error_1.ValidationFailure)
            return i;
    },
    phantom() {
        return '0x0';
    }
};
/**
 * Hex encoded binary string
 */
exports.BYTES = {
    cast(value) {
        return this.validate(value) || value.toLowerCase();
    },
    validate(value) {
        if (isBytes(value))
            return;
        return new error_1.ValidationFailure(value, `{value} is not a hex encoded binary string`);
    },
    phantom() {
        return '0x';
    }
};
/**
 * Base58 encoded binary string
 */
exports.B58 = {
    cast(value) {
        if (isBase58(value))
            return value;
        return new error_1.ValidationFailure(value, `{value} is not a base58 string`);
    },
    validate(value) {
        if (isBase58(value))
            return;
        return new error_1.ValidationFailure(value, `{value} is not a base58 string`);
    },
    phantom() {
        throw new Error('Function not implemented.');
    }
};
function isBase58(value) {
    return typeof value == 'string' &&
        /^[123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz]*$/.test(value);
}
/**
 * Base64 encoded binary string
 */
exports.B64 = {
    cast(value) {
        if (isBase64(value))
            return value;
        return new error_1.ValidationFailure(value, `{value} is not a base64 string`);
    },
    validate(value) {
        if (isBase64(value))
            return;
        return new error_1.ValidationFailure(value, `{value} is not a base64 string`);
    },
    phantom() {
        throw new Error('Function not implemented.');
    }
};
function isBase64(value) {
    return typeof value == 'string' &&
        /^[0-9a-zA-Z+\/]*={0,2}$/.test(value);
}
exports.BOOLEAN = {
    cast(value) {
        return this.validate(value) || value;
    },
    validate(value) {
        if (typeof value === 'boolean')
            return;
        return new error_1.ValidationFailure(value, `{value} is not a boolean`);
    },
    phantom() {
        return false;
    }
};
//# sourceMappingURL=primitives.js.map